buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[S]
if ( modulus == 0 ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[MathMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( modulus == 0 ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI2Mutator]MSP[N] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[InlineConstantMutator]MSP[N] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
public boolean isUrlSafe () { MST[rv.CRCR5Mutator]MSP[S] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[VoidMethodCallMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.OBBN2Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; MST[experimental.MemberVariableMutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR3Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR3Mutator]MSP[S] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.ABSMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[N]
currentLinePos += 4 ; MST[rv.CRCR4Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR3Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.OBBN1Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.ROR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NonVoidMethodCallMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[experimental.MemberVariableMutator]MSP[S]
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ReturnValsMutator]MSP[N] switch ( byteToCheck ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR1Mutator]MSP[N] }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[N] if ( eof ) { return; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR2Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , MST[ReturnValsMutator]MSP[N] isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { MST[rv.ROR4Mutator]MSP[S] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { MST[rv.CRCR6Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ABSMutator]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR3Mutator]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI1Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD1Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[InlineConstantMutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR5Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[InlineConstantMutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[S] return bigBytes ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[ArgumentPropagationMutator]MSP[S]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR5Mutator]MSP[N]
public boolean isUrlSafe () { MST[rv.ROR1Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
currentLinePos += 4 ; MST[rv.AOR2Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD1Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI4Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[S] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR5Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[MathMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR2Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[S] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD2Mutator]MSP[S] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR6Mutator]MSP[S] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[InlineConstantMutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
x = ( x << 8 ) + b ; MST[IncrementsMutator]MSP[S] if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR1Mutator]MSP[S] b += 256 ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR4Mutator]MSP[S] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { MST[rv.AOD2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } return len ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR4Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR3Mutator]MSP[N] }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR3Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI1Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : MST[rv.UOI3Mutator]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] resizeBuffer () ; } switch ( modulus ) { case 1 :
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[S] return bigBytes ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR5Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR4Mutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[NonVoidMethodCallMutator]MSP[N] readPos += len ; if ( readPos >= pos ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI3Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI3Mutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR5Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI3Mutator]MSP[N] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[NegateConditionalsMutator]MSP[N]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR1Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR1Mutator]MSP[N] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[NegateConditionalsMutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[N] currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { MST[rv.CRCR6Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = PAD ; } break; MST[experimental.MemberVariableMutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[NullReturnValsMutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR1Mutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR3Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR6Mutator]MSP[S]
currentLinePos += 4 ; MST[InlineConstantMutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR5Mutator]MSP[N]
if ( buffer != buf ) { MST[rv.CRCR6Mutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI4Mutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[N] currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR5Mutator]MSP[S] break; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR2Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR6Mutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[S] for ( final byte element : arrayOctet ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR3Mutator]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI4Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR6Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR1Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[ReturnValsMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR2Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( modulus == 0 ) { MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR1Mutator]MSP[N] }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI3Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI3Mutator]MSP[S]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI1Mutator]MSP[S] x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR6Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[N] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI1Mutator]MSP[N] if ( buffer != null ) {
if ( modulus == 0 ) { MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI4Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ArgumentPropagationMutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR3Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[S] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI4Mutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOD1Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] currentLinePos = 0 ; } } } } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR4Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[N] currentLinePos = 0 ; } } } } }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[S] return bigBytes ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ArgumentPropagationMutator]MSP[S] switch ( byteToCheck ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ABSMutator]MSP[N] } } return len ; }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[NonVoidMethodCallMutator]MSP[N] encode ( pArray , 0 , - 1 ) ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR6Mutator]MSP[N] b += 256 ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.ABSMutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR6Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( eof ) { return; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; MST[VoidMethodCallMutator]MSP[S] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer = null ; MST[MathMutator]MSP[N] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR2Mutator]MSP[S]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR1Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI2Mutator]MSP[S] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR4Mutator]MSP[N]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
byte [] buf = new byte [ ( int ) len ] ; MST[NullReturnValsMutator]MSP[S] setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR1Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[N]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI4Mutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR3Mutator]MSP[N] b += 256 ; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR4Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR4Mutator]MSP[S]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[NegateConditionalsMutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[N] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.CRCR5Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[N]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR1Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.CRCR4Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[InlineConstantMutator]MSP[N] b += 256 ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR6Mutator]MSP[N] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI2Mutator]MSP[N] resizeBuffer () ; } switch ( modulus ) { case 1 :
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD1Mutator]MSP[N] }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI2Mutator]MSP[N] encode ( pArray , 0 , - 1 ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI4Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[N]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR2Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[S] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR5Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[InlineConstantMutator]MSP[S] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[N] currentLinePos = 0 ; } } } } }
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[InlineConstantMutator]MSP[N] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[IncrementsMutator]MSP[N] }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N]
public boolean isUrlSafe () { MST[rv.CRCR1Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[NegateConditionalsMutator]MSP[S] break; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI1Mutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR3Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[experimental.MemberVariableMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[experimental.RemoveIncrementsMutator]MSP[S] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOD1Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR1Mutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR2Mutator]MSP[N] } } return len ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI1Mutator]MSP[S] x = ( x << 6 ) + result ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR3Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR5Mutator]MSP[N] return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR3Mutator]MSP[S] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { MST[ConstructorCallMutator]MSP[S] if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[ConditionalsBoundaryMutator]MSP[S]
if ( modulus == 0 ) { MST[rv.AOR1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI2Mutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR2Mutator]MSP[N] resizeBuffer () ; } switch ( modulus ) { case 1 :
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI3Mutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[S] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.UOI4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[S] return bigBytes ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR6Mutator]MSP[N] } switch ( modulus ) { case 1 :
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[S] return bigBytes ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[S]
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR3Mutator]MSP[N] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[N] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI4Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[NullReturnValsMutator]MSP[S] switch ( byteToCheck ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOD2Mutator]MSP[N]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[BooleanTrueReturnValsMutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI3Mutator]MSP[N] } } return len ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[N]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI1Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR3Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[MathMutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI2Mutator]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR6Mutator]MSP[S] } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR1Mutator]MSP[N] } } return len ; }
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[InlineConstantMutator]MSP[S]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI4Mutator]MSP[N]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[MathMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[N] currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI2Mutator]MSP[N] }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.ABSMutator]MSP[N]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[N]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR3Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( buffer != buf ) { MST[rv.CRCR6Mutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR3Mutator]MSP[S]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR4Mutator]MSP[N] }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI4Mutator]MSP[N] readPos += len ; if ( readPos >= pos ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[N] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR3Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR2Mutator]MSP[N] switch ( byteToCheck ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[EmptyObjectReturnValsMutator]MSP[N]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI4Mutator]MSP[N]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR3Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NegateConditionalsMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR3Mutator]MSP[N] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI1Mutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI4Mutator]MSP[N] b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[MathMutator]MSP[N]
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI3Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[N] if ( eof ) { return; }
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR4Mutator]MSP[S]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR6Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR4Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[N] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[InlineConstantMutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[N] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[NullReturnValsMutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI1Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[IncrementsMutator]MSP[S] break; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR5Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR1Mutator]MSP[S] x = x << 6 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[N] for ( final byte element : arrayOctet ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[NullReturnValsMutator]MSP[N]
if ( modulus == 0 ) { MST[rv.AOD1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR3Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOD1Mutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD1Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR4Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer = null ; MST[rv.UOI1Mutator]MSP[N] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI4Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR5Mutator]MSP[S]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[InlineConstantMutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR4Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR2Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR5Mutator]MSP[N] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[S]
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.ABSMutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR1Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR5Mutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR3Mutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[InlineConstantMutator]MSP[N] return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[InlineConstantMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI4Mutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR3Mutator]MSP[S] } } } } }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR2Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[N] if ( eof ) { return; }
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI2Mutator]MSP[N] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
case ' ' : case '\n' : case '\r' : MST[rv.UOI4Mutator]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.ABSMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
public boolean isUrlSafe () { MST[rv.CRCR5Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
currentLinePos += 4 ; MST[rv.AOD1Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( buffer != null ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[N] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR5Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR5Mutator]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[InlineConstantMutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR1Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR6Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[experimental.MemberVariableMutator]MSP[N] b += 256 ; }
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR6Mutator]MSP[S] break; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[N]
if ( modulus == 0 ) { MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[N] buffer [ pos ++ ] = PAD ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI3Mutator]MSP[N]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR2Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.ABSMutator]MSP[N] }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR2Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] resizeBuffer () ; } switch ( modulus ) { case 1 :
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI2Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( chunkSize > 0 ) { MST[NegateConditionalsMutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[MathMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI1Mutator]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[S] return bigBytes ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[N] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI2Mutator]MSP[N] if ( buffer != null ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[ArgumentPropagationMutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI4Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[experimental.MemberVariableMutator]MSP[N] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[NegateConditionalsMutator]MSP[S] x = x << 6 ;
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR5Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[S] return bigBytes ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI3Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR1Mutator]MSP[N] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public boolean isUrlSafe () { MST[experimental.MemberVariableMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } return len ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.UOI1Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR4Mutator]MSP[N] b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[N] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[MathMutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR3Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( chunkSize > 0 ) { MST[rv.UOI4Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[InlineConstantMutator]MSP[N] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[NonVoidMethodCallMutator]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ReturnValsMutator]MSP[N]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[N]
buffer [ pos ++ ] = PAD ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
} int startSrc = 0 ; MST[rv.ROR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[ConditionalsBoundaryMutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR6Mutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR3Mutator]MSP[S]
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.ABSMutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI1Mutator]MSP[S] break; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( readPos >= pos ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[N] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR3Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR2Mutator]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[N]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[MathMutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[N] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.CRCR5Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
} int startSrc = 0 ; MST[ReturnValsMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR2Mutator]MSP[N] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.OBBN3Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.ABSMutator]MSP[N] encode ( pArray , 0 , - 1 ) ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[InlineConstantMutator]MSP[N] } } return len ; }
public boolean isUrlSafe () { MST[rv.ROR2Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR1Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI3Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR6Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.OBBN2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[ReturnValsMutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR2Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR4Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI1Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[S] if ( eof ) { return; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[InlineConstantMutator]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[NegateConditionalsMutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[N]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR4Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( chunkSize > 0 ) { MST[rv.CRCR1Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR4Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR2Mutator]MSP[N] }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR4Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI3Mutator]MSP[N]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[S]
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final byte element : arrayOctet ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI3Mutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.ABSMutator]MSP[S] } } } } }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR4Mutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR6Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ABSMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR5Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI3Mutator]MSP[N] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR3Mutator]MSP[N] } } return len ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.ABSMutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[ReturnValsMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR3Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[EmptyObjectReturnValsMutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( final byte element : arrayOctet ) {
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI3Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ABSMutator]MSP[S] break; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ReturnValsMutator]MSP[S] switch ( byteToCheck ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR4Mutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI4Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[experimental.MemberVariableMutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOD2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[InlineConstantMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR4Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD2Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI3Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[InlineConstantMutator]MSP[N] }
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[InlineConstantMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR5Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR3Mutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[N] currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; MST[rv.CRCR6Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI1Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI4Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI2Mutator]MSP[N] } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR5Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[N] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR3Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , MST[NullReturnValsMutator]MSP[N] isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[VoidMethodCallMutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR5Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR4Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR5Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR2Mutator]MSP[N] }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { MST[rv.CRCR5Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI4Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[N] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ABSMutator]MSP[N] if ( buffer != null ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR5Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public boolean isUrlSafe () { MST[rv.CRCR4Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI3Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NegateConditionalsMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[NegateConditionalsMutator]MSP[N]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR3Mutator]MSP[S]
currentLinePos += 4 ; MST[InlineConstantMutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR2Mutator]MSP[S] x = x << 6 ;
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI2Mutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NullReturnValsMutator]MSP[S] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR1Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR2Mutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD1Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI2Mutator]MSP[N]
} int startSrc = 0 ; MST[rv.ABSMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NullReturnValsMutator]MSP[S] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[MathMutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[rv.ROR5Mutator]MSP[S] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR2Mutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI3Mutator]MSP[N] }
byte [] buf = new byte [ ( int ) len ] ; MST[ReturnValsMutator]MSP[S] setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[ConditionalsBoundaryMutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[S] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI3Mutator]MSP[S] break; }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR5Mutator]MSP[N]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR1Mutator]MSP[N] if ( buffer != null ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI3Mutator]MSP[N] } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI1Mutator]MSP[N] encode ( pArray , 0 , - 1 ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] break; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR3Mutator]MSP[S]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[S] return bigBytes ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[N]
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[N] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NonVoidMethodCallMutator]MSP[N] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { MST[rv.AOR2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[N]
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR1Mutator]MSP[N] resizeBuffer () ; } switch ( modulus ) { case 1 :
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[NegateConditionalsMutator]MSP[S] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR4Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR4Mutator]MSP[N] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR1Mutator]MSP[N] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[InlineConstantMutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[InlineConstantMutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR2Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR2Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[S]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR5Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[ReturnValsMutator]MSP[N] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
buffer = null ; MST[rv.AOR1Mutator]MSP[N] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR2Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD2Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[N] if ( eof ) { return; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI2Mutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR4Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI1Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] len += chunkSeparator . length ; } } return len ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR2Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI2Mutator]MSP[N]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR2Mutator]MSP[N] } } return len ; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI3Mutator]MSP[N] if ( buffer != null ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI3Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[N] currentLinePos = 0 ; } } } } }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NonVoidMethodCallMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI1Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR3Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI1Mutator]MSP[N]
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; MST[rv.UOI1Mutator]MSP[N] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD1Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR3Mutator]MSP[N] return newStringUtf8 ( encode ( pArray ) ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[InlineConstantMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[ReturnValsMutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR5Mutator]MSP[S] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; }
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI1Mutator]MSP[S] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI3Mutator]MSP[N] resizeBuffer () ; } switch ( modulus ) { case 1 :
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR3Mutator]MSP[N] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[S] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOD1Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR6Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR5Mutator]MSP[S] } } return len ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR1Mutator]MSP[S]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI1Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI3Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI2Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR6Mutator]MSP[N]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[S] currentLinePos = 0 ; } } } } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.ABSMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[S]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[VoidMethodCallMutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
case ' ' : case '\n' : case '\r' : MST[experimental.SwitchMutator]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR5Mutator]MSP[S] b += 256 ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.ABSMutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NegateConditionalsMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR6Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI4Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; }
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR1Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR4Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR4Mutator]MSP[N] }
currentLinePos += 4 ; MST[InlineConstantMutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR2Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer = null ; } } else { MST[experimental.MemberVariableMutator]MSP[S] buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR5Mutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI3Mutator]MSP[S] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR5Mutator]MSP[N] } } return len ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI4Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[NegateConditionalsMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[InlineConstantMutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR4Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[N] if ( eof ) { return; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[InlineConstantMutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[InlineConstantMutator]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI3Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR1Mutator]MSP[S]
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( buffer != null ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI4Mutator]MSP[S] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR1Mutator]MSP[N] }
public byte [] encode ( final byte [] pArray ) { MST[VoidMethodCallMutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI2Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ABSMutator]MSP[S] return bigBytes ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[N]
private static String newStringUtf8 ( final byte [] encode ) { MST[ArgumentPropagationMutator]MSP[S] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR5Mutator]MSP[S]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR4Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR1Mutator]MSP[S] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR6Mutator]MSP[N] return newStringUtf8 ( encode ( pArray ) ) ; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[InlineConstantMutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[S] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.ABSMutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR3Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR4Mutator]MSP[S] resizeBuffer () ; } switch ( modulus ) { case 1 :
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[MathMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[S] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD2Mutator]MSP[S] }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NullReturnValsMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[MathMutator]MSP[S] b += 256 ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR5Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[N] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[BooleanTrueReturnValsMutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] bigBytes = bigInt . toByteArray () ; MST[NonVoidMethodCallMutator]MSP[S] if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR6Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR4Mutator]MSP[S] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.CRCR2Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR6Mutator]MSP[S] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[S] currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR1Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOD2Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[N] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer = null ; MST[rv.UOI4Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR3Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR2Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR3Mutator]MSP[S] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[N] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[S] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI4Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
case ' ' : case '\n' : case '\r' : MST[rv.UOI2Mutator]MSP[S] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.ABSMutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[S] return bigBytes ;
public boolean isUrlSafe () { MST[rv.CRCR3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[InlineConstantMutator]MSP[S] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.ABSMutator]MSP[S] }
currentLinePos += 4 ; MST[rv.UOI2Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI2Mutator]MSP[S] }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[MathMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] + lr_3 + maxResultSize ) ; }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR4Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N]
currentLinePos += 4 ; MST[rv.AOR4Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR4Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( buffer != null ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[ConditionalsBoundaryMutator]MSP[N] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR3Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[NegateConditionalsMutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR4Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[MathMutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR4Mutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[NegateConditionalsMutator]MSP[S] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; MST[VoidMethodCallMutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
public boolean isUrlSafe () { MST[rv.CRCR6Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR3Mutator]MSP[S] b += 256 ; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR2Mutator]MSP[S] if ( buffer != null ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI2Mutator]MSP[N] } } return len ; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR3Mutator]MSP[S]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR6Mutator]MSP[S] }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI3Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR4Mutator]MSP[S] switch ( byteToCheck ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR4Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[N] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR5Mutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[S] if ( eof ) { return; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR1Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI2Mutator]MSP[S] break; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[S] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[S] }
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI2Mutator]MSP[S] }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[MathMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
case ' ' : case '\n' : case '\r' : MST[rv.ABSMutator]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[ConstructorCallMutator]MSP[S] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI3Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI4Mutator]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR4Mutator]MSP[S]
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[rv.ROR5Mutator]MSP[S] if ( readPos >= pos ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOD2Mutator]MSP[S] } } return len ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[InlineConstantMutator]MSP[S] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI2Mutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR4Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[S]
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR3Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( modulus == 0 ) { MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI1Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[NullReturnValsMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI4Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; MST[rv.ABSMutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI4Mutator]MSP[S] x = ( x << 6 ) + result ;
public boolean isUrlSafe () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR3Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[NegateConditionalsMutator]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD1Mutator]MSP[S] b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD1Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR5Mutator]MSP[S] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = PAD ; MST[rv.ROR5Mutator]MSP[N] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR5Mutator]MSP[N]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI3Mutator]MSP[S] x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[experimental.MemberVariableMutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR4Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI4Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR4Mutator]MSP[N] } } return len ; }
currentLinePos += 4 ; MST[rv.AOR1Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR5Mutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[MathMutator]MSP[N]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR6Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
currentLinePos = 0 ; MST[experimental.MemberVariableMutator]MSP[N] modulus = 0 ; eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[NegateConditionalsMutator]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = PAD ;
} int startSrc = 0 ; MST[NegateConditionalsMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI3Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR3Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI4Mutator]MSP[N] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR1Mutator]MSP[N] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[NonVoidMethodCallMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR5Mutator]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[N] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR3Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[N] if ( eof ) { return; }
public boolean isUrlSafe () { MST[rv.CRCR3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] len += chunkSeparator . length ; } } return len ; }
} int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[InlineConstantMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[N] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.CRCR5Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR5Mutator]MSP[N] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR2Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR1Mutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR3Mutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[experimental.MemberVariableMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.ROR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public byte [] encode ( final byte [] pArray ) { MST[EmptyObjectReturnValsMutator]MSP[N] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR5Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
public boolean isUrlSafe () { MST[InlineConstantMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR1Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.OBBN1Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[N] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI4Mutator]MSP[N] if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI3Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[N] currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR3Mutator]MSP[S] break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( modulus == 0 ) { MST[experimental.MemberVariableMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[BooleanTrueReturnValsMutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR2Mutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; MST[rv.CRCR2Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR4Mutator]MSP[N] }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR2Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR4Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[experimental.MemberVariableMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[S]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI1Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR6Mutator]MSP[N] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR2Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR4Mutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
currentLinePos += 4 ; MST[rv.UOI3Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI3Mutator]MSP[N]
currentLinePos += 4 ; MST[rv.UOI4Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[InlineConstantMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI3Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.SwitchMutator]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI4Mutator]MSP[S]
buffer = null ; MST[rv.AOR2Mutator]MSP[N] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( modulus == 0 ) { MST[rv.AOR3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ABSMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR6Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[NegateConditionalsMutator]MSP[N]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR6Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[N] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[N] if ( eof ) { return; }
final byte [] result = new byte [ pos ] ; MST[VoidMethodCallMutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI2Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.OBBN2Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
private static String newStringUtf8 ( final byte [] encode ) { MST[EmptyObjectReturnValsMutator]MSP[S] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR3Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR2Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR5Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI1Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR1Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[experimental.MemberVariableMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( modulus == 0 ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR4Mutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR3Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[BooleanTrueReturnValsMutator]MSP[N] return newStringUtf8 ( encode ( pArray ) ) ; }
currentLinePos += 4 ; MST[rv.OBBN1Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR2Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer != buf ) { MST[rv.CRCR5Mutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR6Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI3Mutator]MSP[S] return bigBytes ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR3Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[N] if ( eof ) { return; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[NegateConditionalsMutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI1Mutator]MSP[N] }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR1Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR5Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[InlineConstantMutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.ABSMutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[MathMutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI4Mutator]MSP[S] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[MathMutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI4Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR4Mutator]MSP[N]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[experimental.RemoveIncrementsMutator]MSP[S] break; }
public boolean isUrlSafe () { MST[rv.CRCR6Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOD2Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[NegateConditionalsMutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[N]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final byte [] buf = new byte [ ( int ) len ] ; MST[ReturnValsMutator]MSP[S] setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = PAD ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[experimental.MemberVariableMutator]MSP[S] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR4Mutator]MSP[S] x = x << 6 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR3Mutator]MSP[S] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[N] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[S] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[N] currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI1Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[MathMutator]MSP[N] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI4Mutator]MSP[N] }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[S] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[N] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR5Mutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[S] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR1Mutator]MSP[N] }
if ( chunkSize > 0 ) { MST[rv.ROR3Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI1Mutator]MSP[N] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI1Mutator]MSP[N] resizeBuffer () ; } switch ( modulus ) { case 1 :
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI3Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD1Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[NullReturnValsMutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI4Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI4Mutator]MSP[S] len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[InlineConstantMutator]MSP[S] b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR2Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[S]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI2Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR3Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.ABSMutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR6Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR2Mutator]MSP[S] b += 256 ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[N] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.ABSMutator]MSP[S]
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[S]
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[VoidMethodCallMutator]MSP[N] } } } } }
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.ABSMutator]MSP[N] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[S] if ( eof ) { return; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[rv.ROR5Mutator]MSP[S] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR1Mutator]MSP[S] } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR1Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[ConditionalsBoundaryMutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR2Mutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR2Mutator]MSP[N]
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR6Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = PAD ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[N]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[S] return bigBytes ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[S] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ABSMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[rv.UOI3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI1Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; MST[rv.UOI3Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[S] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR3Mutator]MSP[S]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ABSMutator]MSP[S]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI1Mutator]MSP[S] x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR4Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ABSMutator]MSP[S]
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI4Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR3Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR5Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[S]
currentLinePos += 4 ; MST[rv.CRCR1Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.ROR4Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI4Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR4Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR5Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[S]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[ArgumentPropagationMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NullReturnValsMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR4Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI1Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR2Mutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ABSMutator]MSP[S] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR5Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] x = x << 6 ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR4Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI4Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[S]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[S] return bigBytes ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI1Mutator]MSP[S] len += chunkSeparator . length ; } } return len ; }
if ( buffer != buf ) { MST[rv.CRCR5Mutator]MSP[S] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI1Mutator]MSP[S] }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; }
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR4Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR2Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR1Mutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR5Mutator]MSP[S]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR5Mutator]MSP[S] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI4Mutator]MSP[N]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI2Mutator]MSP[N]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR6Mutator]MSP[S] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[experimental.MemberVariableMutator]MSP[S] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[NegateConditionalsMutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[S]
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[N] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR4Mutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[S]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR1Mutator]MSP[S]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR2Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI2Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI3Mutator]MSP[S] break; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR1Mutator]MSP[N] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR3Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR1Mutator]MSP[S]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[S] return bigBytes ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR5Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[InlineConstantMutator]MSP[N] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR2Mutator]MSP[N] b += 256 ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI3Mutator]MSP[N] }
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[S] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN2Mutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[experimental.MemberVariableMutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[InlineConstantMutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR1Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[InlineConstantMutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR1Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI3Mutator]MSP[S] } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[MathMutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR1Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD1Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR3Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[ReturnValsMutator]MSP[S] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR4Mutator]MSP[N] }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[NegateConditionalsMutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR1Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[S]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR2Mutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR6Mutator]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI4Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[S] if ( eof ) { return; }
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[ReturnValsMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[S]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI1Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR4Mutator]MSP[N] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI3Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR2Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( modulus == 0 ) { MST[MathMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
currentLinePos += 4 ; MST[rv.CRCR4Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[S] return bigBytes ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI1Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ABSMutator]MSP[S] break; }
} int startSrc = 0 ; MST[rv.ROR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[InlineConstantMutator]MSP[S]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD2Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[S] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR3Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.ABSMutator]MSP[N] }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.ABSMutator]MSP[S] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ConditionalsBoundaryMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ABSMutator]MSP[S]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR5Mutator]MSP[S] x = x << 6 ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR3Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI3Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[ConstructorCallMutator]MSP[N] }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[S] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI3Mutator]MSP[S] x = ( x << 6 ) + result ;
if ( buffer != buf ) { MST[VoidMethodCallMutator]MSP[S] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR1Mutator]MSP[S]
if ( modulus == 0 ) { MST[rv.AOD2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ABSMutator]MSP[S] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI1Mutator]MSP[S] for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI4Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR5Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[S] currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR2Mutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR3Mutator]MSP[S]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR3Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[experimental.SwitchMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR3Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR1Mutator]MSP[S] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR3Mutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI1Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[EmptyObjectReturnValsMutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI2Mutator]MSP[S] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI4Mutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR1Mutator]MSP[S] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR2Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[InlineConstantMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR6Mutator]MSP[S]
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( chunkSize > 0 ) { MST[rv.CRCR3Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR4Mutator]MSP[N]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI4Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI1Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR5Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { MST[rv.ROR1Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI3Mutator]MSP[S] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD2Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI4Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[MathMutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( eof ) { return; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI3Mutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[S] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S]
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[NullReturnValsMutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR3Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[S] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR1Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR2Mutator]MSP[S] break; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( buffer != null ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR3Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR6Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[S] if ( eof ) { return; }
if ( modulus == 0 ) { MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR3Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[MathMutator]MSP[N] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR1Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR2Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ConstructorCallMutator]MSP[S] switch ( byteToCheck ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[S] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[MathMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR5Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[S]
private static String newStringUtf8 ( final byte [] encode ) { MST[ConstructorCallMutator]MSP[S] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD2Mutator]MSP[S] }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.ABSMutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI2Mutator]MSP[S] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; MST[experimental.MemberVariableMutator]MSP[S] } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI2Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[S]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; MST[NonVoidMethodCallMutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[InlineConstantMutator]MSP[S] } } return len ; }
if ( modulus == 0 ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[S] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[S]
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR1Mutator]MSP[S] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[ReturnValsMutator]MSP[N] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[S] }
currentLinePos += 4 ; MST[rv.CRCR2Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI2Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( eof ) { return; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI3Mutator]MSP[S] }
} int startSrc = 0 ; MST[rv.ROR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer = null ; MST[rv.AOR3Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI2Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR3Mutator]MSP[S] b += 256 ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[experimental.MemberVariableMutator]MSP[S] } switch ( modulus ) { case 1 :
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOD1Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[NegateConditionalsMutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR3Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR4Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ABSMutator]MSP[S] break; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[IncrementsMutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR6Mutator]MSP[S]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR1Mutator]MSP[S]
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.OBBN3Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR4Mutator]MSP[S] if ( buffer != null ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI1Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[S] return bigBytes ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR5Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final byte element : arrayOctet ) {
buffer = null ; MST[rv.AOD1Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR5Mutator]MSP[N] switch ( byteToCheck ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[ReturnValsMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI3Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[S] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[S] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR5Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI4Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[NegateConditionalsMutator]MSP[S] x = x << 6 ;
public boolean isUrlSafe () { MST[rv.CRCR5Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[S] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR6Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI2Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[S]
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR1Mutator]MSP[N] return newStringUtf8 ( encode ( pArray ) ) ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR2Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI2Mutator]MSP[S] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[N] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR1Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR5Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR1Mutator]MSP[S] b += 256 ; }
if ( buffer != buf ) { MST[VoidMethodCallMutator]MSP[S] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR6Mutator]MSP[N] }
} int startSrc = 0 ; MST[MathMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[MathMutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI3Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR2Mutator]MSP[S]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR1Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI4Mutator]MSP[S]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR2Mutator]MSP[S]
final byte [] result = new byte [ pos ] ; MST[VoidMethodCallMutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI3Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[MathMutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR1Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR2Mutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[S] currentLinePos = 0 ; } } } } }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR2Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[NonVoidMethodCallMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S]
currentLinePos += 4 ; MST[rv.UOI1Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR3Mutator]MSP[S] } switch ( modulus ) { case 1 :
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer = null ; MST[rv.UOI3Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S]
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR2Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI1Mutator]MSP[S] readPos += len ; if ( readPos >= pos ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[ReturnValsMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI4Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR3Mutator]MSP[S] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[InlineConstantMutator]MSP[S] } switch ( modulus ) { case 1 :
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR6Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { MST[rv.CRCR3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI1Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR3Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR3Mutator]MSP[S] } } return len ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[VoidMethodCallMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( buffer != buf ) { MST[rv.CRCR3Mutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( eof ) { return; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI1Mutator]MSP[S]
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI2Mutator]MSP[S] b += 256 ; }
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR6Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public byte [] decode ( final byte [] pArray ) { MST[rv.ABSMutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI4Mutator]MSP[S] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR5Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR1Mutator]MSP[N] } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR3Mutator]MSP[S] break; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR5Mutator]MSP[S] } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[ReturnValsMutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[PrimitiveReturnsMutator]MSP[S] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR5Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[InlineConstantMutator]MSP[S] break; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[S] return bigBytes ;
public boolean isUrlSafe () { MST[NegateConditionalsMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[InlineConstantMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR3Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR3Mutator]MSP[S] } } return len ; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[S] if ( eof ) { return; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR6Mutator]MSP[S] b += 256 ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI1Mutator]MSP[S]
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[NegateConditionalsMutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR1Mutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR4Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer = null ; } } else { buffer = null ; } return len ; MST[experimental.MemberVariableMutator]MSP[S] } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR5Mutator]MSP[S] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI1Mutator]MSP[S] + lr_3 + maxResultSize ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR1Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[MathMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
buffer = null ; MST[rv.UOI2Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[experimental.MemberVariableMutator]MSP[S]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR5Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR5Mutator]MSP[S] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR5Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final byte element : arrayOctet ) {
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI4Mutator]MSP[S] resizeBuffer () ; } switch ( modulus ) { case 1 :
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[InlineConstantMutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[S]
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[ArgumentPropagationMutator]MSP[S]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.ABSMutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR4Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; MST[VoidMethodCallMutator]MSP[S] if ( b == PAD ) { eof = true ; break; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[experimental.MemberVariableMutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI1Mutator]MSP[S] return bigBytes ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[experimental.MemberVariableMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[ReturnValsMutator]MSP[S] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
public boolean isUrlSafe () { MST[rv.ROR5Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[IncrementsMutator]MSP[S] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( chunkSize > 0 ) { MST[rv.UOI2Mutator]MSP[S] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD1Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( modulus == 0 ) { MST[rv.AOR1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR4Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI4Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[MathMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[S] currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[VoidMethodCallMutator]MSP[S] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI1Mutator]MSP[S] break; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[NonVoidMethodCallMutator]MSP[N] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[NegateConditionalsMutator]MSP[S] resizeBuffer () ; } switch ( modulus ) { case 1 :
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI2Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
} int startSrc = 0 ; MST[rv.UOI1Mutator]MSP[N] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { MST[rv.CRCR1Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR4Mutator]MSP[S] b += 256 ; }
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR4Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[N] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[N] currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR3Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer = null ; MST[experimental.MemberVariableMutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI3Mutator]MSP[S] x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.ABSMutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR1Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI2Mutator]MSP[S]
currentLinePos += 4 ; MST[rv.UOI1Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR6Mutator]MSP[N] } } return len ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[InlineConstantMutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[experimental.RemoveIncrementsMutator]MSP[S] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR5Mutator]MSP[S] } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI4Mutator]MSP[S] encode ( pArray , 0 , - 1 ) ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[S] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[S]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI1Mutator]MSP[N] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR5Mutator]MSP[N] if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR6Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI3Mutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR4Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[InlineConstantMutator]MSP[S]
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR5Mutator]MSP[S] resizeBuffer () ; } switch ( modulus ) { case 1 :
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( buffer != buf ) { MST[rv.CRCR3Mutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR6Mutator]MSP[N]
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[ReturnValsMutator]MSP[S]
currentLinePos += 4 ; MST[rv.CRCR3Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI1Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[S] currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[ConditionalsBoundaryMutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[InlineConstantMutator]MSP[S]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR6Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[S] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[N]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD2Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[MathMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[S] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR6Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NonVoidMethodCallMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI2Mutator]MSP[S] for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NonVoidMethodCallMutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[MathMutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR1Mutator]MSP[N] }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR2Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
case ' ' : case '\n' : case '\r' : MST[rv.UOI1Mutator]MSP[S] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
if ( chunkSize > 0 ) { MST[rv.ABSMutator]MSP[S] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR2Mutator]MSP[S]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI2Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.ROR5Mutator]MSP[S]
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI1Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( modulus == 0 ) { MST[rv.AOD1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR4Mutator]MSP[S] } switch ( modulus ) { case 1 :
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( eof ) { return; }
buffer = null ; MST[rv.UOI4Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR6Mutator]MSP[S] } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[experimental.RemoveSwitchMutator_0]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[S] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[experimental.RemoveSwitchMutator_1]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR6Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[InlineConstantMutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[NullReturnValsMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR3Mutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR3Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR1Mutator]MSP[N]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR5Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI2Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOD1Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[S] currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI2Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[N] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[MathMutator]MSP[S] } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR2Mutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[ArgumentPropagationMutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR1Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[InlineConstantMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; }
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[NegateConditionalsMutator]MSP[S]
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR3Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI2Mutator]MSP[S] readPos += len ; if ( readPos >= pos ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR1Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[ConstructorCallMutator]MSP[N] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[NegateConditionalsMutator]MSP[S]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR5Mutator]MSP[S]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI2Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[S]
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR6Mutator]MSP[S]
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[BooleanTrueReturnValsMutator]MSP[N] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI1Mutator]MSP[S] } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOD2Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[N] if ( eof ) { return; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI3Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR5Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; MST[rv.AOR4Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI3Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
} int startSrc = 0 ; MST[rv.ROR5Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI3Mutator]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR6Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( buffer != null ) {
if ( modulus == 0 ) { MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR2Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.ABSMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[N] currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[S] return bigBytes ;
} int startSrc = 0 ; MST[NegateConditionalsMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR4Mutator]MSP[S] } } return len ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos = 0 ; modulus = 0 ; MST[experimental.MemberVariableMutator]MSP[S] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
x = ( x << 8 ) + b ; MST[experimental.RemoveIncrementsMutator]MSP[S] if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI3Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR2Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR4Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[ArgumentPropagationMutator]MSP[S] final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[S] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.ROR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[S] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.ABSMutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[MathMutator]MSP[S]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.ABSMutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.ABSMutator]MSP[N] readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOD2Mutator]MSP[N] }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[MathMutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR1Mutator]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR4Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR3Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; }
buffer = null ; MST[rv.UOI3Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[ReturnValsMutator]MSP[N] return newStringUtf8 ( encode ( pArray ) ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR4Mutator]MSP[S] b += 256 ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR2Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[S] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public byte [] encode ( final byte [] pArray ) { MST[rv.ABSMutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR1Mutator]MSP[S] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR5Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] currentLinePos = 0 ; } } } } }
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR5Mutator]MSP[S]
currentLinePos += 4 ; MST[rv.CRCR1Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { MST[rv.UOI1Mutator]MSP[S] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI4Mutator]MSP[S] x = ( x << 6 ) + result ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR5Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI3Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.ROR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[N]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.ABSMutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR5Mutator]MSP[S] }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR3Mutator]MSP[S]
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[InlineConstantMutator]MSP[N] switch ( byteToCheck ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR1Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[S] return bigBytes ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[BooleanTrueReturnValsMutator]MSP[N] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI4Mutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR2Mutator]MSP[S]
currentLinePos += 4 ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[N] }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[InlineConstantMutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI1Mutator]MSP[N] }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR1Mutator]MSP[S] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD2Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR3Mutator]MSP[N]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR3Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[N] if ( eof ) { return; }
if ( modulus == 0 ) { MST[rv.AOR2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[N]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[ArgumentPropagationMutator]MSP[N] readPos += len ; if ( readPos >= pos ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[NonVoidMethodCallMutator]MSP[S]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI3Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR1Mutator]MSP[N]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
public byte [] decode ( final byte [] pArray ) { MST[VoidMethodCallMutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR2Mutator]MSP[S] } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( chunkSize > 0 ) { MST[InlineConstantMutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI2Mutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI1Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[InlineConstantMutator]MSP[S]
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[NonVoidMethodCallMutator]MSP[N]
} int startSrc = 0 ; MST[MathMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR6Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR2Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( modulus == 0 ) { MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR2Mutator]MSP[S] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[N]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR5Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI3Mutator]MSP[N] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR6Mutator]MSP[N] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR1Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI1Mutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR4Mutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N]
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N]
if ( modulus == 0 ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI4Mutator]MSP[S] x = x << 6 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR6Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR3Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[S] return bigBytes ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR5Mutator]MSP[N] } switch ( modulus ) { case 1 :
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[experimental.MemberVariableMutator]MSP[S]
public byte [] encode ( final byte [] pArray ) { MST[ReturnValsMutator]MSP[N] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[InlineConstantMutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[N]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI4Mutator]MSP[N] } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOD1Mutator]MSP[N]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI1Mutator]MSP[S]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD1Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ReturnValsMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { MST[rv.UOI3Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[InlineConstantMutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR5Mutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[InlineConstantMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR5Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR1Mutator]MSP[N] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[N]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI3Mutator]MSP[N] b += 256 ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.OBBN1Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[InlineConstantMutator]MSP[S] } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[S]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[N] readPos += len ; if ( readPos >= pos ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR2Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR4Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI1Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[N] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[N] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[N] currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[N]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR4Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.ABSMutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[MathMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ABSMutator]MSP[N]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR3Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[S] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[S]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR3Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NonVoidMethodCallMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI3Mutator]MSP[N]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR3Mutator]MSP[N]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR3Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR1Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI4Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.CRCR6Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[S] for ( final byte element : arrayOctet ) {
if ( buffer != buf ) { MST[InlineConstantMutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; MST[rv.UOI2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOD2Mutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR5Mutator]MSP[N] buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[S] return bigBytes ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR3Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI2Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.ABSMutator]MSP[N] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[S] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final byte element : arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.RemoveSwitchMutator_0]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.RemoveSwitchMutator_1]MSP[S] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
public boolean isUrlSafe () { MST[rv.ROR3Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI4Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[N] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI3Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[InlineConstantMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR5Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR6Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[MathMutator]MSP[N] }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ABSMutator]MSP[N] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR1Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[NegateConditionalsMutator]MSP[N] } } return len ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[N] if ( eof ) { return; }
private static String newStringUtf8 ( final byte [] encode ) { MST[ReturnValsMutator]MSP[S] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
} int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( modulus == 0 ) { MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[InlineConstantMutator]MSP[N]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[ReturnValsMutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR3Mutator]MSP[N] b += 256 ; }
currentLinePos += 4 ; MST[rv.OBBN2Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI3Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI3Mutator]MSP[N] encode ( pArray , 0 , - 1 ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI2Mutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[S]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR4Mutator]MSP[N] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
public boolean isUrlSafe () { MST[rv.CRCR1Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[NonVoidMethodCallMutator]MSP[S] switch ( byteToCheck ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[MathMutator]MSP[N] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR5Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[NonVoidMethodCallMutator]MSP[N] readPos += len ; if ( readPos >= pos ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR5Mutator]MSP[N] } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI3Mutator]MSP[S]
if ( buffer != buf ) { MST[rv.CRCR1Mutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR1Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[S] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR1Mutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOD2Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[EmptyObjectReturnValsMutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[N]
buffer = null ; MST[rv.ABSMutator]MSP[N] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR5Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI1Mutator]MSP[N] } } return len ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.OBBN2Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[experimental.MemberVariableMutator]MSP[N] b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[InlineConstantMutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI2Mutator]MSP[N]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR3Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.ABSMutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR3Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[InlineConstantMutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD1Mutator]MSP[N] }
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI1Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR6Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI2Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD1Mutator]MSP[N] b += 256 ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[S]
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR5Mutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.OBBN3Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[InlineConstantMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD2Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[InlineConstantMutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR3Mutator]MSP[N] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ABSMutator]MSP[S] x = x << 6 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( eof ) { return; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[NullReturnValsMutator]MSP[S] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI4Mutator]MSP[N] }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[N] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[N] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR6Mutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI2Mutator]MSP[S] } } } } }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR6Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI2Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[NegateConditionalsMutator]MSP[N] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR4Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[NullReturnValsMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI2Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR3Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR3Mutator]MSP[S] x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR2Mutator]MSP[S] x = x << 6 ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[NegateConditionalsMutator]MSP[N] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR5Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[MathMutator]MSP[N] b += 256 ; }
currentLinePos += 4 ; MST[rv.AOD2Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[MathMutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[N] for ( final byte element : arrayOctet ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[S] return bigBytes ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[BooleanFalseReturnValsMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR5Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[NullReturnValsMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR6Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR3Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR1Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR1Mutator]MSP[N] decode ( pArray , 0 , - 1 ) ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[BooleanFalseReturnValsMutator]MSP[N] switch ( byteToCheck ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[N] currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[N]
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[N] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } switch ( modulus ) { MST[VoidMethodCallMutator]MSP[S] case 1 :
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[rv.ROR3Mutator]MSP[N] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI4Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[NegateConditionalsMutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR3Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[S] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI4Mutator]MSP[S]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ABSMutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR4Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI3Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR3Mutator]MSP[N] }
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR6Mutator]MSP[N] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[InlineConstantMutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR1Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[NegateConditionalsMutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI2Mutator]MSP[N] } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[NonVoidMethodCallMutator]MSP[N] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[S]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI2Mutator]MSP[S]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD2Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[ArgumentPropagationMutator]MSP[S]
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[S] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.ABSMutator]MSP[S]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI2Mutator]MSP[S] x = ( x << 6 ) + result ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { MST[InlineConstantMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.ABSMutator]MSP[S] x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.ROR5Mutator]MSP[S] final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S]
public boolean isUrlSafe () { MST[InlineConstantMutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[S]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR3Mutator]MSP[S] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( buffer != buf ) { MST[InlineConstantMutator]MSP[N] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[ConditionalsBoundaryMutator]MSP[S] resizeBuffer () ; } switch ( modulus ) { case 1 :
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[S] if ( eof ) { return; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR1Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
} int startSrc = 0 ; MST[rv.ROR5Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( modulus == 0 ) { MST[rv.AOR3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI1Mutator]MSP[S] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[NegateConditionalsMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[S] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR2Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI2Mutator]MSP[S] len += chunkSeparator . length ; } } return len ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR5Mutator]MSP[N] final byte [] smallerBuf = new byte [ pos ] ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR1Mutator]MSP[S] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( chunkSize > 0 ) { MST[rv.ROR5Mutator]MSP[N] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[N]
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[ReturnValsMutator]MSP[S] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[S] return bigBytes ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR3Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR6Mutator]MSP[S]
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR1Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI2Mutator]MSP[S] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] x = x << 6 ;
if ( chunkSize > 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[NegateConditionalsMutator]MSP[S] if ( readPos >= pos ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR3Mutator]MSP[N] }
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[S] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = PAD ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[S]
if ( buffer != buf ) { MST[rv.CRCR1Mutator]MSP[S] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[S] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI4Mutator]MSP[S] break; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOD1Mutator]MSP[N] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR6Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR5Mutator]MSP[S] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR2Mutator]MSP[N]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR1Mutator]MSP[N]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[S] }
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD2Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI2Mutator]MSP[S] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR2Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI4Mutator]MSP[S] } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR1Mutator]MSP[S] b += 256 ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR2Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR4Mutator]MSP[S]
private static String newStringUtf8 ( final byte [] encode ) { MST[NonVoidMethodCallMutator]MSP[S] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI2Mutator]MSP[S] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[S] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[S]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; }
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[S] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[S]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR4Mutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR3Mutator]MSP[S] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI4Mutator]MSP[N] }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR2Mutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR1Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR5Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[experimental.MemberVariableMutator]MSP[S] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI4Mutator]MSP[S] break; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR2Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR2Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[S] buffer [ pos ++ ] = PAD ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR3Mutator]MSP[S] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI1Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR6Mutator]MSP[N]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI4Mutator]MSP[S] }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.ABSMutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( eof ) { return; }
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[ReturnValsMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI4Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR1Mutator]MSP[S] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[N] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[S] return bigBytes ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final byte [] buf = new byte [ ( int ) len ] ; MST[NullReturnValsMutator]MSP[S] setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[N]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[MathMutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI2Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ABSMutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR1Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI4Mutator]MSP[N] } } return len ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR5Mutator]MSP[S] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI2Mutator]MSP[S] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[N] buffer [ pos ++ ] = PAD ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR6Mutator]MSP[N] switch ( byteToCheck ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR1Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( buffer != null ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[N] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[PrimitiveReturnsMutator]MSP[N] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR1Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI3Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI2Mutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[S]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
} int startSrc = 0 ; MST[NonVoidMethodCallMutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[InlineConstantMutator]MSP[S]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[InlineConstantMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR3Mutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI2Mutator]MSP[N]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI1Mutator]MSP[S] if ( mod != 0 ) { len += 4 - mod ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI4Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = PAD ; MST[NegateConditionalsMutator]MSP[S] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR2Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.ABSMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[InlineConstantMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
currentLinePos += 4 ; MST[rv.UOI4Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR1Mutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI1Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR1Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ConstructorCallMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[S]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR5Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR3Mutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR5Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; MST[rv.CRCR3Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR4Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD2Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ABSMutator]MSP[N] len += chunkSeparator . length ; } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.OBBN3Mutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = PAD ; } break; MST[MathMutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ABSMutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( buffer != null ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR1Mutator]MSP[S] break; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI3Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR4Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { MST[rv.ROR2Mutator]MSP[S] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR2Mutator]MSP[N] }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI2Mutator]MSP[S] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[S] return bigBytes ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ABSMutator]MSP[N] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.ABSMutator]MSP[S] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI2Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer = null ; MST[rv.ABSMutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI1Mutator]MSP[N] } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR4Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR1Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR1Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR5Mutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[S]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR5Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR4Mutator]MSP[S] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR3Mutator]MSP[S] resizeBuffer () ; } switch ( modulus ) { case 1 :
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR3Mutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR1Mutator]MSP[S] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[S] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.AOR3Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[S]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[ReturnValsMutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR3Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[IncrementsMutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.ABSMutator]MSP[S]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR4Mutator]MSP[S] } } return len ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI1Mutator]MSP[S]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI1Mutator]MSP[S] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR3Mutator]MSP[S] } } return len ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI4Mutator]MSP[N] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
currentLinePos = 0 ; modulus = 0 ; MST[InlineConstantMutator]MSP[S] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR1Mutator]MSP[S] } } } } }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] break; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR4Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR3Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI1Mutator]MSP[S] b += 256 ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI1Mutator]MSP[S] break; }
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI3Mutator]MSP[S] break; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR1Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[S] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[S] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI1Mutator]MSP[S] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[InlineConstantMutator]MSP[S] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[S] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR4Mutator]MSP[S] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI4Mutator]MSP[S] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = PAD ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[NegateConditionalsMutator]MSP[S] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[MathMutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR2Mutator]MSP[S] b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR4Mutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOD1Mutator]MSP[S] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.ROR5Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[S] currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.CRCR6Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR4Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[NonVoidMethodCallMutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
currentLinePos += 4 ; MST[MathMutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_3]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_2]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI3Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[S]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR4Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI3Mutator]MSP[S] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI3Mutator]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_1]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI2Mutator]MSP[S] + lr_3 + maxResultSize ) ; }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_0]MSP[N] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[S] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR6Mutator]MSP[S] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[S] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[S] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR2Mutator]MSP[N] }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[NegateConditionalsMutator]MSP[S] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI2Mutator]MSP[S] x = x << 6 ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[experimental.MemberVariableMutator]MSP[S] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[S] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[S] currentLinePos = 0 ; } } } } }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.ABSMutator]MSP[S] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[S] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR5Mutator]MSP[N] }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR3Mutator]MSP[S] if ( buffer != null ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR4Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[N] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR3Mutator]MSP[S] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR4Mutator]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[RemoveConditionalMutator_ORDER_IF]MSP[N] + lr_3 + maxResultSize ) ; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[S] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[S]
buffer = null ; MST[rv.AOD2Mutator]MSP[S] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR1Mutator]MSP[S] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR3Mutator]MSP[N] switch ( byteToCheck ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[S]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[S] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR4Mutator]MSP[S] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[N] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[S] buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; MST[rv.CRCR3Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR1Mutator]MSP[S] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[experimental.MemberVariableMutator]MSP[S] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR2Mutator]MSP[S] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ConditionalsBoundaryMutator]MSP[N] for ( final byte element : arrayOctet ) {
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[N] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[NonVoidMethodCallMutator]MSP[N]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR3Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ConditionalsBoundaryMutator]MSP[N] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[S] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR1Mutator]MSP[N] + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[S] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.UOI3Mutator]MSP[S] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.ROR5Mutator]MSP[S] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[S]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[S] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI2Mutator]MSP[N] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[MathMutator]MSP[S] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR3Mutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[N]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[N] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI1Mutator]MSP[N] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR3Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public boolean isUrlSafe () { MST[rv.CRCR2Mutator]MSP[N] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR4Mutator]MSP[S] decode ( pArray , 0 , - 1 ) ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR5Mutator]MSP[N] b += 256 ; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; MST[rv.UOI4Mutator]MSP[N] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[ReturnValsMutator]MSP[N]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ABSMutator]MSP[N]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[VoidMethodCallMutator]MSP[N]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.ABSMutator]MSP[N] }
buffer = null ; MST[rv.UOI2Mutator]MSP[N] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[MathMutator]MSP[N]
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[N] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[N]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N]
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR3Mutator]MSP[S]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR6Mutator]MSP[N] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR3Mutator]MSP[N] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[N]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR4Mutator]MSP[N] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI2Mutator]MSP[S] x = ( x << 6 ) + result ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR2Mutator]MSP[N] } switch ( modulus ) { case 1 :
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR2Mutator]MSP[N] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR1Mutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ConstructorCallMutator]MSP[N]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[InlineConstantMutator]MSP[N] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.ABSMutator]MSP[S] x = ( x << 6 ) + result ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR4Mutator]MSP[S] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[MathMutator]MSP[S] break; } } } public static boolean isBase64 ( final byte octet ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI1Mutator]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.ABSMutator]MSP[S] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR1Mutator]MSP[N] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.ABSMutator]MSP[N] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ABSMutator]MSP[N] if ( buffer != null ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[experimental.MemberVariableMutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR1Mutator]MSP[N] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[N] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[ArgumentPropagationMutator]MSP[S] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[InlineConstantMutator]MSP[N]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[N] if ( eof ) { return; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR6Mutator]MSP[N] } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[S] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR6Mutator]MSP[S] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( readPos >= pos ) {
private static String newStringUtf8 ( final byte [] encode ) { MST[NonVoidMethodCallMutator]MSP[S] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[N] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[N] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[NonVoidMethodCallMutator]MSP[N] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[N] default: break; } if ( lineLength > 0 && pos > 0 ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ABSMutator]MSP[N] resizeBuffer () ; } switch ( modulus ) { case 1 :
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR1Mutator]MSP[S] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[MathMutator]MSP[N] for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD2Mutator]MSP[N] b += 256 ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[N] if ( eof ) { return; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[experimental.MemberVariableMutator]MSP[N]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[N] buffer [ pos ++ ] = PAD ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[N] for ( final byte element : arrayOctet ) {
