if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.ABSMutator]MSP[] working . add ( Calendar . YEAR , - 1 ) ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR3Mutator]MSP[] } private static int indexOf ( final int calendarUnit ) {
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[NegateConditionalsMutator]MSP[] if ( recentDateFormat != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[InlineConstantMutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI4Mutator]MSP[] final int value = working . get ( field ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR4Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[ArgumentPropagationMutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR2Mutator]MSP[] return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.ABSMutator]MSP[] } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR5Mutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI4Mutator]MSP[] return i ; } } return 0 ; }
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ; MST[VoidMethodCallMutator]MSP[]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR1Mutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[InlineConstantMutator]MSP[] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR1Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR4Mutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR1Mutator]MSP[] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[PrimitiveReturnsMutator]MSP[] } } return 0 ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR5Mutator]MSP[] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR5Mutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[NonVoidMethodCallMutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[rv.ROR5Mutator]MSP[] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR5Mutator]MSP[]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[NonVoidMethodCallMutator]MSP[]
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[rv.ROR5Mutator]MSP[] if ( format != null ) { if ( dfs != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI2Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI2Mutator]MSP[] working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[NonVoidMethodCallMutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR6Mutator]MSP[] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR3Mutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR4Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ABSMutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR4Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI3Mutator]MSP[] final int value = working . get ( field ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR1Mutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[InlineConstantMutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( recentDateFormat != null ) {
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR5Mutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( format != null ) { if ( dfs != null ) { MST[experimental.MemberVariableMutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
final String languageCode = config . getServerLanguageCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR5Mutator]MSP[]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[experimental.NakedReceiverMutator]MSP[]
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR3Mutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[InlineConstantMutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR5Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR1Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[NegateConditionalsMutator]MSP[] if ( format != null ) { if ( dfs != null ) {
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[ConstructorCallMutator]MSP[]
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[rv.ROR5Mutator]MSP[] }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR3Mutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR3Mutator]MSP[] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI1Mutator]MSP[] return i ; } } return 0 ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[]
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[NegateConditionalsMutator]MSP[] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR1Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
final String languageCode = config . getServerLanguageCode () ; MST[NegateConditionalsMutator]MSP[] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
hackFormatter . setLenient ( false ) ; MST[NonVoidMethodCallMutator]MSP[] hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR4Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( value != 0 ) { MST[rv.UOI2Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[VoidMethodCallMutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[NullReturnValsMutator]MSP[] return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR3Mutator]MSP[]
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[InlineConstantMutator]MSP[] } private static int indexOf ( final int calendarUnit ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI4Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR2Mutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NegateConditionalsMutator]MSP[]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { MST[BooleanFalseReturnValsMutator]MSP[] return lenientFutureDates ; }
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override MST[NonVoidMethodCallMutator]MSP[] public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOD2Mutator]MSP[] final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR5Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[NegateConditionalsMutator]MSP[] }
final String languageCode = config . getServerLanguageCode () ; final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( languageCode != null ) {
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( format != null ) { if ( dfs != null ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI1Mutator]MSP[] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR2Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
final String languageCode = config . getServerLanguageCode () ; MST[NonVoidMethodCallMutator]MSP[] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; MST[NonVoidMethodCallMutator]MSP[] setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI2Mutator]MSP[] } } return 0 ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI1Mutator]MSP[] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI4Mutator]MSP[] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR2Mutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR2Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.ROR4Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[ReturnValsMutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR4Mutator]MSP[]
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; MST[NullReturnValsMutator]MSP[] } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR2Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI1Mutator]MSP[]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[NegateConditionalsMutator]MSP[]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR1Mutator]MSP[] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[InlineConstantMutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[NegateConditionalsMutator]MSP[] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR4Mutator]MSP[] final int value = working . get ( field ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI3Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI3Mutator]MSP[] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI1Mutator]MSP[] final int value = working . get ( field ) ;
final String languageCode = config . getServerLanguageCode () ; final String shortmonths = config . getShortMonthNames () ; MST[NonVoidMethodCallMutator]MSP[] if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI3Mutator]MSP[] return i ; } } return 0 ; }
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR3Mutator]MSP[] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI3Mutator]MSP[] final int value = working . get ( field ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR3Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR6Mutator]MSP[] } private static int indexOf ( final int calendarUnit ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[NonVoidMethodCallMutator]MSP[]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR1Mutator]MSP[] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR5Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { if ( format != null ) { if ( dfs != null ) { MST[experimental.MemberVariableMutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR6Mutator]MSP[] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ABSMutator]MSP[] return i ; } } return 0 ; }
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; MST[ReturnValsMutator]MSP[] } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR6Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR4Mutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[ConstructorCallMutator]MSP[] if ( format != null ) { if ( dfs != null ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI1Mutator]MSP[]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[NegateConditionalsMutator]MSP[] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI4Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[ReturnValsMutator]MSP[] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR2Mutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR6Mutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI2Mutator]MSP[] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[NonVoidMethodCallMutator]MSP[] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR1Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR3Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[VoidMethodCallMutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI4Mutator]MSP[] return i ; } } return 0 ; }
if ( value != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR5Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI1Mutator]MSP[] working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR5Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI2Mutator]MSP[] final int value = working . get ( field ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[VoidMethodCallMutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[VoidMethodCallMutator]MSP[]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[] } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI3Mutator]MSP[] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ABSMutator]MSP[] return i ; } } return 0 ; }
if ( value != 0 ) { MST[rv.ROR3Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[VoidMethodCallMutator]MSP[]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { MST[ReturnValsMutator]MSP[] return lenientFutureDates ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR5Mutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR5Mutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[experimental.NakedReceiverMutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR3Mutator]MSP[]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR6Mutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR1Mutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR5Mutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[NonVoidMethodCallMutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[InlineConstantMutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR6Mutator]MSP[] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR2Mutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR1Mutator]MSP[] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[NonVoidMethodCallMutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
if ( value != 0 ) { } else { working . clear ( field ) ; MST[VoidMethodCallMutator]MSP[] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI4Mutator]MSP[] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR5Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[InlineConstantMutator]MSP[]
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.ABSMutator]MSP[]
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[ReturnValsMutator]MSP[] return parseTimestamp ( timestampStr , now ) ; }
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; MST[VoidMethodCallMutator]MSP[] } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[ArgumentPropagationMutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[NonVoidMethodCallMutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NegateConditionalsMutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR1Mutator]MSP[] final int value = working . get ( field ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR6Mutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR3Mutator]MSP[] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[InlineConstantMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
} else { MST[NonVoidMethodCallMutator]MSP[] this . recentDateFormat = null ; } this . recentDateSmallestUnitIndex = getEntry ( this . recentDateFormat ) ; } public String [] getShortMonths () { return defaultDateFormat . getDateFormatSymbols () . getShortMonths () ; } public TimeZone getServerTimeZone () {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR2Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI4Mutator]MSP[]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[InlineConstantMutator]MSP[] final int value = working . get ( field ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI1Mutator]MSP[] } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI1Mutator]MSP[] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[NegateConditionalsMutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[experimental.MemberVariableMutator]MSP[]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[MathMutator]MSP[] final int value = working . get ( field ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ABSMutator]MSP[] return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR6Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR1Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR2Mutator]MSP[]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { MST[BooleanTrueReturnValsMutator]MSP[] return lenientFutureDates ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[rv.ROR5Mutator]MSP[] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[experimental.NakedReceiverMutator]MSP[]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI1Mutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
} else { MST[experimental.MemberVariableMutator]MSP[] this . recentDateFormat = null ; } this . recentDateSmallestUnitIndex = getEntry ( this . recentDateFormat ) ; } public String [] getShortMonths () { return defaultDateFormat . getDateFormatSymbols () . getShortMonths () ; } public TimeZone getServerTimeZone () {
if ( format != null ) { if ( dfs != null ) { MST[ConstructorCallMutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR6Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ABSMutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[VoidMethodCallMutator]MSP[] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR5Mutator]MSP[] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[ArgumentPropagationMutator]MSP[] return parseTimestamp ( timestampStr , now ) ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[rv.ROR5Mutator]MSP[] if ( recentDateFormat != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI1Mutator]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[PrimitiveReturnsMutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR1Mutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR5Mutator]MSP[] } private static int indexOf ( final int calendarUnit ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI2Mutator]MSP[] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI2Mutator]MSP[] final int value = working . get ( field ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[ArgumentPropagationMutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR4Mutator]MSP[] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR2Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[ConstructorCallMutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR1Mutator]MSP[] } private static int indexOf ( final int calendarUnit ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.ABSMutator]MSP[]
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[ReturnValsMutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR1Mutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ArgumentPropagationMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override MST[NonVoidMethodCallMutator]MSP[] public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[ReturnValsMutator]MSP[] } private static int indexOf ( final int calendarUnit ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR6Mutator]MSP[]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[IncrementsMutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[NegateConditionalsMutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR3Mutator]MSP[] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR3Mutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR6Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR2Mutator]MSP[]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR3Mutator]MSP[]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[ConstructorCallMutator]MSP[]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[InlineConstantMutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; MST[ReturnValsMutator]MSP[] }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR5Mutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[] } final String recentFormatString = config . getRecentDateFormatStr () ; setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI4Mutator]MSP[] working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI4Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI4Mutator]MSP[] } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI3Mutator]MSP[]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI3Mutator]MSP[] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR4Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI2Mutator]MSP[] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ; MST[VoidMethodCallMutator]MSP[]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; MST[NonVoidMethodCallMutator]MSP[] for( final char ch : FORMAT_CHARS . toCharArray () ) {
working . setTime ( parsed ) ; } else { throw new ParseException ( MST[ConstructorCallMutator]MSP[] lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( value != 0 ) { MST[rv.ROR2Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR3Mutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[NonVoidMethodCallMutator]MSP[]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR4Mutator]MSP[]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR2Mutator]MSP[] final int value = working . get ( field ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( recentDateFormat != null ) {
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[VoidMethodCallMutator]MSP[] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI2Mutator]MSP[]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI3Mutator]MSP[]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[InlineConstantMutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NegateConditionalsMutator]MSP[]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[NegateConditionalsMutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override MST[VoidMethodCallMutator]MSP[] public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[NonVoidMethodCallMutator]MSP[] if ( recentDateFormat != null ) {
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI3Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR6Mutator]MSP[] final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR2Mutator]MSP[] final int value = working . get ( field ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[ReturnValsMutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI1Mutator]MSP[] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI3Mutator]MSP[] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR6Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[ArgumentPropagationMutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.UOI1Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[rv.ROR5Mutator]MSP[]
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.ABSMutator]MSP[] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[InlineConstantMutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.UOI4Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR1Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { MST[ArgumentPropagationMutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR3Mutator]MSP[] final int value = working . get ( field ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI2Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_5]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_4]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR4Mutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( format != null ) { if ( dfs != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR1Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR5Mutator]MSP[] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI2Mutator]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR6Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.ABSMutator]MSP[]
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.ABSMutator]MSP[] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[InlineConstantMutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR3Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR5Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.ROR1Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ConstructorCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR3Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR1Mutator]MSP[]
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR5Mutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[PrimitiveReturnsMutator]MSP[]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; MST[experimental.MemberVariableMutator]MSP[] setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[VoidMethodCallMutator]MSP[] working . add ( Calendar . YEAR , - 1 ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[NonVoidMethodCallMutator]MSP[] return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR5Mutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR4Mutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI1Mutator]MSP[] return i ; } } return 0 ; }
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.ABSMutator]MSP[] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[NegateConditionalsMutator]MSP[]
if ( value != 0 ) { MST[NegateConditionalsMutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[NegateConditionalsMutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR5Mutator]MSP[] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR1Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return i ; } } return 0 ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; MST[NullReturnValsMutator]MSP[] }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR6Mutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[ArgumentPropagationMutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR2Mutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR6Mutator]MSP[] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI3Mutator]MSP[]
if ( value != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI2Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[InlineConstantMutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[VoidMethodCallMutator]MSP[] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR4Mutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR4Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR2Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; setRecentDateFormat ( recentFormatString , dfs ) ; MST[ConstructorCallMutator]MSP[] final String defaultFormatString = config . getDefaultDateFormatStr () ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI4Mutator]MSP[] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { MST[VoidMethodCallMutator]MSP[] serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[NegateConditionalsMutator]MSP[] return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI3Mutator]MSP[] } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI2Mutator]MSP[]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[rv.ROR5Mutator]MSP[]
if ( value != 0 ) { MST[rv.ABSMutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[VoidMethodCallMutator]MSP[] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[NonVoidMethodCallMutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ConstructorCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR4Mutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override MST[NonVoidMethodCallMutator]MSP[] public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[ReturnValsMutator]MSP[] } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR4Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NegateConditionalsMutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI3Mutator]MSP[]
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[NonVoidMethodCallMutator]MSP[] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR2Mutator]MSP[]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[InlineConstantMutator]MSP[] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR3Mutator]MSP[] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[PrimitiveReturnsMutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR4Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[ConstructorCallMutator]MSP[]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR1Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI1Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI3Mutator]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR6Mutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ConstructorCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[InlineConstantMutator]MSP[] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[InlineConstantMutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[VoidMethodCallMutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.ABSMutator]MSP[] final int value = working . get ( field ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR2Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[NonVoidMethodCallMutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
if ( value != 0 ) { MST[rv.UOI3Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[experimental.MemberVariableMutator]MSP[] if ( format != null ) { if ( dfs != null ) {
final String languageCode = config . getServerLanguageCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { if ( format != null ) { if ( dfs != null ) { MST[ConstructorCallMutator]MSP[]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[VoidMethodCallMutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR5Mutator]MSP[]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI4Mutator]MSP[]
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[rv.ROR5Mutator]MSP[] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR5Mutator]MSP[] final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR3Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI4Mutator]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.SwitchMutator]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( MST[NonVoidMethodCallMutator]MSP[] lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { MST[experimental.MemberVariableMutator]MSP[] this . defaultDateFormat = null ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI2Mutator]MSP[] return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR5Mutator]MSP[] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.ABSMutator]MSP[] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR3Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI1Mutator]MSP[]
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { MST[NonVoidMethodCallMutator]MSP[] this . defaultDateFormat = null ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[PrimitiveReturnsMutator]MSP[] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI4Mutator]MSP[] final int value = working . get ( field ) ;
final String languageCode = config . getServerLanguageCode () ; MST[rv.ROR5Mutator]MSP[] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR2Mutator]MSP[] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.ABSMutator]MSP[]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR3Mutator]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
if ( value != 0 ) { MST[rv.ROR5Mutator]MSP[] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR3Mutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR5Mutator]MSP[]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR4Mutator]MSP[] final int value = working . get ( field ) ;
working . setTime ( parsed ) ; } else { MST[experimental.NakedReceiverMutator]MSP[] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR1Mutator]MSP[] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI4Mutator]MSP[]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[NonVoidMethodCallMutator]MSP[] case 'm' : return indexOf ( Calendar . MINUTE ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[ReturnValsMutator]MSP[]
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[InlineConstantMutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI3Mutator]MSP[] working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI1Mutator]MSP[] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR3Mutator]MSP[] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOD1Mutator]MSP[] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[NonVoidMethodCallMutator]MSP[] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[experimental.MemberVariableMutator]MSP[]
