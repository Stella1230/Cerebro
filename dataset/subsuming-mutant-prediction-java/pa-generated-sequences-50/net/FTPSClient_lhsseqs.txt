public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[NegateConditionalsMutator]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getUseClientMode () ; } return false ; } public void setEnabledCipherSuites ( final String [] cipherSuites ) { MST[ReturnValsMutator]MSP[] suites = new String [ cipherSuites . length ] ;
public void setAuthValue ( final String auth ) { MST[rv.UOI1Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR2Mutator]MSP[]
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[NonVoidMethodCallMutator]MSP[]
} public int execAUTH ( final String mechanism ) throws IOException { return sendCommand ( CMD_AUTH , mechanism ) ; } public int execADAT ( final byte [] data ) throws IOException MST[NonVoidMethodCallMutator]MSP[] { if ( data != null ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override MST[VoidMethodCallMutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { MST[rv.ABSMutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override MST[ReturnValsMutator]MSP[]
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR3Mutator]MSP[] }
public void setAuthValue ( final String auth ) { MST[InlineConstantMutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
} else if ( FTPReply . SECURITY_DATA_EXCHANGE_COMPLETE != replyCode ) { throw new SSLException ( getReplyString () ) ; } } private void initSslContext () throws IOException { if ( context == null ) { MST[NonVoidMethodCallMutator]MSP[] context = SSLContextUtils . createSSLContext ( protocol , getKeyManager () , getTrustManager () ) ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.CRCR3Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[InlineConstantMutator]MSP[] }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new SSLException ( getReplyString () ) ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[NonVoidMethodCallMutator]MSP[]
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[rv.ROR5Mutator]MSP[] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR3Mutator]MSP[] throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR4Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
throw new IllegalArgumentException () ; MST[VoidMethodCallMutator]MSP[] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR1Mutator]MSP[] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR2Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[ReturnValsMutator]MSP[] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; MST[ReturnValsMutator]MSP[] } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[NonVoidMethodCallMutator]MSP[] if ( prot == null ) {
} else if ( FTPReply . SECURITY_DATA_EXCHANGE_COMPLETE != replyCode ) { throw new SSLException ( getReplyString () ) ; } } private void initSslContext () throws IOException { if ( context == null ) { context = SSLContextUtils . createSSLContext ( protocol , getKeyManager () , getTrustManager () ) ; MST[NonVoidMethodCallMutator]MSP[]
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR4Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
throw new IllegalArgumentException () ; MST[rv.UOI2Mutator]MSP[] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[experimental.MemberVariableMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI3Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[NegateConditionalsMutator]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR2Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR4Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR5Mutator]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[NegateConditionalsMutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR5Mutator]MSP[] }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI2Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( prot == null ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR4Mutator]MSP[] if ( prot == null ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[VoidMethodCallMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
if ( protocols != null ) { sslSocket . setEnabledProtocols ( protocols ) ; } sslSocket . startHandshake () ; } return socket ; } protected void _prepareDataSocket_ ( final Socket socket ) MST[experimental.MemberVariableMutator]MSP[] throws IOException { } public TrustManager getTrustManager () { return trustManager ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[InlineConstantMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR4Mutator]MSP[]
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[BooleanTrueReturnValsMutator]MSP[] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.ABSMutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[BooleanTrueReturnValsMutator]MSP[] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[NegateConditionalsMutator]MSP[] throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.ABSMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR1Mutator]MSP[] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[rv.ROR5Mutator]MSP[] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
public void setAuthValue ( final String auth ) { MST[rv.CRCR1Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[NegateConditionalsMutator]MSP[] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; } public boolean isEndpointCheckingEnabled () MST[NonVoidMethodCallMutator]MSP[] { return tlsEndpointChecking ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR5Mutator]MSP[] throw new SSLException ( getReplyString () ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR3Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException MST[NonVoidMethodCallMutator]MSP[] { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[rv.ROR5Mutator]MSP[] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR4Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[ReturnValsMutator]MSP[] }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR6Mutator]MSP[] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR5Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR1Mutator]MSP[] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[InlineConstantMutator]MSP[] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR2Mutator]MSP[] if ( prot == null ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[VoidMethodCallMutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
return ( ( SSLSocket ) _socket_ ) . getUseClientMode () ; } return false ; } public void setEnabledCipherSuites ( final String [] cipherSuites ) { MST[experimental.MemberVariableMutator]MSP[] suites = new String [ cipherSuites . length ] ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
if ( ! isImplicit ) { MST[NonVoidMethodCallMutator]MSP[] execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR5Mutator]MSP[]
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new SSLException ( getReplyString () ) ; }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[InlineConstantMutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI3Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setAuthValue ( final String auth ) { MST[VoidMethodCallMutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI2Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR6Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR5Mutator]MSP[] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.ABSMutator]MSP[] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR2Mutator]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR2Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI2Mutator]MSP[] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI1Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR2Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR2Mutator]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR2Mutator]MSP[] }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR4Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.UOI4Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR2Mutator]MSP[] throw new SSLException ( getReplyString () ) ; }
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI3Mutator]MSP[] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR6Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI2Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR6Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR2Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR5Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[ReturnValsMutator]MSP[] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR1Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR1Mutator]MSP[] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR5Mutator]MSP[] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[NonVoidMethodCallMutator]MSP[]
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI4Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR1Mutator]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override MST[NullReturnValsMutator]MSP[]
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[BooleanTrueReturnValsMutator]MSP[] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI1Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI2Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[NonVoidMethodCallMutator]MSP[] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
public void setAuthValue ( final String auth ) { MST[rv.ROR3Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR6Mutator]MSP[] }
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR4Mutator]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR1Mutator]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR3Mutator]MSP[] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[InlineConstantMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override @Deprecated MST[NonVoidMethodCallMutator]MSP[] protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[ReturnValsMutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { MST[rv.CRCR6Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[InlineConstantMutator]MSP[] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR3Mutator]MSP[] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[NegateConditionalsMutator]MSP[] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
} public int execAUTH ( final String mechanism ) throws IOException MST[NonVoidMethodCallMutator]MSP[] { return sendCommand ( CMD_AUTH , mechanism ) ; } public int execADAT ( final byte [] data ) throws IOException { if ( data != null ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR5Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR5Mutator]MSP[] if ( prot == null ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR3Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI2Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR6Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR6Mutator]MSP[] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; } setSocketFactory ( null ) ; MST[NonVoidMethodCallMutator]MSP[] setServerSocketFactory ( null ) ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new SSLException ( getReplyString () ) ; }
public void setAuthValue ( final String auth ) { MST[rv.CRCR4Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR3Mutator]MSP[]
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[InlineConstantMutator]MSP[] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[InlineConstantMutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[NegateConditionalsMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR5Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR3Mutator]MSP[] if ( prot == null ) {
public int execMIC ( final byte [] data ) throws IOException MST[ArgumentPropagationMutator]MSP[] { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI4Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[NegateConditionalsMutator]MSP[]
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR4Mutator]MSP[] }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[NegateConditionalsMutator]MSP[] if ( prot == null ) {
public void setAuthValue ( final String auth ) { MST[rv.UOI2Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[rv.ROR5Mutator]MSP[] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR5Mutator]MSP[] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR4Mutator]MSP[] throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[NegateConditionalsMutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
socket . getOutputStream () , getControlEncoding () ) ) ; if ( isClientMode ) { if ( hostnameVerifier != null && ! hostnameVerifier . verify ( _hostname_ , socket . getSession () ) ) { MST[experimental.MemberVariableMutator]MSP[] throw new SSLHandshakeException ( lr_1 ) ; } } } private KeyManager getKeyManager () {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR4Mutator]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[NegateConditionalsMutator]MSP[] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[experimental.MemberVariableMutator]MSP[]
throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
public void setAuthValue ( final String auth ) { MST[NegateConditionalsMutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR4Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[InlineConstantMutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; } public boolean isEndpointCheckingEnabled () MST[NonVoidMethodCallMutator]MSP[] { return tlsEndpointChecking ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[ReturnValsMutator]MSP[] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR3Mutator]MSP[] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public void setEnabledProtocols ( final String [] protocolVersions ) { MST[ReturnValsMutator]MSP[] protocols = new String [ protocolVersions . length ] ; System . arraycopy ( protocolVersions , 0 , protocols , 0 , protocolVersions . length ) ; } public String [] getEnabledProtocols () {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[InlineConstantMutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR4Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[experimental.MemberVariableMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException MST[NonVoidMethodCallMutator]MSP[] { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setAuthValue ( final String auth ) { MST[rv.CRCR5Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR6Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override MST[VoidMethodCallMutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR5Mutator]MSP[] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[ReturnValsMutator]MSP[] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR1Mutator]MSP[] throw new SSLException ( getReplyString () ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR6Mutator]MSP[] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[rv.ROR5Mutator]MSP[] }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR3Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( prot == null ) {
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR3Mutator]MSP[] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[ReturnValsMutator]MSP[] }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR2Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI1Mutator]MSP[] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
private boolean checkPROTValue ( final String prot ) { for ( final String element : PROT_COMMAND_VALUE ) { MST[NonVoidMethodCallMutator]MSP[] if ( element . equals ( prot ) ) { return true ; } } return false ; } @Override
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[BooleanTrueReturnValsMutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR3Mutator]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI4Mutator]MSP[] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
public void setAuthValue ( final String auth ) { MST[rv.UOI3Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; } setSocketFactory ( null ) ; MST[NonVoidMethodCallMutator]MSP[] setServerSocketFactory ( null ) ;
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[InlineConstantMutator]MSP[] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR1Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException MST[NonVoidMethodCallMutator]MSP[] { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; }
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR6Mutator]MSP[] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR3Mutator]MSP[] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI4Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR6Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
if ( suites != null ) { socket . setEnabledCipherSuites ( suites ) ; } socket . startHandshake () ; _socket_ = socket ; MST[ReturnValsMutator]MSP[] _controlInput_ = new BufferedReader ( new InputStreamReader ( socket . getInputStream () , getControlEncoding () ) ) ; _controlOutput_ = new BufferedWriter ( new OutputStreamWriter (
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () MST[NonVoidMethodCallMutator]MSP[] { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI2Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) MST[NonVoidMethodCallMutator]MSP[] { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[NegateConditionalsMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ABSMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ABSMutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR1Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI4Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setAuthValue ( final String auth ) { MST[EmptyObjectReturnValsMutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[NegateConditionalsMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR1Mutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.CRCR2Mutator]MSP[] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[NegateConditionalsMutator]MSP[] }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR1Mutator]MSP[]
if ( suites != null ) { socket . setEnabledCipherSuites ( suites ) ; } socket . startHandshake () ; _socket_ = socket ; MST[NullReturnValsMutator]MSP[] _controlInput_ = new BufferedReader ( new InputStreamReader ( socket . getInputStream () , getControlEncoding () ) ) ; _controlOutput_ = new BufferedWriter ( new OutputStreamWriter (
} else if ( FTPReply . SECURITY_DATA_EXCHANGE_COMPLETE != replyCode ) { throw new SSLException ( getReplyString () ) ; } } private void initSslContext () throws IOException { MST[VoidMethodCallMutator]MSP[] if ( context == null ) { context = SSLContextUtils . createSSLContext ( protocol , getKeyManager () , getTrustManager () ) ;
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR1Mutator]MSP[] if ( prot == null ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR2Mutator]MSP[] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI1Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[experimental.MemberVariableMutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR5Mutator]MSP[] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[NegateConditionalsMutator]MSP[] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[experimental.MemberVariableMutator]MSP[] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[ReturnValsMutator]MSP[] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR5Mutator]MSP[] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
