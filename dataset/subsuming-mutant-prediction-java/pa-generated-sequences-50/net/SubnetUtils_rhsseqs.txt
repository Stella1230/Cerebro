return str . toString () ; } @Override MST[rv.CRCR5Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[S] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR2Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI2Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI3Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[N] if ( value >= begin && value <= end ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR2Mutator]MSP[N]
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR5Mutator]MSP[N] final StringBuilder str = new StringBuilder () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI4Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI3Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR4Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI1Mutator]MSP[N] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR4Mutator]MSP[N]
return str . toString () ; } @Override MST[ReturnValsMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR1Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR4Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR5Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI3Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[ArgumentPropagationMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return str . toString () ; } @Override MST[rv.CRCR1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } MST[experimental.NakedReceiverMutator]MSP[N] private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR3Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.OBBN2Mutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[InlineConstantMutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOD1Mutator]MSP[N] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI3Mutator]MSP[N]
return str . toString () ; } @Override MST[InlineConstantMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } MST[rv.ROR2Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR6Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI4Mutator]MSP[N] } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR4Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR1Mutator]MSP[N] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[N] if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.OBBN2Mutator]MSP[N]
private int [] toArray ( final int val ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI4Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR1Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final long b = broadcastLong () ; final long n = networkLong () ;
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return str . toString () ; } @Override MST[rv.AOD1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[NegateConditionalsMutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR6Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[rv.CRCR4Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.UOI1Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.ABSMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.MemberVariableMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; MST[rv.UOI3Mutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[rv.ROR3Mutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[rv.ROR5Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.ABSMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR4Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[InlineConstantMutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR5Mutator]MSP[S] return toInteger ( address ) ; } public String getCidrSignature () {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR3Mutator]MSP[N] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.ABSMutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOR3Mutator]MSP[N]
return str . toString () ; } @Override MST[NullReturnValsMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.ABSMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[ArgumentPropagationMutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI4Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR6Mutator]MSP[S] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[ConstructorCallMutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.OBBN3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI4Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI2Mutator]MSP[N] int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR2Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[NegateConditionalsMutator]MSP[N] final long b = broadcastLong () ; final long n = networkLong () ;
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR1Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.NakedReceiverMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR5Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOD2Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.ABSMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR4Mutator]MSP[N] if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR1Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOD1Mutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[InlineConstantMutator]MSP[N] final StringBuilder str = new StringBuilder () ;
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.ABSMutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
private int [] toArray ( final int val ) { MST[NonVoidMethodCallMutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[InlineConstantMutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR3Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR3Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR1Mutator]MSP[N] int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[InlineConstantMutator]MSP[N]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI3Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[S] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR6Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI1Mutator]MSP[N] } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR3Mutator]MSP[N] int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR3Mutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[MathMutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[InlineConstantMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI3Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI1Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[ReturnValsMutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR4Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOD2Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI3Mutator]MSP[N]
return str . toString () ; } @Override MST[MathMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR2Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR6Mutator]MSP[N]
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR5Mutator]MSP[N] final long b = broadcastLong () ; final long n = networkLong () ;
return buf . toString () ; MST[rv.UOI1Mutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI4Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.ABSMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return str . toString () ; } @Override MST[rv.CRCR6Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ABSMutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.ABSMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return str . toString () ; } @Override MST[rv.AOD2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI4Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR5Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[experimental.MemberVariableMutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[N] if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOD1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[MathMutator]MSP[N] int addr = 0 ;
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[NonVoidMethodCallMutator]MSP[N] final long b = broadcastLong () ; final long n = networkLong () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR4Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[MathMutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI1Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI3Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR4Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR2Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI2Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI1Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[S] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[ConstructorCallMutator]MSP[S] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI3Mutator]MSP[N] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR3Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[ReturnValsMutator]MSP[N] if ( value >= begin && value <= end ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[ConstructorCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR4Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOD1Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI1Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR5Mutator]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[InlineConstantMutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.NakedReceiverMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[InlineConstantMutator]MSP[S] return toInteger ( address ) ; } public String getCidrSignature () {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.CRCR6Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.OBBN2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR4Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI1Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR5Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } MST[rv.AOR3Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR3Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } MST[rv.ABSMutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR3Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR5Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI2Mutator]MSP[N] } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR1Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[rv.CRCR4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
private int [] toArray ( final int val ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR1Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR3Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[InlineConstantMutator]MSP[N]
return str . toString () ; } @Override MST[MathMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.OBBN2Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.AOR4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[N] if ( matcher . matches () ) {
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR3Mutator]MSP[N] final long b = broadcastLong () ; final long n = networkLong () ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[InlineConstantMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
private int [] toArray ( final int val ) { MST[rv.ROR1Mutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR6Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.NakedReceiverMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOD2Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI2Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR1Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.ABSMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOD1Mutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI1Mutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ABSMutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[N] if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.OBBN1Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return buf . toString () ; } MST[rv.AOD2Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } MST[NegateConditionalsMutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR2Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR5Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.CRCR2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI2Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.OBBN2Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI2Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI4Mutator]MSP[N] int addr = 0 ;
return str . toString () ; } @Override MST[rv.AOR1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.AOR3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[InlineConstantMutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[InlineConstantMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR5Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[InlineConstantMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR4Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI4Mutator]MSP[N]
return buf . toString () ; } MST[rv.ROR3Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI4Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.ABSMutator]MSP[N] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[MathMutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR5Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.OBBN1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[InlineConstantMutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI4Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.UOI4Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR6Mutator]MSP[N]
return buf . toString () ; MST[rv.UOI3Mutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[rv.ROR4Mutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR1Mutator]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR5Mutator]MSP[N] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR1Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.OBBN1Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR3Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.OBBN1Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI4Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR1Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI3Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[MathMutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.ABSMutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR6Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return str . toString () ; } @Override MST[rv.AOR2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } MST[rv.CRCR2Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[ConditionalsBoundaryMutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[N] if ( matcher . matches () ) {
return buf . toString () ; MST[rv.ABSMutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR2Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[InlineConstantMutator]MSP[N]
private int [] toArray ( final int val ) { MST[ReturnValsMutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR2Mutator]MSP[N] if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI4Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[experimental.MemberVariableMutator]MSP[N]
return str . toString () ; } @Override MST[rv.CRCR3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[MathMutator]MSP[N]
return str . toString () ; } @Override MST[rv.UOI1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR4Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR5Mutator]MSP[N]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR6Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[InlineConstantMutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
private int [] toArray ( final int val ) { MST[NonVoidMethodCallMutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[PrimitiveReturnsMutator]MSP[N] } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[EmptyObjectReturnValsMutator]MSP[N] if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI3Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[experimental.MemberVariableMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR3Mutator]MSP[N]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI1Mutator]MSP[N]
return buf . toString () ; } MST[rv.AOR1Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[MathMutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI1Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR4Mutator]MSP[N]
return buf . toString () ; MST[rv.UOI4Mutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI1Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return str . toString () ; } @Override MST[rv.CRCR1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR4Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[ConstructorCallMutator]MSP[S] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR1Mutator]MSP[N] final StringBuilder str = new StringBuilder () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI3Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOR2Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[MathMutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI3Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI4Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[N] if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[ConditionalsBoundaryMutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR6Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR5Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR2Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[N] if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR3Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI3Mutator]MSP[S] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR3Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.OBBN1Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[experimental.NakedReceiverMutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI3Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.ABSMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; MST[rv.UOI2Mutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR5Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.OBBN3Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR4Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR2Mutator]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR2Mutator]MSP[N] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR5Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR6Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI1Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.OBBN3Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI4Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.CRCR3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR5Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR4Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR4Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR1Mutator]MSP[S] final long b = broadcastLong () ; final long n = networkLong () ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOD2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR3Mutator]MSP[N] if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI3Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI2Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.CRCR2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[InlineConstantMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; MST[experimental.NakedReceiverMutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.CRCR4Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } MST[NonVoidMethodCallMutator]MSP[N] private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI1Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.AOD1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI2Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI4Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR5Mutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR6Mutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR1Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR2Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR1Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI3Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI1Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI4Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.CRCR6Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI4Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) MST[ConstructorCallMutator]MSP[N] . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI4Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR1Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.ABSMutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[S] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[InlineConstantMutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR4Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[rv.AOR4Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI4Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[N] if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR5Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[N] if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[N] if ( matcher . matches () ) {
return buf . toString () ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.ABSMutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR6Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[InlineConstantMutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI2Mutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR2Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[InlineConstantMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.OBBN1Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[MathMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[experimental.NakedReceiverMutator]MSP[N]
return str . toString () ; } @Override MST[rv.UOI3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[PrimitiveReturnsMutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI2Mutator]MSP[N] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR5Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[ConditionalsBoundaryMutator]MSP[N] if ( matcher . matches () ) {
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR4Mutator]MSP[N] final long b = broadcastLong () ; final long n = networkLong () ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[NegateConditionalsMutator]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR4Mutator]MSP[N] if ( matcher . matches () ) {
return buf . toString () ; } MST[rv.UOI3Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[MathMutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR5Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[IncrementsMutator]MSP[N]
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.AOD2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[S] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR4Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR2Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR2Mutator]MSP[N] int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR4Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR3Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.OBBN3Mutator]MSP[N]
return buf . toString () ; } MST[rv.ROR1Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR6Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[N] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[MathMutator]MSP[N] int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[InlineConstantMutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } MST[rv.AOD1Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR5Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI1Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.ABSMutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR1Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.UOI3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.OBBN3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[experimental.NakedReceiverMutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR3Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI1Mutator]MSP[N] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[InlineConstantMutator]MSP[N] int addr = 0 ;
return buf . toString () ; } MST[rv.CRCR5Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; MST[rv.UOI1Mutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI4Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR4Mutator]MSP[N]
private int [] toArray ( final int val ) { MST[rv.ROR2Mutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI4Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR6Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR3Mutator]MSP[N]
return buf . toString () ; } MST[InlineConstantMutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return str . toString () ; } @Override MST[rv.CRCR3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[InlineConstantMutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR3Mutator]MSP[N] final StringBuilder str = new StringBuilder () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI1Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI3Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOR4Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[ConstructorCallMutator]MSP[S] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR2Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR6Mutator]MSP[N]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[MathMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return buf . toString () ; MST[rv.UOI4Mutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[NegateConditionalsMutator]MSP[N] if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI1Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR1Mutator]MSP[N] if ( matcher . matches () ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[MathMutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.ABSMutator]MSP[N] } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOD2Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[MathMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI2Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI3Mutator]MSP[N] int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.OBBN1Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[MathMutator]MSP[N]
return str . toString () ; } @Override MST[rv.AOR4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR3Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[N] if ( value >= begin && value <= end ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[InlineConstantMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[ReturnValsMutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR4Mutator]MSP[N] int addr = 0 ;
return buf . toString () ; } MST[rv.UOI1Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.OBBN2Mutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR2Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI2Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI3Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI2Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ABSMutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.UOI3Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[ReturnValsMutator]MSP[N] } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return str . toString () ; } @Override MST[rv.OBBN2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final long b = broadcastLong () ; final long n = networkLong () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR2Mutator]MSP[N]
return buf . toString () ; } MST[rv.CRCR6Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[ArgumentPropagationMutator]MSP[N] if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR2Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[ConditionalsBoundaryMutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR3Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI4Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.OBBN3Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[ConditionalsBoundaryMutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.ABSMutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[InlineConstantMutator]MSP[N]
return str . toString () ; } @Override MST[MathMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[PrimitiveReturnsMutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN3Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.AOR1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[N] if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR4Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR5Mutator]MSP[N] if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[PrimitiveReturnsMutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR3Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.ABSMutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI2Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI2Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI2Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.ABSMutator]MSP[N] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[MathMutator]MSP[N]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[ConstructorCallMutator]MSP[N] if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI3Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } MST[MathMutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI1Mutator]MSP[N] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR5Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI2Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.OBBN1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.ABSMutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI2Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return buf . toString () ; } MST[rv.AOR2Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR3Mutator]MSP[N]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR5Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR1Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR6Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.OBBN2Mutator]MSP[N] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[ConstructorCallMutator]MSP[N]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR3Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR2Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR1Mutator]MSP[N] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN2Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[InlineConstantMutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return str . toString () ; } @Override MST[rv.CRCR4Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR2Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOD2Mutator]MSP[N] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI2Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[rv.AOR3Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } MST[rv.CRCR3Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[NegateConditionalsMutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR2Mutator]MSP[N]
return str . toString () ; } @Override MST[rv.CRCR5Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR6Mutator]MSP[N] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI3Mutator]MSP[N] } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR4Mutator]MSP[N] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD1Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR2Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[rv.UOI1Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.ABSMutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN1Mutator]MSP[N] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR4Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[InlineConstantMutator]MSP[N]
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[MathMutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
private int [] toArray ( final int val ) { MST[rv.ROR5Mutator]MSP[N] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return buf . toString () ; MST[rv.ABSMutator]MSP[N] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR6Mutator]MSP[N]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR5Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[N] if ( value >= begin && value <= end ) {
return buf . toString () ; } MST[rv.ROR4Mutator]MSP[N] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOD1Mutator]MSP[N]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR1Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR1Mutator]MSP[N]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI4Mutator]MSP[N] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI1Mutator]MSP[N] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.OBBN3Mutator]MSP[N] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.ABSMutator]MSP[N]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR6Mutator]MSP[N] final StringBuilder str = new StringBuilder () ;
return str . toString () ; } @Override MST[rv.AOR2Mutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.OBBN3Mutator]MSP[N]
return str . toString () ; } @Override MST[InlineConstantMutator]MSP[N] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR5Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR6Mutator]MSP[N] return toInteger ( address ) ; } public String getCidrSignature () {
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR2Mutator]MSP[N] final long b = broadcastLong () ; final long n = networkLong () ;
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[NegateConditionalsMutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[N] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR4Mutator]MSP[N] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR5Mutator]MSP[N]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[N] if ( matcher . matches () ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[NegateConditionalsMutator]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR3Mutator]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[NegateConditionalsMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI1Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( broadcast ) ) ; MST[rv.ABSMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( broadcast ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[ArgumentPropagationMutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR2Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[NonVoidMethodCallMutator]MSP[N] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR2Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ReturnValsMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_IF]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR5Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[NegateConditionalsMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[ReturnValsMutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR1Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[ConditionalsBoundaryMutator]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[PrimitiveReturnsMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR4Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[ReturnValsMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getHighAddress () { return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { MST[rv.CRCR5Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NegateConditionalsMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR4Mutator]MSP[N]
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI4Mutator]MSP[N] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[NonVoidMethodCallMutator]MSP[N] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR3Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD1Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR2Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[InlineConstantMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[NegateConditionalsMutator]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR5Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI3Mutator]MSP[N]
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ConditionalsBoundaryMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR5Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[ConditionalsBoundaryMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR4Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR5Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR3Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI4Mutator]MSP[N]
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[NonVoidMethodCallMutator]MSP[N] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[BooleanFalseReturnValsMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[PrimitiveReturnsMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { MST[ReturnValsMutator]MSP[N] return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR1Mutator]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR4Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR6Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR2Mutator]MSP[N]
return format ( toArray ( broadcast ) ) ; MST[ConstructorCallMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { MST[ReturnValsMutator]MSP[N] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR3Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[ReturnValsMutator]MSP[S] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[NonVoidMethodCallMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[ReturnValsMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { MST[rv.CRCR5Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR1Mutator]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.ROR5Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR3Mutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR2Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR6Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR4Mutator]MSP[S] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { MST[NonVoidMethodCallMutator]MSP[N] return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NegateConditionalsMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ABSMutator]MSP[S]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR6Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[MathMutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR5Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR4Mutator]MSP[S] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR5Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR4Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI1Mutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[NonVoidMethodCallMutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NegateConditionalsMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI4Mutator]MSP[N]
public boolean isInclusiveHostCount () { MST[ReturnValsMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.AOR3Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { MST[PrimitiveReturnsMutator]MSP[N] return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[EmptyObjectReturnValsMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ConditionalsBoundaryMutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[ReturnValsMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[NegateConditionalsMutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR1Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI1Mutator]MSP[N] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR5Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[rv.UOI3Mutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR5Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[InlineConstantMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR5Mutator]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[NonVoidMethodCallMutator]MSP[S] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR3Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI2Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR6Mutator]MSP[N]
private int low () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { MST[rv.CRCR1Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR1Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR2Mutator]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[EmptyObjectReturnValsMutator]MSP[N] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[ConditionalsBoundaryMutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[ConstructorCallMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[NonVoidMethodCallMutator]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI3Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR5Mutator]MSP[S]
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR1Mutator]MSP[N]
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR4Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[ReturnValsMutator]MSP[N] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD1Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.ABSMutator]MSP[N] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { MST[rv.ROR4Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[PrimitiveReturnsMutator]MSP[N] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { MST[EmptyObjectReturnValsMutator]MSP[N] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR3Mutator]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR6Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR2Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR4Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.ABSMutator]MSP[N]
private int low () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.ROR4Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR3Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[rv.UOI4Mutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { MST[MathMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NegateConditionalsMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI1Mutator]MSP[N]
public boolean isInclusiveHostCount () { MST[rv.AOR4Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[InlineConstantMutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR1Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR2Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI2Mutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[NullReturnValsMutator]MSP[S] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[PrimitiveReturnsMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[NonVoidMethodCallMutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR3Mutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () { MST[NonVoidMethodCallMutator]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR2Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD2Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI2Mutator]MSP[N] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ReturnValsMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR1Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR5Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[ReturnValsMutator]MSP[N] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[ReturnValsMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR3Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR1Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR3Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ABSMutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR5Mutator]MSP[S]
public boolean isInclusiveHostCount () { MST[rv.AOR4Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD2Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[EmptyObjectReturnValsMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[ReturnValsMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[EmptyObjectReturnValsMutator]MSP[S] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_IF]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[ReturnValsMutator]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI4Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR4Mutator]MSP[N]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[BooleanTrueReturnValsMutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR1Mutator]MSP[N] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[MathMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[InlineConstantMutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR3Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[InlineConstantMutator]MSP[S]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI2Mutator]MSP[N]
public boolean isInclusiveHostCount () { MST[rv.AOR1Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[InlineConstantMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[N] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR3Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR6Mutator]MSP[S] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI3Mutator]MSP[N] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( broadcast ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[MathMutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[BooleanTrueReturnValsMutator]MSP[S] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR3Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR2Mutator]MSP[N] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[S] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ReturnValsMutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR2Mutator]MSP[N] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR2Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR2Mutator]MSP[N] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR1Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[EmptyObjectReturnValsMutator]MSP[N]
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI3Mutator]MSP[S]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[N] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
