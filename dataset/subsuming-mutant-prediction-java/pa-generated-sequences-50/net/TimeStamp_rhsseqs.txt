long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[MathMutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR2Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR1Mutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.ABSMutator]MSP[N] {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[PrimitiveReturnsMutator]MSP[N] }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[rv.UOI2Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.CRCR3Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.ABSMutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.ROR4Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR5Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; MST[ReturnValsMutator]MSP[N] }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR3Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR4Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI4Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI2Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.UOI3Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) MST[ConstructorCallMutator]MSP[N] throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR4Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ABSMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.OBBN1Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.ROR3Mutator]MSP[N] if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.AOR3Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR5Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI4Mutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR3Mutator]MSP[N] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.CRCR1Mutator]MSP[S] } long seconds = baseTime / 1000 ;
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.UOI2Mutator]MSP[N] {
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[rv.UOI2Mutator]MSP[N] { return getTime ( ntpTime ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI4Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI3Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR3Mutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR5Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.OBBN1Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR6Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.CRCR1Mutator]MSP[N] return time ; } @Override public int hashCode () {
if ( simpleFormatter == null ) { MST[VoidMethodCallMutator]MSP[N] simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString ()
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[rv.ABSMutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[MathMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.AOD1Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.OBBN3Mutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[InlineConstantMutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI1Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.CRCR3Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[InlineConstantMutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR2Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[MathMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[MathMutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[MathMutator]MSP[N] {
public Date getDate () MST[rv.UOI1Mutator]MSP[N] { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOD2Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
protected static long decodeNtpHexString ( final String hexString ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.UOI3Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI4Mutator]MSP[N] }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI2Mutator]MSP[S] {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[ConditionalsBoundaryMutator]MSP[N] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[InlineConstantMutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI1Mutator]MSP[N] return time ; } @Override public int hashCode () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI2Mutator]MSP[N] return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR2Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR3Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public long ntpValue () MST[rv.UOI3Mutator]MSP[N] { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR4Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR5Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD1Mutator]MSP[N] }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = s . length () ; i < 8 ; i ++ ) { buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) MST[ConstructorCallMutator]MSP[N] {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[InlineConstantMutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.OBBN3Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR3Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR4Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR2Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[InlineConstantMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.AOR2Mutator]MSP[S] } long seconds = baseTime / 1000 ;
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR6Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR3Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[rv.ROR4Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR3Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.ROR1Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI1Mutator]MSP[N] }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR1Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR1Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.ABSMutator]MSP[S] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.CRCR6Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.ROR4Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
{ if ( utcFormatter == null ) { utcFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT + lr_2 , MST[NonVoidMethodCallMutator]MSP[N] Locale . US ) ; utcFormatter . setTimeZone ( TimeZone . getTimeZone ( lr_3 ) ) ; } final Date ntpDate = getDate () ; return utcFormatter . format ( ntpDate ) ;
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.CRCR6Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.UOI2Mutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR5Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.ABSMutator]MSP[N] return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.UOI1Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
public Date getDate () MST[NonVoidMethodCallMutator]MSP[N] { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR6Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR2Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI3Mutator]MSP[N] return time ; } @Override public int hashCode () {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[NonVoidMethodCallMutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[InlineConstantMutator]MSP[N] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI2Mutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR2Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR4Mutator]MSP[N] }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[rv.ROR1Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.CRCR1Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[NegateConditionalsMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR4Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR6Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[rv.UOI4Mutator]MSP[N] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR6Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOD2Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.CRCR4Mutator]MSP[S] } long seconds = baseTime / 1000 ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.ROR4Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI4Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI2Mutator]MSP[S] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.AOD2Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR1Mutator]MSP[N] }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI2Mutator]MSP[S]
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { MST[rv.CRCR1Mutator]MSP[N] return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 |
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[rv.ABSMutator]MSP[N] { return getTime ( ntpTime ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR4Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD1Mutator]MSP[N] }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR1Mutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR1Mutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR6Mutator]MSP[N] {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR1Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR6Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR4Mutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[rv.UOI3Mutator]MSP[N] { final String s = Long . toHexString ( l ) ;
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI3Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR3Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[InlineConstantMutator]MSP[S] {
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.UOI3Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString ()
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR5Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR6Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI4Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.OBBN2Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR2Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final StringBuilder buf = new StringBuilder () ; MST[InlineConstantMutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[InlineConstantMutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.UOI3Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[NegateConditionalsMutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR1Mutator]MSP[N] }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.CRCR4Mutator]MSP[N] return time ; } @Override public int hashCode () {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR5Mutator]MSP[N] {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.OBBN1Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.AOR4Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR2Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.CRCR3Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[experimental.NakedReceiverMutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR5Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.OBBN2Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR4Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[InlineConstantMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[InlineConstantMutator]MSP[N]
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[NonVoidMethodCallMutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR1Mutator]MSP[N] }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.ABSMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[BooleanTrueReturnValsMutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.UOI3Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[NonVoidMethodCallMutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR4Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.CRCR6Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.ROR5Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.UOI1Mutator]MSP[S] } long seconds = baseTime / 1000 ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.ROR4Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.ROR3Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
protected static long decodeNtpHexString ( final String hexString ) MST[ReturnValsMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR6Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR4Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD1Mutator]MSP[N]
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[EmptyObjectReturnValsMutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.ABSMutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI1Mutator]MSP[N] }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[ConditionalsBoundaryMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.UOI1Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR5Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
public Date getDate () MST[ArgumentPropagationMutator]MSP[N] { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[experimental.MemberVariableMutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR1Mutator]MSP[N] }
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[experimental.NakedReceiverMutator]MSP[N] { final String s = Long . toHexString ( l ) ;
final StringBuilder buf = new StringBuilder () ; MST[InlineConstantMutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.CRCR2Mutator]MSP[N] {
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR3Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.CRCR3Mutator]MSP[N] return time ; } @Override public int hashCode () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI3Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR4Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; MST[NullReturnValsMutator]MSP[N] }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.UOI3Mutator]MSP[N] if ( ind == - 1 ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR6Mutator]MSP[N] }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR5Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[rv.OBBN3Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI3Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[rv.UOI1Mutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.CRCR2Mutator]MSP[N]
public Date getDate () MST[rv.UOI3Mutator]MSP[N] { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR5Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[InlineConstantMutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.OBBN2Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR5Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.ROR1Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR6Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI1Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR2Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR5Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR4Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR3Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[ReturnValsMutator]MSP[N] return time ; } @Override public int hashCode () {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR5Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD2Mutator]MSP[N] }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.CRCR1Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR5Mutator]MSP[N] {
final StringBuilder buf = new StringBuilder () ; MST[VoidMethodCallMutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR3Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.UOI1Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR6Mutator]MSP[N]
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[rv.ROR5Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR2Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR2Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD1Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR5Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR1Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR6Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[experimental.NakedReceiverMutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI2Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[MathMutator]MSP[N] return time ; } @Override public int hashCode () {
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[rv.CRCR2Mutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[MathMutator]MSP[N] }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI1Mutator]MSP[S] {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.CRCR1Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOD1Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR4Mutator]MSP[N] }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR1Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[rv.UOI4Mutator]MSP[N] { return getTime ( ntpTime ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI1Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI1Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) MST[ReturnValsMutator]MSP[N] throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.UOI4Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR2Mutator]MSP[N] }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[ReturnValsMutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[MathMutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI1Mutator]MSP[N] return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR3Mutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR4Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR4Mutator]MSP[N] {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ABSMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR3Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.CRCR4Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[rv.ABSMutator]MSP[N] { final String s = Long . toHexString ( l ) ;
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[MathMutator]MSP[N] return time ; } @Override public int hashCode () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI4Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[MathMutator]MSP[N]
public long ntpValue () MST[ReturnValsMutator]MSP[N] { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.ROR2Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI2Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR4Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.UOI4Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR6Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI4Mutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.CRCR4Mutator]MSP[N] if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { MST[InlineConstantMutator]MSP[N] return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 |
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD2Mutator]MSP[N] }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.UOI1Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.CRCR5Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
protected static long decodeNtpHexString ( final String hexString ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR3Mutator]MSP[N] }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.ROR5Mutator]MSP[N] {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[InlineConstantMutator]MSP[S] {
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[ReturnValsMutator]MSP[N] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR6Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.UOI2Mutator]MSP[S] } long seconds = baseTime / 1000 ;
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.UOI2Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.AOR3Mutator]MSP[S] } long seconds = baseTime / 1000 ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR2Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR2Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR1Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR1Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public Date getDate () MST[rv.UOI4Mutator]MSP[N] { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.CRCR3Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[ReturnValsMutator]MSP[N] { return getTime ( ntpTime ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI1Mutator]MSP[S] {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR1Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.UOI4Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR4Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOD1Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[InlineConstantMutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.ROR2Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.ABSMutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
if ( simpleFormatter == null ) { MST[NonVoidMethodCallMutator]MSP[N] simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString ()
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[MathMutator]MSP[N] }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR2Mutator]MSP[N] }
final StringBuilder buf = new StringBuilder () ; MST[rv.UOI2Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.OBBN1Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR3Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR4Mutator]MSP[N] }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.OBBN2Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.AOR2Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[ReturnValsMutator]MSP[N] {
final StringBuilder buf = new StringBuilder () ; MST[rv.OBBN2Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[VoidMethodCallMutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI4Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.ROR2Mutator]MSP[N] if ( ind == - 1 ) {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR6Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR4Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.UOI1Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR6Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR1Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR1Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.CRCR1Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR5Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[experimental.NakedReceiverMutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD1Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[rv.UOI3Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR5Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.CRCR6Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR6Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[NegateConditionalsMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[InlineConstantMutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[NonVoidMethodCallMutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI3Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR3Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR5Mutator]MSP[S] {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.ABSMutator]MSP[S] {
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.UOI1Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR3Mutator]MSP[S] {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[ReturnValsMutator]MSP[N] {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI1Mutator]MSP[S]
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[ConstructorCallMutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI4Mutator]MSP[N] return time ; } @Override public int hashCode () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI1Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
{ if ( utcFormatter == null ) { utcFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT + lr_2 , Locale . US ) ; utcFormatter . setTimeZone ( TimeZone . getTimeZone ( lr_3 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Date ntpDate = getDate () ; return utcFormatter . format ( ntpDate ) ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR6Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR4Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final StringBuilder buf = new StringBuilder () ; MST[rv.UOI4Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.UOI4Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR6Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[ReturnValsMutator]MSP[N] }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[MathMutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[InlineConstantMutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[InlineConstantMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; MST[ReturnValsMutator]MSP[N] return buf . toString () ; } public String toDateString () {
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[MathMutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI4Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR4Mutator]MSP[N] }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI1Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR3Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.OBBN2Mutator]MSP[N] return time ; } @Override public int hashCode () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI4Mutator]MSP[N] }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.CRCR6Mutator]MSP[S] } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR4Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.ROR4Mutator]MSP[N] if ( ind == - 1 ) {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[NonVoidMethodCallMutator]MSP[N] { final String s = Long . toHexString ( l ) ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[MathMutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR4Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[rv.UOI2Mutator]MSP[N] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI3Mutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[NegateConditionalsMutator]MSP[N] {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR3Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[NonVoidMethodCallMutator]MSP[N] {
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.UOI4Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[InlineConstantMutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[InlineConstantMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[MathMutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.ROR3Mutator]MSP[N] {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.CRCR3Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD1Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.ABSMutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR4Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[ReturnValsMutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR2Mutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[InlineConstantMutator]MSP[N] {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.ROR2Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.UOI4Mutator]MSP[S] } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.ROR1Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR3Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[ReturnValsMutator]MSP[S]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI3Mutator]MSP[S] {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR5Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR5Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR2Mutator]MSP[N] }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[BooleanTrueReturnValsMutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.CRCR5Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[EmptyObjectReturnValsMutator]MSP[N] {
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR2Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.UOI3Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR1Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.CRCR5Mutator]MSP[S] {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR6Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[MathMutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.ABSMutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR3Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.CRCR6Mutator]MSP[N] return time ; } @Override public int hashCode () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[InlineConstantMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR2Mutator]MSP[N] {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[MathMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.ROR4Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[InlineConstantMutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.AOD1Mutator]MSP[S] } long seconds = baseTime / 1000 ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR1Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.UOI1Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[rv.UOI4Mutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[NegateConditionalsMutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI2Mutator]MSP[N] }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[rv.ROR5Mutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[MathMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[experimental.MemberVariableMutator]MSP[N] {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.CRCR4Mutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[NullReturnValsMutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
if ( hexString . length () == 0 ) { MST[rv.CRCR5Mutator]MSP[N] return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 |
public long ntpValue () MST[rv.ABSMutator]MSP[N] { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.CRCR2Mutator]MSP[N] if ( ind == - 1 ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR1Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ind == - 1 ) {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR1Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[ReturnValsMutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR6Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[NonVoidMethodCallMutator]MSP[N] { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { MST[ConstructorCallMutator]MSP[N] throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[rv.ABSMutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[ConditionalsBoundaryMutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[MathMutator]MSP[S] {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR3Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR5Mutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[rv.UOI4Mutator]MSP[N] { final String s = Long . toHexString ( l ) ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[NonVoidMethodCallMutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[MathMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.CRCR5Mutator]MSP[S] } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR5Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR4Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR3Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI3Mutator]MSP[S] {
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.ABSMutator]MSP[N] if ( ind == - 1 ) {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.CRCR3Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[rv.UOI3Mutator]MSP[N] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR1Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR2Mutator]MSP[N] }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[PrimitiveReturnsMutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR4Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.CRCR3Mutator]MSP[S] {
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR2Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.OBBN3Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[InlineConstantMutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final StringBuilder buf = new StringBuilder () ; MST[rv.UOI1Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR1Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.UOI1Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.CRCR5Mutator]MSP[N] return time ; } @Override public int hashCode () {
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[InlineConstantMutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.AOR3Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.ROR2Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR1Mutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[rv.UOI2Mutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI2Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; MST[EmptyObjectReturnValsMutator]MSP[N] return buf . toString () ; } public String toDateString () {
protected static long decodeNtpHexString ( final String hexString ) MST[ArgumentPropagationMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ABSMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
protected static long decodeNtpHexString ( final String hexString ) MST[InlineConstantMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR6Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR4Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[InlineConstantMutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR1Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.ROR4Mutator]MSP[N] {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.UOI4Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.ABSMutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
protected static long decodeNtpHexString ( final String hexString ) MST[NonVoidMethodCallMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR3Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.UOI1Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.UOI4Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.ROR3Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR1Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR3Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[rv.ROR5Mutator]MSP[N] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD2Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR4Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.CRCR1Mutator]MSP[N]
public Date getDate () MST[rv.UOI2Mutator]MSP[N] { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[NegateConditionalsMutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR6Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[InlineConstantMutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.OBBN1Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR1Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR1Mutator]MSP[N] }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) MST[NonVoidMethodCallMutator]MSP[N] throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) {
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[InlineConstantMutator]MSP[N] if ( ind == - 1 ) {
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI1Mutator]MSP[N] return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR4Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.UOI2Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR4Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[InlineConstantMutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.ROR5Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.CRCR2Mutator]MSP[N] return time ; } @Override public int hashCode () {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR6Mutator]MSP[N] {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR3Mutator]MSP[N] {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.OBBN2Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.UOI2Mutator]MSP[N] if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.AOD2Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI2Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR5Mutator]MSP[N] }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR6Mutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) MST[PrimitiveReturnsMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[NullReturnValsMutator]MSP[N] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.CRCR3Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.OBBN3Mutator]MSP[N] return time ; } @Override public int hashCode () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI2Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[NegateConditionalsMutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI2Mutator]MSP[N] }
protected static long decodeNtpHexString ( final String hexString ) MST[InlineConstantMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI4Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.ABSMutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.AOR2Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR6Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR4Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR2Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[MathMutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.UOI2Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.UOI2Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[MathMutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.CRCR6Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.ABSMutator]MSP[N] return time ; } @Override public int hashCode () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR3Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[rv.UOI1Mutator]MSP[N] { return getTime ( ntpTime ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR3Mutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.ROR3Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[rv.UOI1Mutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.CRCR6Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD2Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.UOI4Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR3Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR2Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.UOI2Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI3Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[rv.UOI1Mutator]MSP[N] { final String s = Long . toHexString ( l ) ;
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI1Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR1Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR1Mutator]MSP[S] {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[InlineConstantMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI3Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI2Mutator]MSP[N] return time ; } @Override public int hashCode () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR4Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ind == - 1 ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR4Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public long ntpValue () MST[rv.UOI2Mutator]MSP[N] { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR6Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD1Mutator]MSP[N] }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI4Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.OBBN2Mutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR5Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR4Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI3Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.ABSMutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR5Mutator]MSP[N] }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.CRCR5Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR4Mutator]MSP[S]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[InlineConstantMutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[rv.ROR3Mutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.AOR4Mutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR2Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.OBBN2Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.CRCR2Mutator]MSP[S] } long seconds = baseTime / 1000 ;
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[ConstructorCallMutator]MSP[N] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[MathMutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[rv.UOI3Mutator]MSP[N] { return getTime ( ntpTime ) ; }
if ( hexString . length () == 0 ) { MST[rv.CRCR3Mutator]MSP[N] return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 |
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI4Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[MathMutator]MSP[S] } long seconds = baseTime / 1000 ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR5Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.ROR1Mutator]MSP[N] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.AOR1Mutator]MSP[S] } long seconds = baseTime / 1000 ;
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.ABSMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.OBBN2Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () MST[rv.ABSMutator]MSP[N] { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.ABSMutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR3Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR5Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR3Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR2Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.CRCR1Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR1Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.ROR4Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[PrimitiveReturnsMutator]MSP[N] { return getTime ( ntpTime ) ; }
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR3Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
protected static long decodeNtpHexString ( final String hexString ) MST[NonVoidMethodCallMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.ABSMutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR3Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.UOI2Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.OBBN3Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.ROR5Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.AOD1Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI3Mutator]MSP[N] return time ; } @Override public int hashCode () {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[ReturnValsMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR1Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.ABSMutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[InlineConstantMutator]MSP[S] } long seconds = baseTime / 1000 ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR3Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.UOI2Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD2Mutator]MSP[N] }
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR5Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR1Mutator]MSP[N]
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[InlineConstantMutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI4Mutator]MSP[N] return time ; } @Override public int hashCode () {
protected static long decodeNtpHexString ( final String hexString ) MST[InlineConstantMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[PrimitiveReturnsMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[NegateConditionalsMutator]MSP[N] {
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[ConstructorCallMutator]MSP[S] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } public String toDateString () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[InlineConstantMutator]MSP[N] return time ; } @Override public int hashCode () {
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.CRCR2Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[rv.ROR2Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[MathMutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[InlineConstantMutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.UOI3Mutator]MSP[N] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[MathMutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR2Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI3Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.CRCR5Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
protected static long decodeNtpHexString ( final String hexString ) MST[rv.ROR5Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
public long ntpValue () MST[rv.UOI1Mutator]MSP[N] { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
{ if ( utcFormatter == null ) { utcFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT + lr_2 , MST[VoidMethodCallMutator]MSP[N] Locale . US ) ; utcFormatter . setTimeZone ( TimeZone . getTimeZone ( lr_3 ) ) ; } final Date ntpDate = getDate () ; return utcFormatter . format ( ntpDate ) ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR6Mutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[NonVoidMethodCallMutator]MSP[N] { final String s = Long . toHexString ( l ) ;
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR4Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[NonVoidMethodCallMutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD2Mutator]MSP[N]
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.ROR2Mutator]MSP[N]
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[rv.UOI4Mutator]MSP[N]
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.CRCR5Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) MST[rv.UOI2Mutator]MSP[N] { final String s = Long . toHexString ( l ) ;
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.CRCR5Mutator]MSP[N]
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI4Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR3Mutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ABSMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR3Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.ROR1Mutator]MSP[N] if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.AOR1Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR5Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.ROR5Mutator]MSP[N] if ( ind == - 1 ) {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.CRCR3Mutator]MSP[S] } long seconds = baseTime / 1000 ;
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.OBBN3Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.ABSMutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR3Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[rv.UOI1Mutator]MSP[N] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.UOI2Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[PrimitiveReturnsMutator]MSP[N] {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.UOI4Mutator]MSP[N] {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[MathMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR2Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR3Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR2Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[NegateConditionalsMutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR3Mutator]MSP[N] }
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.UOI3Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI4Mutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.UOI4Mutator]MSP[N] if ( ind == - 1 ) {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR6Mutator]MSP[N] }
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
final StringBuilder buf = new StringBuilder () ; MST[MathMutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final StringBuilder buf = new StringBuilder () ; MST[rv.OBBN1Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.ABSMutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.OBBN1Mutator]MSP[N] return time ; } @Override public int hashCode () {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR4Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.CRCR6Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[MathMutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[NonVoidMethodCallMutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI2Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.CRCR4Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[InlineConstantMutator]MSP[N] }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR2Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[InlineConstantMutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[NegateConditionalsMutator]MSP[N] if ( ind == - 1 ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.ROR1Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
public long ntpValue () MST[PrimitiveReturnsMutator]MSP[N] { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR6Mutator]MSP[S] {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.ABSMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.ROR5Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR6Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.ROR2Mutator]MSP[N] {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.ROR5Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.CRCR2Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.UOI1Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.UOI2Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[PrimitiveReturnsMutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOD2Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[MathMutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR4Mutator]MSP[N] }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOD1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR1Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.OBBN1Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR5Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[InlineConstantMutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final boolean useBase1 = t < msb0baseTime ; long baseTime ; MST[rv.ROR1Mutator]MSP[N] if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR3Mutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.ROR2Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.UOI3Mutator]MSP[S] } long seconds = baseTime / 1000 ;
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[ReturnValsMutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR4Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR2Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.OBBN1Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI3Mutator]MSP[N] }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[PrimitiveReturnsMutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[NegateConditionalsMutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[ReturnValsMutator]MSP[N]
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.OBBN3Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () MST[ArgumentPropagationMutator]MSP[N] { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI1Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.ABSMutator]MSP[N] }
if ( hexString . length () == 0 ) { MST[rv.CRCR6Mutator]MSP[N] return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 |
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR3Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[PrimitiveReturnsMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.CRCR4Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR1Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
protected static long decodeNtpHexString ( final String hexString ) MST[NegateConditionalsMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR2Mutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.CRCR1Mutator]MSP[S] {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.CRCR6Mutator]MSP[S] {
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR3Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI2Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[ReturnValsMutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.AOD2Mutator]MSP[S] } long seconds = baseTime / 1000 ;
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI4Mutator]MSP[S] {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI1Mutator]MSP[S] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR5Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[PrimitiveReturnsMutator]MSP[N] return time ; } @Override public int hashCode () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.ROR4Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[InlineConstantMutator]MSP[N]
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[NonVoidMethodCallMutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[InlineConstantMutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR4Mutator]MSP[N] {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI3Mutator]MSP[N] return time ; } @Override public int hashCode () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI4Mutator]MSP[N] return time ; } @Override public int hashCode () {
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.OBBN1Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI3Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR3Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR6Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.ROR5Mutator]MSP[N]
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[ArgumentPropagationMutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR6Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR5Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR2Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
if ( simpleFormatter == null ) { simpleFormatter = new SimpleDateFormat ( NTP_DATE_FORMAT , Locale . US ) ; simpleFormatter . setTimeZone ( TimeZone . getDefault () ) ; } final Date ntpDate = getDate () ; return simpleFormatter . format ( ntpDate ) ; } public String toUTCString () MST[ConstructorCallMutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR3Mutator]MSP[N]
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) MST[NullReturnValsMutator]MSP[N] throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[InlineConstantMutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI1Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR1Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[NegateConditionalsMutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[InlineConstantMutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR4Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.CRCR5Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI1Mutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[ReturnValsMutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.CRCR1Mutator]MSP[N] if ( ind == - 1 ) {
final StringBuilder buf = new StringBuilder () ; MST[rv.ABSMutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.CRCR2Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.CRCR2Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public long ntpValue () MST[rv.UOI4Mutator]MSP[N] { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ; MST[rv.UOI4Mutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR1Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.CRCR4Mutator]MSP[S] {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR4Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR2Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; MST[rv.ABSMutator]MSP[N] return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR3Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
if ( hexString . length () == 0 ) { MST[ReturnValsMutator]MSP[N] return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 |
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.UOI2Mutator]MSP[N] return time ; } @Override public int hashCode () {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[rv.CRCR1Mutator]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[rv.ROR3Mutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; MST[rv.UOI1Mutator]MSP[N] if ( ind == - 1 ) {
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[rv.UOI3Mutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
protected static long decodeNtpHexString ( final String hexString ) MST[rv.CRCR6Mutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.ABSMutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
} @Override public int compareTo ( final TimeStamp anotherTimeStamp ) { final long thisVal = this . ntpTime ; MST[rv.UOI3Mutator]MSP[N] final long anotherVal = anotherTimeStamp . ntpTime ; return ( thisVal < anotherVal ? - 1 : ( thisVal == anotherVal ? 0 : 1 ) ) ; }
for ( int i = s . length () ; i < 8 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] buf . append ( '0' ) ; } buf . append ( s ) ; } public static String toString ( final long ntpTime ) {
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () MST[rv.UOI4Mutator]MSP[S] {
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR1Mutator]MSP[N] {
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.CRCR2Mutator]MSP[N] {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR3Mutator]MSP[N] }
Long . parseLong ( hexString . substring ( ind + 1 ) , 16 ) ; } public static TimeStamp parseNtpString ( final String s ) throws NumberFormatException { return new TimeStamp ( decodeNtpHexString ( s ) ) ; } protected static long toNtpTime ( final long t ) MST[rv.UOI1Mutator]MSP[N] {
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[NonVoidMethodCallMutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[MathMutator]MSP[N] }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[MathMutator]MSP[N]
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; MST[rv.ABSMutator]MSP[N] return time ; } @Override public int hashCode () {
protected static long decodeNtpHexString ( final String hexString ) MST[MathMutator]MSP[N] throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.CRCR4Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
public String toString () { return toString ( ntpTime ) ; } private static void appendHexString ( final StringBuilder buf , final long l ) { final String s = Long . toHexString ( l ) ; MST[rv.UOI3Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.UOI3Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.CRCR5Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.AOR4Mutator]MSP[S] } long seconds = baseTime / 1000 ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; MST[rv.AOR1Mutator]MSP[N] final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.ABSMutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.CRCR2Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.CRCR2Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.UOI3Mutator]MSP[N] }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; MST[rv.ROR3Mutator]MSP[N] if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.UOI3Mutator]MSP[N]
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR5Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return msb1baseTime + ( seconds * 1000 ) + fraction ; } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; MST[ReturnValsMutator]MSP[N] } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final StringBuilder buf = new StringBuilder () ; MST[rv.CRCR5Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.ABSMutator]MSP[N] }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.ABSMutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.UOI3Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
return msb1baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR1Mutator]MSP[N] } public static TimeStamp getNtpTime ( final long date ) { return new TimeStamp ( toNtpTime ( date ) ) ; } public static TimeStamp getCurrentTime () { return getNtpTime ( System . currentTimeMillis () ) ; }
final StringBuilder buf = new StringBuilder () ; MST[rv.UOI3Mutator]MSP[N] appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ; MST[rv.AOR4Mutator]MSP[N]
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.CRCR3Mutator]MSP[N] }
public long ntpValue () { return ntpTime ; } public long getSeconds () MST[rv.OBBN3Mutator]MSP[N] { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { MST[InlineConstantMutator]MSP[N] return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.UOI3Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[rv.CRCR2Mutator]MSP[N]
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { MST[rv.AOR1Mutator]MSP[N] baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; } long seconds = baseTime / 1000 ;
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.OBBN3Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
return (int) ( ntpTime ^ ( ntpTime >>> 32 ) ) ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof TimeStamp ) { return ntpTime == ( ( TimeStamp ) obj ) . ntpValue () ; } return false ; } @Override MST[EmptyObjectReturnValsMutator]MSP[N]
protected static long decodeNtpHexString ( final String hexString ) throws NumberFormatException { if ( hexString == null ) { throw new NumberFormatException ( lr_1 ) ; } final int ind = hexString . indexOf ( '.' ) ; if ( ind == - 1 ) { MST[NonVoidMethodCallMutator]MSP[N]
public long ntpValue () { return ntpTime ; } public long getSeconds () { return ( ntpTime >>> 32 ) & 0xffffffffL ; } public long getFraction () MST[rv.CRCR5Mutator]MSP[N] { return ntpTime & 0xffffffffL ; } public long getTime () { return getTime ( ntpTime ) ; }
final boolean useBase1 = t < msb0baseTime ; long baseTime ; if ( useBase1 ) { baseTime = t - msb1baseTime ; } else { baseTime = t - msb0baseTime ; MST[rv.ABSMutator]MSP[S] } long seconds = baseTime / 1000 ;
public Date getDate () { final long time = getTime ( ntpTime ) ; return new Date ( time ) ; } public static long getTime ( final long ntpTimeValue ) MST[rv.CRCR2Mutator]MSP[N] { final long seconds = ( ntpTimeValue >>> 32 ) & 0xffffffffL ;
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[InlineConstantMutator]MSP[N] }
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.ROR3Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR2Mutator]MSP[N] }
long fraction = ntpTimeValue & 0xffffffffL ; fraction = Math . round ( 1000D * fraction / 0x100000000L ) ; final long msb = seconds & 0x80000000L ; if ( msb == 0 ) { return msb0baseTime + ( seconds * 1000 ) + fraction ; MST[rv.AOR3Mutator]MSP[N] }
if ( hexString . length () == 0 ) { return 0 ; } return Long . parseLong ( hexString , 16 ) << 32 ; } return Long . parseLong ( hexString . substring ( 0 , ind ) , 16 ) << 32 | MST[NonVoidMethodCallMutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; appendHexString ( buf , ( ntpTime >>> 32 ) & 0xffffffffL ) ; buf . append ( '.' ) ; MST[rv.CRCR2Mutator]MSP[N] appendHexString ( buf , ntpTime & 0xffffffffL ) ; return buf . toString () ; } public String toDateString () {
final long fraction = ( ( baseTime % 1000 ) * 0x100000000L ) / 1000 ; if ( useBase1 ) { MST[rv.UOI2Mutator]MSP[N] seconds |= 0x80000000L ; } final long time = seconds << 32 | fraction ; return time ; } @Override public int hashCode () {
