System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI2Mutator]MSP[N] {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI1Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
final synchronized void requestDo ( final int option ) MST[rv.ROR4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR1Mutator]MSP[N] {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; MST[rv.UOI3Mutator]MSP[N] } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[NonVoidMethodCallMutator]MSP[N] protected void _connectAction_ () throws IOException {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[VoidMethodCallMutator]MSP[S] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.UOI2Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } MST[rv.UOI1Mutator]MSP[S] final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI1Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI3Mutator]MSP[N] { switch ( option ) { default:
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.ABSMutator]MSP[S] { -- doResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.ABSMutator]MSP[N] {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI1Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( option == TERMINAL_TYPE ) MST[rv.UOI4Mutator]MSP[N] { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException {
setWantDont ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.UOI1Mutator]MSP[N] { default: break; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR2Mutator]MSP[S] throws IOException {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI4Mutator]MSP[N] { -- doResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR1Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.UOI4Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.CRCR3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.ABSMutator]MSP[N] if ( optionHandlers [ option ] != null ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; MST[rv.UOI1Mutator]MSP[N] } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.CRCR3Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI1Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.ABSMutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR2Mutator]MSP[N] }
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; MST[rv.CRCR5Mutator]MSP[S] if ( aytFlag == false ) { retValue = false ;
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.ABSMutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[rv.ROR1Mutator]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.UOI2Mutator]MSP[S] if ( optionHandlers [ option ] != null ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; } MST[rv.UOI3Mutator]MSP[N]
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.UOI2Mutator]MSP[N] {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.AOR1Mutator]MSP[N]
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.AOR1Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI4Mutator]MSP[N] } if ( acceptNewState )
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.ROR5Mutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_14 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WONT ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.ABSMutator]MSP[N]
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ABSMutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.CRCR6Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
final synchronized void processAYTResponse () MST[rv.CRCR5Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
final synchronized void requestWont ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.CRCR3Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[rv.ROR2Mutator]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.AOD2Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
if ( debug || debugoptions ) { System . err . println ( lr_11 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DO ) ; _output_ . write ( option ) ; _output_ . flush () ; MST[VoidMethodCallMutator]MSP[S] }
final synchronized void requestWont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.UOI3Mutator]MSP[N] {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ROR3Mutator]MSP[N] protected void _connectAction_ () throws IOException {
final synchronized void requestDo ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.ROR1Mutator]MSP[N] -- willResponse [ option ] ; } }
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.ROR4Mutator]MSP[N] -- willResponse [ option ] ; } }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[NonVoidMethodCallMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ABSMutator]MSP[N] }
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[rv.ROR4Mutator]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[rv.UOI3Mutator]MSP[N] {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { MST[rv.UOI3Mutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.CRCR5Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[NegateConditionalsMutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
if ( subneg != null ) MST[VoidMethodCallMutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[rv.UOI3Mutator]MSP[N] default: break; }
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI1Mutator]MSP[S] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
final synchronized void processAYTResponse () MST[rv.CRCR2Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
boolean stateIsWill ( final int option ) MST[rv.CRCR2Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
optionHandlers [ option ] . setWill ( true ) ; MST[rv.ROR2Mutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_14 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WONT ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI2Mutator]MSP[N]
spy . write ( ch ) ; spy . flush () ; } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) MST[VoidMethodCallMutator]MSP[S] { if ( ! ( stateIsDo ( TelnetOption . ECHO )
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
final synchronized void requestWont ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
} if ( opthand . getDo () ) { MST[rv.ROR2Mutator]MSP[N] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { MST[rv.ROR3Mutator]MSP[N] default:
final synchronized void requestDo ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.AOD2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { MST[rv.UOI1Mutator]MSP[N] _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else MST[rv.UOI1Mutator]MSP[N] { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; MST[rv.UOI2Mutator]MSP[N] }
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.UOI2Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else MST[rv.UOI4Mutator]MSP[N] { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; MST[VoidMethodCallMutator]MSP[S] } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.ABSMutator]MSP[N] {
final synchronized void requestWont ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } MST[rv.CRCR6Mutator]MSP[S] if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.UOI4Mutator]MSP[N] { default: break; }
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI2Mutator]MSP[N] { -- doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] {
final synchronized void requestDo ( final int option ) MST[rv.ROR1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[rv.UOI2Mutator]MSP[S] optionHandlers [ option ] . startSubnegotiationRemote () ;
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.CRCR2Mutator]MSP[S] {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] protected void _connectAction_ () throws IOException {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[NonVoidMethodCallMutator]MSP[S] throws IOException {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.ROR5Mutator]MSP[S] throws IOException { if ( debug ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } MST[rv.UOI3Mutator]MSP[N] final synchronized void sendDo ( final int option ) throws IOException {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException {
final synchronized void requestDo ( final int option ) MST[rv.ROR1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.CRCR1Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
} if ( opthand . getDo () ) MST[rv.UOI2Mutator]MSP[S] { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } MST[rv.UOI4Mutator]MSP[S] final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI4Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[NonVoidMethodCallMutator]MSP[S] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.ROR3Mutator]MSP[S] {
if ( subneg != null ) MST[InlineConstantMutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI4Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI1Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI1Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[rv.UOI2Mutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[rv.CRCR5Mutator]MSP[N]
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI2Mutator]MSP[S] } _output_ . write ( b ) ; }
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) throws IOException { if ( debug ) {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.CRCR5Mutator]MSP[S] {
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[rv.UOI3Mutator]MSP[S] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
for ( final int element : subn ) MST[NegateConditionalsMutator]MSP[N] { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI1Mutator]MSP[S] throws IOException {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.ROR4Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.ROR1Mutator]MSP[N] { default: break; }
optionHandlers [ option ] . setWill ( true ) ; MST[rv.ROR5Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
boolean stateIsWill ( final int option ) MST[InlineConstantMutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
} if ( opthand . getDo () ) { MST[rv.ROR5Mutator]MSP[S] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
setWont ( option ) ; MST[rv.ABSMutator]MSP[N] } void processWill ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.ABSMutator]MSP[S] } _output_ . write ( b ) ; }
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.ROR2Mutator]MSP[S]
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR6Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI3Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[rv.UOI3Mutator]MSP[N]
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throws IOException {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI4Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR2Mutator]MSP[N] }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR1Mutator]MSP[S] throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR4Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[NegateConditionalsMutator]MSP[S] throws IOException { if ( debug ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[rv.UOI3Mutator]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.OBBN2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI4Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] protected void _connectAction_ () throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI4Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.UOI1Mutator]MSP[N]
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[rv.ABSMutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( option == TERMINAL_TYPE ) MST[rv.UOI1Mutator]MSP[N] { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) {
aytFlag = true ; MST[rv.UOI1Mutator]MSP[N] } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
boolean stateIsWill ( final int option ) MST[rv.CRCR5Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR6Mutator]MSP[S] throws IOException {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default: break; } if ( acceptNewState )
for ( final int element : subn ) MST[rv.ROR5Mutator]MSP[N] { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; }
optionHandlers [ option ] . setWill ( true ) ; MST[rv.ABSMutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ABSMutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[rv.ROR5Mutator]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
final synchronized void requestWont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
final synchronized void requestDo ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; MST[rv.UOI2Mutator]MSP[N] } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.CRCR6Mutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { MST[rv.UOI1Mutator]MSP[N] switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ABSMutator]MSP[N] }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR6Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.AOR1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR1Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR1Mutator]MSP[N] throws IOException {
optionHandlers [ ii ] . setDo ( false ) ; MST[rv.UOI1Mutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI3Mutator]MSP[N] -- willResponse [ option ] ; } }
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.UOI2Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI2Mutator]MSP[N]
} if ( willResponse [ option ] > 0 ) MST[rv.CRCR6Mutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[BooleanTrueReturnValsMutator]MSP[S] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { MST[rv.UOI4Mutator]MSP[N] requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI2Mutator]MSP[N] throws IOException {
aytFlag = true ; } else { MST[rv.CRCR6Mutator]MSP[S] retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.UOI1Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.OBBN1Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI1Mutator]MSP[N] { switch ( option ) { default:
final synchronized void requestWont ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( subneg != null ) { MST[rv.UOI3Mutator]MSP[S] _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
final synchronized void requestWont ( final int option ) MST[VoidMethodCallMutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } MST[rv.UOI2Mutator]MSP[N] setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.CRCR3Mutator]MSP[N]
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[rv.ABSMutator]MSP[S] optionHandlers [ option ] . startSubnegotiationRemote () ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( optionHandlers [ ii ] != null ) {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.ROR4Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; MST[rv.UOI4Mutator]MSP[N] } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
boolean stateIsWill ( final int option ) MST[rv.CRCR3Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; MST[rv.ABSMutator]MSP[N] } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.ABSMutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[ReturnValsMutator]MSP[S] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[MathMutator]MSP[N] { switch ( option ) { default:
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.CRCR3Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[InlineConstantMutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.AOR1Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI4Mutator]MSP[S] throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.CRCR3Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[rv.ROR3Mutator]MSP[S] ++ doResponse [ option ] ;
System . err . println ( lr_7 + ii + lr_8 + suboption [ ii ] ) ; } } if ( suboption [ 0 ] == TERMINAL_TYPE && suboption [ 1 ] == TERMINAL_TYPE_SEND ) { sendTerminalType () ; } } } } } final synchronized void sendTerminalType () MST[VoidMethodCallMutator]MSP[S]
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[InlineConstantMutator]MSP[N] {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[InlineConstantMutator]MSP[N]
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.UOI1Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[InlineConstantMutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
aytFlag = true ; } else { retValue = true ; } } return retValue ; MST[rv.CRCR4Mutator]MSP[N] } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
aytFlag = true ; } else { retValue = true ; MST[rv.CRCR2Mutator]MSP[N] } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void requestWont ( final int option ) MST[NegateConditionalsMutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { MST[rv.UOI4Mutator]MSP[S] ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
final synchronized void requestDo ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.ABSMutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) MST[rv.CRCR3Mutator]MSP[N] { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.AOR4Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; MST[rv.UOI4Mutator]MSP[S] } } final synchronized void _sendCommand ( final byte cmd ) throws IOException { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
void processDont ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_3 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DONT , option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } MST[rv.ABSMutator]MSP[N] setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
TelnetNotificationHandler . RECEIVED_WILL , option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
setWantDont ( option ) ; MST[rv.ROR3Mutator]MSP[S] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI4Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.ROR2Mutator]MSP[S] throws IOException { if ( debug ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI4Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[rv.ROR3Mutator]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
} void spyRead ( final int ch ) MST[experimental.MemberVariableMutator]MSP[S] { final OutputStream spy = spyStream ; if ( spy != null ) { try { if ( ch != '\r' ) { if ( ch == '\n' ) { spy . write ( '\r' ) ; }
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; MST[rv.UOI3Mutator]MSP[N] } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR5Mutator]MSP[N] }
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.UOI3Mutator]MSP[N] protected void _connectAction_ () throws IOException {
_output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI3Mutator]MSP[N] final synchronized void requestDont ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI1Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.UOI4Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException {
throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_14 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WONT ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[VoidMethodCallMutator]MSP[N]
break; MST[rv.ABSMutator]MSP[N] } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; if ( aytFlag == false ) MST[VoidMethodCallMutator]MSP[S] { retValue = false ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.AOD2Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR5Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.ABSMutator]MSP[S] } _output_ . write ( b ) ; }
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[NegateConditionalsMutator]MSP[N] optionHandlers [ option ] . startSubnegotiationRemote () ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.ABSMutator]MSP[S] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; MST[rv.UOI1Mutator]MSP[S] sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[ConditionalsBoundaryMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { MST[rv.CRCR1Mutator]MSP[N] acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.UOI2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR1Mutator]MSP[N] throws IOException {
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.UOI1Mutator]MSP[N] {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.UOI4Mutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
System . err . println ( lr_7 + ii + lr_8 + suboption [ ii ] ) ; } } if ( suboption [ 0 ] == TERMINAL_TYPE && suboption [ 1 ] == TERMINAL_TYPE_SEND ) { sendTerminalType () ; } } } } } final synchronized void sendTerminalType () MST[NonVoidMethodCallMutator]MSP[S]
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.CRCR5Mutator]MSP[S] {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.ROR3Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { MST[experimental.MemberVariableMutator]MSP[N] if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR3Mutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.ROR4Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; MST[rv.ABSMutator]MSP[N] sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.CRCR2Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default: break; } if ( acceptNewState )
boolean stateIsWill ( final int option ) MST[experimental.MemberVariableMutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { MST[rv.UOI2Mutator]MSP[N] requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.ROR1Mutator]MSP[N] default: break; } if ( acceptNewState )
final synchronized void requestDo ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
boolean stateIsWill ( final int option ) MST[experimental.MemberVariableMutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.ROR1Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.CRCR6Mutator]MSP[N] {
setWantDont ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR1Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI4Mutator]MSP[S] throws IOException {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; MST[rv.UOI2Mutator]MSP[N] } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.ROR5Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.CRCR5Mutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; MST[rv.UOI2Mutator]MSP[N] sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.UOI3Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.ROR5Mutator]MSP[N] {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.UOI2Mutator]MSP[S] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
optionHandlers [ option ] . setWill ( true ) ; MST[rv.UOI2Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[InlineConstantMutator]MSP[S] throws IOException {
spy . write ( ch ) ; spy . flush () ; MST[rv.UOI2Mutator]MSP[S] } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) { if ( ! ( stateIsDo ( TelnetOption . ECHO )
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[rv.ROR5Mutator]MSP[N] optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) MST[InlineConstantMutator]MSP[N] { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI4Mutator]MSP[N] default: break; } if ( acceptNewState )
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.UOI4Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; MST[rv.UOI1Mutator]MSP[N] if ( opthand . getWill () ) { requestWont ( optcode ) ;
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.ABSMutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.UOI1Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.ROR4Mutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.UOI2Mutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI3Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { MST[rv.ABSMutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { default:
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] default: break; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI2Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[ConditionalsBoundaryMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
final synchronized void processAYTResponse () MST[InlineConstantMutator]MSP[S] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI4Mutator]MSP[S] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
final synchronized void requestWont ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[NegateConditionalsMutator]MSP[N] }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR4Mutator]MSP[S] throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI2Mutator]MSP[S] } _output_ . write ( b ) ; }
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[rv.CRCR5Mutator]MSP[S] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI4Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.UOI1Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.CRCR4Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } MST[VoidMethodCallMutator]MSP[S] } final synchronized void _sendCommand ( final byte cmd ) throws IOException { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
final synchronized void requestWont ( final int option ) MST[NegateConditionalsMutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
boolean stateIsWill ( final int option ) MST[rv.CRCR1Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI2Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[NegateConditionalsMutator]MSP[S] throws IOException {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.ABSMutator]MSP[N] {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR5Mutator]MSP[N] }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[NegateConditionalsMutator]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.AOR3Mutator]MSP[N] { switch ( option ) { default:
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[rv.ROR2Mutator]MSP[N] ++ doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[rv.UOI3Mutator]MSP[S] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR1Mutator]MSP[S] throws IOException {
aytFlag = true ; } else { retValue = true ; MST[rv.CRCR5Mutator]MSP[N] } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.CRCR6Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.UOI3Mutator]MSP[N] protected void _connectAction_ () throws IOException {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.UOI4Mutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.ROR2Mutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
if ( debug || debugoptions ) { System . err . println ( lr_11 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DO ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI4Mutator]MSP[S]
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR5Mutator]MSP[S] throws IOException {
boolean stateIsWill ( final int option ) MST[rv.CRCR6Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
} if ( willResponse [ option ] > 0 ) MST[rv.UOI2Mutator]MSP[N] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.ROR1Mutator]MSP[S] default: break; } if ( acceptNewState )
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.ROR2Mutator]MSP[N] {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) MST[rv.CRCR6Mutator]MSP[N] { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
final synchronized void requestDo ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI3Mutator]MSP[N] }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[rv.UOI1Mutator]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.UOI2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR3Mutator]MSP[N] { if ( debugoptions ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.UOI4Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[rv.ROR5Mutator]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI4Mutator]MSP[N] { switch ( option ) { default:
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; MST[rv.UOI4Mutator]MSP[N] if ( opthand . getWill () ) { requestWont ( optcode ) ;
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.ROR4Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.AOD1Mutator]MSP[N] { switch ( option ) { default:
final synchronized void requestDo ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; MST[VoidMethodCallMutator]MSP[N] } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] protected void _connectAction_ () throws IOException {
optionHandlers [ ii ] . setDo ( false ) ; MST[rv.UOI4Mutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.ROR2Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI1Mutator]MSP[N] }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR4Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[VoidMethodCallMutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.ABSMutator]MSP[N] final synchronized void requestWill ( final int option ) throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI2Mutator]MSP[S]
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.ABSMutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
boolean stateIsWill ( final int option ) MST[rv.CRCR2Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI3Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { MST[VoidMethodCallMutator]MSP[S] ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
_output_ . write ( option ) ; _output_ . flush () ; } MST[rv.ABSMutator]MSP[N] final synchronized void requestDont ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[VoidMethodCallMutator]MSP[N]
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR4Mutator]MSP[S] throws IOException {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
spy . write ( ch ) ; spy . flush () ; } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) MST[VoidMethodCallMutator]MSP[N] { if ( ! ( stateIsDo ( TelnetOption . ECHO )
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI4Mutator]MSP[N] default: break; } if ( acceptNewState )
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR3Mutator]MSP[S] throws IOException {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; MST[rv.ABSMutator]MSP[N] }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.CRCR6Mutator]MSP[N]
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ++ doResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI1Mutator]MSP[N] throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI3Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI2Mutator]MSP[N] } _output_ . write ( b ) ; }
final synchronized void requestWont ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.UOI4Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } MST[NonVoidMethodCallMutator]MSP[N] final synchronized void sendDo ( final int option ) throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[NegateConditionalsMutator]MSP[N] }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.CRCR6Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI3Mutator]MSP[N] final synchronized void requestWill ( final int option ) throws IOException {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throws IOException {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } MST[rv.CRCR2Mutator]MSP[S] if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.UOI1Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.CRCR4Mutator]MSP[N] { if ( debugoptions ) {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.CRCR2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { MST[rv.CRCR5Mutator]MSP[N] aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; if ( aytFlag == false ) { retValue = false ;
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.ROR4Mutator]MSP[N] throws IOException { if ( debug ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throws IOException {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { MST[rv.UOI2Mutator]MSP[S] ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) MST[rv.CRCR1Mutator]MSP[N] { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } MST[rv.UOI4Mutator]MSP[N] final synchronized void sendDo ( final int option ) throws IOException {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; MST[rv.ROR5Mutator]MSP[N] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[InlineConstantMutator]MSP[N] { if ( debugoptions ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException {
boolean stateIsWill ( final int option ) MST[rv.CRCR4Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[NegateConditionalsMutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; MST[VoidMethodCallMutator]MSP[S] sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ABSMutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } MST[VoidMethodCallMutator]MSP[N] setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI3Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[NegateConditionalsMutator]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; MST[VoidMethodCallMutator]MSP[N] } final synchronized void requestWill ( final int option ) throws IOException {
void processDont ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_3 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DONT , option ) ; MST[rv.ROR5Mutator]MSP[N]
final synchronized void requestDo ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR3Mutator]MSP[N] throws IOException {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.ABSMutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR3Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[rv.UOI2Mutator]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[ConstructorCallMutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.UOI4Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
void processDont ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_3 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DONT , option ) ; MST[NegateConditionalsMutator]MSP[N]
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[InlineConstantMutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.UOI2Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR6Mutator]MSP[S] throws IOException {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.UOI1Mutator]MSP[N] protected void _connectAction_ () throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[rv.UOI1Mutator]MSP[S] optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void requestWont ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR5Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR6Mutator]MSP[N] {
if ( debug || debugoptions ) { System . err . println ( lr_11 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DO ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI1Mutator]MSP[N]
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.ABSMutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.CRCR2Mutator]MSP[N] { if ( debugoptions ) {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.CRCR5Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI4Mutator]MSP[S] } _output_ . write ( b ) ; }
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; MST[rv.UOI1Mutator]MSP[N] }
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[rv.ROR5Mutator]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
boolean stateIsWill ( final int option ) MST[rv.CRCR3Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI3Mutator]MSP[N] -- willResponse [ option ] ; } }
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.UOI4Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { MST[rv.UOI2Mutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
boolean stateIsWill ( final int option ) MST[rv.CRCR5Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; MST[rv.CRCR1Mutator]MSP[S] if ( aytFlag == false ) { retValue = false ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.CRCR2Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.UOI1Mutator]MSP[N] { default: break; }
setWont ( option ) ; MST[rv.UOI1Mutator]MSP[N] } void processWill ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[rv.ABSMutator]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[InlineConstantMutator]MSP[N] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[rv.ABSMutator]MSP[N] default: break; }
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[VoidMethodCallMutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.ABSMutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[ConditionalsBoundaryMutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[VoidMethodCallMutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[rv.ABSMutator]MSP[N] {
} if ( willResponse [ option ] > 0 ) MST[rv.ABSMutator]MSP[N] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[ConditionalsBoundaryMutator]MSP[N] {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR4Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.ROR3Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI2Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.UOI1Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[NonVoidMethodCallMutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.OBBN1Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
if ( subneg != null ) MST[rv.CRCR3Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[NegateConditionalsMutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.ROR3Mutator]MSP[N] {
aytFlag = true ; } else { retValue = true ; } } return retValue ; MST[rv.CRCR5Mutator]MSP[S] } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.ABSMutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.UOI4Mutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; MST[rv.UOI3Mutator]MSP[N] if ( opthand . getWill () ) { requestWont ( optcode ) ;
if ( subneg != null ) { MST[rv.UOI4Mutator]MSP[S] _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( debug ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
TelnetNotificationHandler . RECEIVED_WILL , option ) ; MST[NegateConditionalsMutator]MSP[N] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
final synchronized void requestWont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI2Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.AOD1Mutator]MSP[N] { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI2Mutator]MSP[N] final synchronized void requestWill ( final int option ) throws IOException {
final synchronized void requestWont ( final int option ) MST[NonVoidMethodCallMutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[rv.ROR2Mutator]MSP[N] ++ doResponse [ option ] ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.UOI4Mutator]MSP[N] protected void _connectAction_ () throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) {
optionHandlers [ ii ] . setDo ( false ) ; MST[rv.UOI2Mutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { MST[rv.ABSMutator]MSP[N] _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ABSMutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.ROR5Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
_output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI2Mutator]MSP[N] final synchronized void requestDont ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.ABSMutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.UOI2Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI1Mutator]MSP[N] {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final synchronized void requestDo ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.AOR1Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
setWantDont ( option ) ; MST[rv.ROR4Mutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else MST[rv.ABSMutator]MSP[N] { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; MST[rv.ABSMutator]MSP[N] } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; MST[rv.UOI2Mutator]MSP[N] } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } MST[rv.UOI2Mutator]MSP[S] final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[InlineConstantMutator]MSP[N] { switch ( option ) { default:
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR3Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI1Mutator]MSP[S] { -- doResponse [ option ] ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; } MST[rv.UOI2Mutator]MSP[S]
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[rv.CRCR4Mutator]MSP[S] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI3Mutator]MSP[N] } if ( acceptNewState )
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[rv.CRCR1Mutator]MSP[N]
final synchronized void requestDo ( final int option ) MST[rv.ROR2Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.CRCR4Mutator]MSP[N] throws IOException { if ( debug ) {
spy . write ( ch ) ; spy . flush () ; } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) MST[rv.UOI2Mutator]MSP[N] { if ( ! ( stateIsDo ( TelnetOption . ECHO )
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.CRCR2Mutator]MSP[N] {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[InlineConstantMutator]MSP[S] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR5Mutator]MSP[S] throws IOException {
aytFlag = true ; } else { retValue = true ; MST[rv.CRCR3Mutator]MSP[N] } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
aytFlag = true ; } else { retValue = true ; } } return retValue ; MST[InlineConstantMutator]MSP[S] } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.CRCR5Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } MST[rv.ABSMutator]MSP[N] final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
} if ( opthand . getDo () ) { MST[rv.ROR1Mutator]MSP[N] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else MST[rv.UOI2Mutator]MSP[N] { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI3Mutator]MSP[S] throws IOException {
final synchronized void requestWont ( final int option ) MST[rv.ROR5Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR1Mutator]MSP[N] }
boolean stateIsWill ( final int option ) MST[rv.CRCR1Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI2Mutator]MSP[N] { switch ( option ) { default:
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI2Mutator]MSP[N] -- willResponse [ option ] ; } }
optionHandlers [ ii ] . setDo ( false ) ; MST[InlineConstantMutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI4Mutator]MSP[S] } _output_ . write ( b ) ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.ROR4Mutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI1Mutator]MSP[N]
} void spyRead ( final int ch ) MST[rv.UOI2Mutator]MSP[S] { final OutputStream spy = spyStream ; if ( spy != null ) { try { if ( ch != '\r' ) { if ( ch == '\n' ) { spy . write ( '\r' ) ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.UOI2Mutator]MSP[N] { default: break; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI3Mutator]MSP[N] { -- doResponse [ option ] ;
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.CRCR4Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.AOD1Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.ABSMutator]MSP[N]
throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_14 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WONT ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI1Mutator]MSP[N]
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[InlineConstantMutator]MSP[S] throws IOException { if ( debug ) {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { MST[rv.CRCR3Mutator]MSP[N] aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; if ( aytFlag == false ) { retValue = false ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[rv.ROR4Mutator]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
final synchronized void processAYTResponse () MST[rv.CRCR6Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI1Mutator]MSP[N] throws IOException {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; MST[rv.UOI4Mutator]MSP[S] } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.UOI2Mutator]MSP[N] {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ROR4Mutator]MSP[N] protected void _connectAction_ () throws IOException {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.ABSMutator]MSP[S] } _output_ . write ( b ) ; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { MST[InlineConstantMutator]MSP[N] acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI4Mutator]MSP[N] }
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } if ( doResponse [ option ] > 0 ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[rv.UOI4Mutator]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI4Mutator]MSP[N]
aytFlag = true ; MST[rv.UOI2Mutator]MSP[N] } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
setWont ( option ) ; MST[rv.UOI4Mutator]MSP[S] } void processWill ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.AOR2Mutator]MSP[N]
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[rv.ABSMutator]MSP[N] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.UOI1Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[NegateConditionalsMutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.CRCR5Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.AOR2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[NonVoidMethodCallMutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.UOI2Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( option == TERMINAL_TYPE ) MST[NonVoidMethodCallMutator]MSP[S] { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[rv.ROR2Mutator]MSP[N] default: break; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ++ doResponse [ option ] ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR3Mutator]MSP[N] {
final synchronized void requestDo ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.UOI1Mutator]MSP[N] protected void _connectAction_ () throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[rv.UOI4Mutator]MSP[N]
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.ABSMutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
optionHandlers [ option ] . setWill ( true ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[ConditionalsBoundaryMutator]MSP[N] -- willResponse [ option ] ; } }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[InlineConstantMutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.ROR5Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.CRCR4Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[rv.UOI3Mutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; MST[VoidMethodCallMutator]MSP[S] } } final synchronized void _sendSubnegotiation ( final int subn [] ) throws IOException { if ( debug ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.AOD1Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.CRCR6Mutator]MSP[S] {
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[rv.UOI4Mutator]MSP[S] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR3Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR2Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[InlineConstantMutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { if ( optionHandlers [ option ] != null ) {
final synchronized void requestDo ( final int option ) MST[rv.ROR2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR3Mutator]MSP[N] {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI2Mutator]MSP[S] } _output_ . write ( b ) ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[VoidMethodCallMutator]MSP[S] throws IOException { if ( debug ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI3Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI4Mutator]MSP[N] {
System . err . println ( lr_7 + ii + lr_8 + suboption [ ii ] ) ; } } if ( suboption [ 0 ] == TERMINAL_TYPE && suboption [ 1 ] == TERMINAL_TYPE_SEND ) { sendTerminalType () ; } } } } } final synchronized void sendTerminalType () MST[NonVoidMethodCallMutator]MSP[S]
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR3Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { MST[rv.CRCR5Mutator]MSP[N] acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] ++ doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) {
if ( option == TERMINAL_TYPE ) MST[rv.UOI2Mutator]MSP[N] { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.ROR5Mutator]MSP[S]
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI1Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { MST[rv.CRCR6Mutator]MSP[N] aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; if ( aytFlag == false ) { retValue = false ;
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.AOD2Mutator]MSP[N]
} if ( willResponse [ option ] > 0 ) MST[rv.CRCR3Mutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
final synchronized void requestWont ( final int option ) MST[rv.ROR5Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
final synchronized void requestDo ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI1Mutator]MSP[S] } _output_ . write ( b ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR1Mutator]MSP[N] }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR1Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
setWantDont ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[VoidMethodCallMutator]MSP[S] {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.AOD2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI4Mutator]MSP[N] { -- doResponse [ option ] ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.AOR2Mutator]MSP[N] { switch ( option ) { default:
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI4Mutator]MSP[S] throws IOException {
final synchronized void processAYTResponse () MST[rv.CRCR3Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendCommand ( final byte cmd ) throws IOException MST[VoidMethodCallMutator]MSP[N] { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.CRCR2Mutator]MSP[N] { switch ( option ) { default:
break; MST[rv.UOI1Mutator]MSP[N] } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.ABSMutator]MSP[S] } _output_ . write ( b ) ; }
final synchronized void requestWont ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.ABSMutator]MSP[N] -- willResponse [ option ] ; } }
if ( subneg != null ) MST[rv.CRCR6Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( debug ) {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[rv.ROR3Mutator]MSP[S] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( debug ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { MST[rv.UOI2Mutator]MSP[N] switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } MST[rv.CRCR3Mutator]MSP[N] if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.CRCR5Mutator]MSP[N] { if ( debugoptions ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.UOI3Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[rv.UOI1Mutator]MSP[N] {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI3Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI3Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[VoidMethodCallMutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[rv.ROR2Mutator]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.UOI4Mutator]MSP[S]
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR3Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default: break; }
boolean stateIsWill ( final int option ) MST[rv.CRCR4Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { MST[rv.CRCR1Mutator]MSP[S] optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.CRCR2Mutator]MSP[N]
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
boolean stateIsWill ( final int option ) MST[InlineConstantMutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; MST[rv.UOI2Mutator]MSP[S] sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; MST[rv.UOI3Mutator]MSP[N] } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
aytFlag = true ; } else { retValue = true ; MST[experimental.MemberVariableMutator]MSP[N] } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.AOR2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; } MST[rv.ABSMutator]MSP[N]
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[InlineConstantMutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.CRCR4Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
final synchronized void requestWont ( final int option ) MST[rv.ROR2Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } MST[rv.UOI1Mutator]MSP[N] setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.CRCR2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.ABSMutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; MST[rv.ABSMutator]MSP[N] } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI4Mutator]MSP[N] }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR4Mutator]MSP[N] }
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[NegateConditionalsMutator]MSP[S]
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI2Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR3Mutator]MSP[S] throws IOException {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.ABSMutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[rv.UOI4Mutator]MSP[S] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
final synchronized void requestWont ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.OBBN2Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
aytFlag = true ; } else { retValue = true ; MST[rv.CRCR6Mutator]MSP[N] } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void requestDo ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
} if ( opthand . getDo () ) { MST[NegateConditionalsMutator]MSP[S] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.AOR2Mutator]MSP[N] { if ( debugoptions ) {
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; MST[rv.UOI3Mutator]MSP[S] } } final synchronized void _sendCommand ( final byte cmd ) throws IOException { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
final synchronized void requestDo ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.ROR1Mutator]MSP[S] throws IOException { if ( debug ) {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[NegateConditionalsMutator]MSP[N] {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI3Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI3Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.CRCR6Mutator]MSP[N] {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.ROR2Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.ABSMutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) {
setWont ( option ) ; MST[VoidMethodCallMutator]MSP[N] } void processWill ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
boolean stateIsWill ( final int option ) MST[rv.CRCR6Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.CRCR6Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException {
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[rv.UOI1Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.UOI3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
if ( debug || debugoptions ) { System . err . println ( lr_11 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DO ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.ABSMutator]MSP[S]
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ABSMutator]MSP[N] throws IOException {
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.ROR1Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[NonVoidMethodCallMutator]MSP[N] { if ( debugoptions ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { MST[rv.UOI3Mutator]MSP[N] requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.AOR2Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) throws IOException { if ( debug ) {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { MST[rv.ROR5Mutator]MSP[N] default:
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
} if ( opthand . getDo () ) MST[rv.ABSMutator]MSP[N] { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[VoidMethodCallMutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI1Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI1Mutator]MSP[N] } _output_ . write ( b ) ; }
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.UOI3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI3Mutator]MSP[S] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.UOI2Mutator]MSP[N] {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.UOI1Mutator]MSP[N] throws IOException , IllegalArgumentException , InterruptedException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.AOR4Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ABSMutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { MST[rv.UOI4Mutator]MSP[N] optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; MST[rv.UOI1Mutator]MSP[N] sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI1Mutator]MSP[S]
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI3Mutator]MSP[S]
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.UOI1Mutator]MSP[S] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[InlineConstantMutator]MSP[S] throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.ABSMutator]MSP[N]
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[IncrementsMutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
spy . write ( ch ) ; spy . flush () ; MST[rv.UOI3Mutator]MSP[S] } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) { if ( ! ( stateIsDo ( TelnetOption . ECHO )
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ABSMutator]MSP[S] throws IOException {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.CRCR6Mutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
final synchronized void requestDo ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[rv.ROR3Mutator]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; MST[rv.ABSMutator]MSP[S] }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.CRCR5Mutator]MSP[N] { switch ( option ) { default:
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.CRCR5Mutator]MSP[N] {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.CRCR3Mutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.ROR3Mutator]MSP[N] -- willResponse [ option ] ; } }
break; MST[rv.UOI4Mutator]MSP[N] } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.ROR4Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( debugoptions ) {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] optionHandlers [ option ] . startSubnegotiationRemote () ;
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; MST[rv.UOI1Mutator]MSP[N] } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
final synchronized void processAYTResponse () MST[rv.CRCR4Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.AOR4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI3Mutator]MSP[S] throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR6Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI3Mutator]MSP[N] { switch ( option ) { default:
optionHandlers [ ii ] . setDo ( false ) ; MST[rv.ABSMutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR2Mutator]MSP[N] { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.UOI4Mutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { MST[rv.ABSMutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
final synchronized void requestDo ( final int option ) MST[NonVoidMethodCallMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR5Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[InlineConstantMutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.ABSMutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI4Mutator]MSP[N] }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.ABSMutator]MSP[N] { switch ( option ) { default:
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.ROR1Mutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
optionHandlers [ option ] . setWill ( true ) ; MST[rv.ROR3Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.ROR3Mutator]MSP[N] { default: break; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.AOD1Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.UOI3Mutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI2Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { MST[rv.UOI2Mutator]MSP[N] _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.UOI4Mutator]MSP[N] protected void _connectAction_ () throws IOException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.ROR3Mutator]MSP[N] throws IOException , IllegalArgumentException , InterruptedException {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.ABSMutator]MSP[N] if ( optionHandlers [ option ] != null ) {
optionHandlers [ ii ] . setDo ( false ) ; MST[rv.CRCR5Mutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.UOI3Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
final synchronized void requestWont ( final int option ) MST[rv.ROR2Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[rv.ROR5Mutator]MSP[N] {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI1Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR4Mutator]MSP[S] throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR4Mutator]MSP[N] }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI4Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else MST[ConstructorCallMutator]MSP[N] { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { MST[rv.UOI1Mutator]MSP[N] requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
aytFlag = true ; } else { MST[rv.CRCR3Mutator]MSP[S] retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.CRCR1Mutator]MSP[N] throws IOException { if ( debug ) {
if ( subneg != null ) MST[rv.UOI3Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[MathMutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void requestWont ( final int option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.ROR1Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI3Mutator]MSP[N] default: break; } if ( acceptNewState )
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ABSMutator]MSP[N] protected void _connectAction_ () throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.ABSMutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.AOR2Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; MST[rv.UOI2Mutator]MSP[N] } } final synchronized void _sendCommand ( final byte cmd ) throws IOException { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { -- doResponse [ option ] ;
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI4Mutator]MSP[S] } _output_ . write ( b ) ; }
setWantDont ( option ) ; MST[rv.ROR5Mutator]MSP[S] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; MST[rv.UOI1Mutator]MSP[N] } } } setWill ( option ) ; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { MST[rv.CRCR3Mutator]MSP[N] acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ABSMutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR1Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) MST[rv.CRCR5Mutator]MSP[N] { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
_output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI1Mutator]MSP[N] final synchronized void requestDont ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[ConditionalsBoundaryMutator]MSP[N] {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.ABSMutator]MSP[N] default: break; } if ( acceptNewState )
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[rv.ROR5Mutator]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI2Mutator]MSP[S] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } MST[rv.UOI4Mutator]MSP[N] setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.CRCR5Mutator]MSP[N]
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR2Mutator]MSP[N] {
} void spyRead ( final int ch ) MST[rv.CRCR1Mutator]MSP[N] { final OutputStream spy = spyStream ; if ( spy != null ) { try { if ( ch != '\r' ) { if ( ch == '\n' ) { spy . write ( '\r' ) ; }
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; MST[rv.ABSMutator]MSP[S] } } final synchronized void _sendCommand ( final byte cmd ) throws IOException { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI4Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR6Mutator]MSP[S] throws IOException {
final synchronized void requestWont ( final int option ) MST[rv.ROR4Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
setWantDont ( option ) ; MST[NegateConditionalsMutator]MSP[S] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.CRCR5Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI1Mutator]MSP[N] final synchronized void requestWill ( final int option ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ABSMutator]MSP[S] throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.CRCR6Mutator]MSP[N] { if ( debugoptions ) {
boolean stateIsWill ( final int option ) MST[rv.CRCR1Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ++ doResponse [ option ] ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI4Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
aytFlag = true ; } else { retValue = true ; MST[rv.CRCR4Mutator]MSP[N] } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[rv.CRCR3Mutator]MSP[S] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[NegateConditionalsMutator]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
final synchronized void requestDo ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.CRCR6Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.UOI3Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[rv.ROR3Mutator]MSP[N] ++ doResponse [ option ] ;
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.ROR3Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.AOD2Mutator]MSP[N] { switch ( option ) { default:
final synchronized void requestDo ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[InlineConstantMutator]MSP[N] if ( optionHandlers [ option ] != null ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR3Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.CRCR3Mutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[rv.ROR5Mutator]MSP[S] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI2Mutator]MSP[N] throws IOException {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( debug ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI1Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.ABSMutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
} if ( willResponse [ option ] > 0 ) MST[rv.UOI1Mutator]MSP[N] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[VoidMethodCallMutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.ABSMutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; MST[rv.UOI4Mutator]MSP[N] sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.CRCR3Mutator]MSP[N] { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR2Mutator]MSP[S] throws IOException {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.UOI4Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR1Mutator]MSP[S] throws IOException {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.AOD2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.CRCR3Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR2Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.UOI1Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR2Mutator]MSP[N] { if ( debugoptions ) {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; MST[NegateConditionalsMutator]MSP[N] _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) throws IOException { if ( debug ) {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR3Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
for ( final int element : subn ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; }
optionHandlers [ ii ] . setDo ( false ) ; MST[rv.CRCR1Mutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] default: break; } if ( acceptNewState )
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI2Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[InlineConstantMutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[rv.UOI3Mutator]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[VoidMethodCallMutator]MSP[N] {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; MST[rv.UOI4Mutator]MSP[N] } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI3Mutator]MSP[N]
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.ROR1Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[InlineConstantMutator]MSP[S] throws IOException {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.UOI2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.UOI3Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR5Mutator]MSP[S] throws IOException {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[rv.ROR5Mutator]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.CRCR6Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { MST[rv.CRCR1Mutator]MSP[N] aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; if ( aytFlag == false ) { retValue = false ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI3Mutator]MSP[N] default: break; } if ( acceptNewState )
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR4Mutator]MSP[S] throws IOException {
boolean stateIsWill ( final int option ) MST[experimental.MemberVariableMutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[rv.ROR2Mutator]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI2Mutator]MSP[S] default: break; } if ( acceptNewState )
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[rv.UOI1Mutator]MSP[N] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { MST[rv.UOI3Mutator]MSP[S] ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI4Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[VoidMethodCallMutator]MSP[S] throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.AOR4Mutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) {
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] void setWantWont ( final int option ) { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.ROR5Mutator]MSP[S] {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.ABSMutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.ROR4Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.ROR5Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
boolean stateIsWill ( final int option ) MST[rv.CRCR2Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] -- willResponse [ option ] ; } }
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI4Mutator]MSP[S] } _output_ . write ( b ) ; }
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI2Mutator]MSP[N] -- willResponse [ option ] ; } }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[rv.UOI4Mutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ABSMutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.UOI2Mutator]MSP[S] { default: break; }
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.AOD2Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { MST[NegateConditionalsMutator]MSP[N] default:
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.AOR1Mutator]MSP[N] { switch ( option ) { default:
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[InlineConstantMutator]MSP[N] {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; MST[experimental.MemberVariableMutator]MSP[S] if ( aytFlag == false ) { retValue = false ;
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { MST[rv.UOI1Mutator]MSP[N] requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.AOR4Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
if ( subneg != null ) { MST[rv.UOI2Mutator]MSP[N] _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { -- doResponse [ option ] ;
final synchronized void requestWont ( final int option ) MST[rv.ROR4Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.ABSMutator]MSP[N] { default: break; }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default:
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
{ setWantDo ( option ) ; sendDo ( option ) ; } else { MST[VoidMethodCallMutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
final synchronized void requestWont ( final int option ) MST[rv.ROR1Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[NegateConditionalsMutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR2Mutator]MSP[S] throws IOException {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws IOException { if ( debug ) {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.UOI3Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[MathMutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR6Mutator]MSP[N] {
if ( subneg != null ) { MST[rv.ABSMutator]MSP[S] _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR6Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.CRCR3Mutator]MSP[N] { switch ( option ) { default:
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; MST[rv.UOI3Mutator]MSP[S] } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[ConditionalsBoundaryMutator]MSP[N] { if ( debugoptions ) {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.UOI1Mutator]MSP[N] {
final synchronized void processAYTResponse () MST[rv.CRCR2Mutator]MSP[S] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.CRCR1Mutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR3Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.ROR4Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[MathMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.OBBN3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { MST[rv.UOI1Mutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI3Mutator]MSP[S] } _output_ . write ( b ) ; }
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.ROR3Mutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; } MST[VoidMethodCallMutator]MSP[N]
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI1Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
boolean stateIsWill ( final int option ) MST[rv.CRCR4Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[MathMutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] ++ doResponse [ option ] ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] default: break; } if ( acceptNewState )
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.UOI2Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.AOR4Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
} if ( willResponse [ option ] > 0 ) MST[rv.CRCR1Mutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[NegateConditionalsMutator]MSP[N] protected void _connectAction_ () throws IOException {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[NegateConditionalsMutator]MSP[S] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; MST[InlineConstantMutator]MSP[S] if ( aytFlag == false ) { retValue = false ;
final synchronized void requestDo ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[NegateConditionalsMutator]MSP[S] {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI3Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI4Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { MST[rv.ROR5Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { default:
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.AOD2Mutator]MSP[N] { if ( debugoptions ) {
final synchronized void requestDo ( final int option ) MST[VoidMethodCallMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR1Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.UOI2Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[MathMutator]MSP[N]
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] { if ( debugoptions ) {
if ( subneg != null ) MST[rv.CRCR2Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR2Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI4Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.ROR4Mutator]MSP[N] {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; MST[rv.CRCR3Mutator]MSP[S] if ( aytFlag == false ) { retValue = false ;
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[NonVoidMethodCallMutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
optionHandlers [ option ] . setWill ( true ) ; MST[rv.UOI3Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.UOI3Mutator]MSP[S] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
spy . write ( ch ) ; spy . flush () ; } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) MST[rv.UOI3Mutator]MSP[S] { if ( ! ( stateIsDo ( TelnetOption . ECHO )
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI1Mutator]MSP[N] }
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.CRCR3Mutator]MSP[N] {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { MST[rv.ABSMutator]MSP[N] requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.ROR3Mutator]MSP[N] default: break; } if ( acceptNewState )
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; MST[rv.UOI2Mutator]MSP[N] if ( opthand . getWill () ) { requestWont ( optcode ) ;
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ++ doResponse [ option ] ;
} if ( opthand . getDo () ) MST[rv.UOI1Mutator]MSP[S] { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.AOR1Mutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) {
boolean stateIsWill ( final int option ) MST[rv.CRCR6Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
final synchronized void requestWont ( final int option ) MST[rv.ABSMutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; MST[rv.UOI1Mutator]MSP[N] } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[rv.ABSMutator]MSP[N]
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[VoidMethodCallMutator]MSP[S] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; MST[rv.ABSMutator]MSP[N] } if ( acceptNewState )
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { MST[rv.UOI1Mutator]MSP[N] optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.ROR2Mutator]MSP[S] {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI2Mutator]MSP[S]
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI3Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[rv.UOI3Mutator]MSP[S] optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.UOI3Mutator]MSP[N] { default: break; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR4Mutator]MSP[S] throws IOException {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI2Mutator]MSP[N] { -- doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; MST[NonVoidMethodCallMutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR4Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI1Mutator]MSP[N] { switch ( option ) { default:
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[InlineConstantMutator]MSP[S] throws IOException {
optionHandlers [ option ] . setWill ( true ) ; MST[rv.ROR4Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
} if ( opthand . getDo () ) { MST[rv.ROR4Mutator]MSP[S] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
final synchronized void requestWont ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.AOR1Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
if ( option == TERMINAL_TYPE ) MST[rv.ABSMutator]MSP[N] { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; MST[VoidMethodCallMutator]MSP[S] } } final synchronized void _sendCommand ( final byte cmd ) throws IOException { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.ROR1Mutator]MSP[N]
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.UOI4Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } MST[rv.ABSMutator]MSP[N] final synchronized void sendDo ( final int option ) throws IOException {
final synchronized void requestWont ( final int option ) MST[rv.ROR1Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
} if ( willResponse [ option ] > 0 ) MST[VoidMethodCallMutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR5Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[rv.UOI4Mutator]MSP[N] {
final synchronized void requestDo ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
System . err . println ( lr_7 + ii + lr_8 + suboption [ ii ] ) ; } } if ( suboption [ 0 ] == TERMINAL_TYPE && suboption [ 1 ] == TERMINAL_TYPE_SEND ) { sendTerminalType () ; } } } } } final synchronized void sendTerminalType () MST[VoidMethodCallMutator]MSP[S]
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } MST[rv.CRCR4Mutator]MSP[N] if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI1Mutator]MSP[S] } _output_ . write ( b ) ; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[rv.UOI4Mutator]MSP[N] default: break; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR4Mutator]MSP[S] throws IOException {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[VoidMethodCallMutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
final synchronized void requestDo ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.UOI3Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { MST[InlineConstantMutator]MSP[N] aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; if ( aytFlag == false ) { retValue = false ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[VoidMethodCallMutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
final synchronized void requestWont ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.CRCR4Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[rv.ROR4Mutator]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[NegateConditionalsMutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI3Mutator]MSP[N] }
} if ( willResponse [ option ] > 0 ) MST[rv.UOI4Mutator]MSP[N] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.CRCR4Mutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI4Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI1Mutator]MSP[N] -- willResponse [ option ] ; } }
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI3Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.CRCR1Mutator]MSP[N] {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { MST[rv.UOI4Mutator]MSP[N] default:
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.ABSMutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { MST[rv.UOI2Mutator]MSP[N] requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
aytFlag = true ; } else { retValue = true ; MST[InlineConstantMutator]MSP[N] } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[rv.ROR1Mutator]MSP[N] default: break; }
throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_14 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WONT ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI4Mutator]MSP[N]
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[NegateConditionalsMutator]MSP[N] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.CRCR4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
final synchronized void requestDo ( final int option ) MST[rv.ABSMutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR3Mutator]MSP[S] throws IOException {
if ( debug || debugoptions ) { System . err . println ( lr_11 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DO ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI2Mutator]MSP[N]
for ( final int element : subn ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; }
boolean stateIsWill ( final int option ) MST[rv.CRCR4Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.ABSMutator]MSP[N] -- willResponse [ option ] ; } }
} if ( opthand . getDo () ) { MST[NonVoidMethodCallMutator]MSP[S] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR3Mutator]MSP[N] }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] { if ( debugoptions ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR2Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR2Mutator]MSP[N] throws IOException {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[NegateConditionalsMutator]MSP[N] protected void _connectAction_ () throws IOException {
aytFlag = true ; MST[rv.UOI3Mutator]MSP[N] } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.UOI4Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; } MST[rv.UOI1Mutator]MSP[S]
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) {
setWont ( option ) ; MST[rv.UOI3Mutator]MSP[S] } void processWill ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( option == TERMINAL_TYPE ) MST[rv.UOI3Mutator]MSP[N] { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.AOR3Mutator]MSP[N]
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.UOI1Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.ROR4Mutator]MSP[N]
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI2Mutator]MSP[N] } if ( acceptNewState )
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) MST[rv.ROR5Mutator]MSP[N] { spyStream = null ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.CRCR5Mutator]MSP[S] throws IOException { if ( debug ) {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.AOR3Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.UOI4Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR6Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR6Mutator]MSP[N] throws IOException {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.ROR5Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
final synchronized void requestDo ( final int option ) MST[rv.ROR5Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } MST[rv.UOI1Mutator]MSP[N] final synchronized void sendDo ( final int option ) throws IOException {
if ( debug || debugoptions ) { System . err . println ( lr_11 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DO ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[VoidMethodCallMutator]MSP[S]
final synchronized void requestDo ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException {
boolean stateIsWill ( final int option ) MST[rv.CRCR3Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; MST[rv.UOI4Mutator]MSP[N] } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI1Mutator]MSP[S] } _output_ . write ( b ) ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI2Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.UOI3Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI3Mutator]MSP[N] {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; } MST[rv.UOI4Mutator]MSP[N]
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI3Mutator]MSP[S] { -- doResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.UOI3Mutator]MSP[N] {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.ABSMutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
} if ( opthand . getDo () ) MST[rv.UOI4Mutator]MSP[N] { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ABSMutator]MSP[N] protected void _connectAction_ () throws IOException {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throws IOException { if ( debug ) {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.CRCR2Mutator]MSP[S] throws IOException { if ( debug ) {
if ( optionHandlers [ optcode ] == null ) { MST[NonVoidMethodCallMutator]MSP[N] optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( subneg != null ) MST[rv.UOI4Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.CRCR3Mutator]MSP[S] {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.ROR2Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR3Mutator]MSP[N] throws IOException {
if ( subneg != null ) MST[rv.UOI2Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI3Mutator]MSP[S] throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.ROR2Mutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void requestWont ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
final synchronized void requestWont ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { -- doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; MST[rv.UOI2Mutator]MSP[N] } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
final synchronized void requestDo ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { MST[rv.UOI3Mutator]MSP[N] _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR5Mutator]MSP[N] {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; MST[rv.UOI4Mutator]MSP[S] }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR5Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[VoidMethodCallMutator]MSP[N] throws IOException { if ( debug ) {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { default: break; }
final synchronized void requestWont ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR3Mutator]MSP[N] throws IOException {
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[rv.ROR5Mutator]MSP[S] ++ doResponse [ option ] ;
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR4Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR5Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { MST[rv.CRCR6Mutator]MSP[N] acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI2Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.ABSMutator]MSP[S] {
aytFlag = true ; MST[rv.ABSMutator]MSP[S] } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR4Mutator]MSP[N] throws IOException {
aytFlag = true ; } else { retValue = true ; } } return retValue ; MST[rv.CRCR2Mutator]MSP[S] } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
final synchronized void processAYTResponse () MST[rv.CRCR4Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
final synchronized void requestDo ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.ABSMutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.CRCR6Mutator]MSP[N] { switch ( option ) { default:
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.UOI3Mutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ROR1Mutator]MSP[S] protected void _connectAction_ () throws IOException {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.ROR2Mutator]MSP[N] -- willResponse [ option ] ; } }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[NegateConditionalsMutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.ROR3Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[rv.ROR2Mutator]MSP[N] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) {
if ( subneg != null ) MST[rv.CRCR5Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.AOD1Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
final synchronized void processAYTResponse () MST[rv.CRCR5Mutator]MSP[S] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { MST[rv.UOI3Mutator]MSP[N] switch ( option ) { default: break; } } } setWill ( option ) ; }
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { MST[VoidMethodCallMutator]MSP[N] requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI3Mutator]MSP[N] }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] { if ( debugoptions ) {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[VoidMethodCallMutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.AOD1Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; MST[rv.CRCR6Mutator]MSP[S] if ( aytFlag == false ) { retValue = false ;
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[NegateConditionalsMutator]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI4Mutator]MSP[N]
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; MST[rv.ABSMutator]MSP[S] sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ROR5Mutator]MSP[N] protected void _connectAction_ () throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[InlineConstantMutator]MSP[N]
} if ( willResponse [ option ] > 0 ) MST[rv.CRCR4Mutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI4Mutator]MSP[S] throws IOException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[InlineConstantMutator]MSP[S] {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.AOD1Mutator]MSP[N]
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[rv.ROR5Mutator]MSP[N] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.OBBN3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.AOR1Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; MST[rv.UOI3Mutator]MSP[S] sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
final synchronized void requestDo ( final int option ) MST[NegateConditionalsMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.UOI3Mutator]MSP[N] {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.AOD1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.UOI2Mutator]MSP[N] throws IOException , IllegalArgumentException , InterruptedException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[rv.UOI1Mutator]MSP[N]
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { MST[rv.ABSMutator]MSP[N] switch ( option ) { default: break; } } } setWill ( option ) ; }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI4Mutator]MSP[N] { switch ( option ) { default:
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[rv.UOI1Mutator]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
boolean stateIsWill ( final int option ) MST[rv.CRCR5Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) {
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[rv.ROR1Mutator]MSP[N] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[rv.UOI2Mutator]MSP[N] {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI2Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
{ setWantDo ( option ) ; sendDo ( option ) ; } else { MST[rv.UOI4Mutator]MSP[S] ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR2Mutator]MSP[S] throws IOException {
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.CRCR5Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.UOI3Mutator]MSP[N]
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[rv.ROR3Mutator]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
boolean stateIsWill ( final int option ) MST[experimental.MemberVariableMutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.ROR2Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.ABSMutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { MST[rv.UOI2Mutator]MSP[N] default: break; }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { MST[rv.UOI4Mutator]MSP[N] requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
boolean stateIsWill ( final int option ) MST[rv.CRCR3Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
boolean stateIsWill ( final int option ) MST[InlineConstantMutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR2Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
} if ( opthand . getDo () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ABSMutator]MSP[S] throws IOException {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
setWantDont ( option ) ; MST[rv.ROR1Mutator]MSP[S] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
final synchronized void requestDo ( final int option ) MST[rv.ROR5Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.CRCR2Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.AOR3Mutator]MSP[N] { if ( debugoptions ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[InlineConstantMutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.ROR4Mutator]MSP[N] {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { if ( optionHandlers [ option ] != null ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI2Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.UOI2Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI4Mutator]MSP[S]
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[NegateConditionalsMutator]MSP[N] -- willResponse [ option ] ; } }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ABSMutator]MSP[N] throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI3Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) MST[experimental.MemberVariableMutator]MSP[N] { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR5Mutator]MSP[N] {
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.ROR3Mutator]MSP[S]
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.ABSMutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
void processDont ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_3 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DONT , option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final synchronized void requestWont ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[rv.ABSMutator]MSP[N] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR5Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; MST[rv.ROR1Mutator]MSP[N] ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option )
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () MST[experimental.MemberVariableMutator]MSP[S] { spyStream = null ;
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.ABSMutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.AOR3Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( subneg != null ) { MST[rv.UOI1Mutator]MSP[N] _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.ABSMutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.ABSMutator]MSP[S]
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.UOI2Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.AOR3Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR2Mutator]MSP[S] throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[MathMutator]MSP[N] if ( optionHandlers [ option ] != null ) {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { if ( optionHandlers [ option ] != null ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[InlineConstantMutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR4Mutator]MSP[S] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[rv.UOI2Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.ABSMutator]MSP[N] default: break; } if ( acceptNewState )
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.UOI3Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
for ( final int element : subn ) { final byte b = ( byte ) element ; MST[VoidMethodCallMutator]MSP[S] if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; }
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { MST[rv.ABSMutator]MSP[N] ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[InlineConstantMutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = MST[rv.UOI2Mutator]MSP[N] optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.ROR3Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.CRCR4Mutator]MSP[N] { switch ( option ) { default:
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[NonVoidMethodCallMutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
boolean retValue = false ; synchronized ( aytMonitor ) { synchronized ( this ) { aytFlag = false ; _output_ . write ( _COMMAND_AYT ) ; _output_ . flush () ; } aytMonitor . wait ( timeout ) ; if ( aytFlag == false ) { MST[VoidMethodCallMutator]MSP[S] retValue = false ;
final synchronized void requestDo ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; MST[VoidMethodCallMutator]MSP[S] sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( debugoptions ) {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.CRCR2Mutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
break; MST[rv.UOI3Mutator]MSP[N] } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.AOR3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR2Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI1Mutator]MSP[N] throws IOException {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR5Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
final synchronized void processAYTResponse () MST[rv.CRCR3Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI1Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[rv.UOI2Mutator]MSP[S]
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.CRCR3Mutator]MSP[N] {
optionHandlers [ option ] . setWill ( true ) ; MST[rv.UOI4Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.ABSMutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.UOI4Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI2Mutator]MSP[N] default: break; } if ( acceptNewState )
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI1Mutator]MSP[S] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
} if ( willResponse [ option ] > 0 ) MST[rv.CRCR2Mutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
final synchronized void requestWont ( final int option ) MST[rv.ROR3Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[rv.CRCR2Mutator]MSP[N] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
final synchronized void requestDo ( final int option ) MST[NegateConditionalsMutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR3Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) MST[VoidMethodCallMutator]MSP[N] { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR5Mutator]MSP[S] throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ABSMutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.UOI3Mutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.CRCR2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[InlineConstantMutator]MSP[S] throws IOException {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } } void setDo ( final int option ) throws IOException {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.UOI2Mutator]MSP[N] { switch ( option ) { default:
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI4Mutator]MSP[N] -- willResponse [ option ] ; } }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.ROR5Mutator]MSP[N] { -- doResponse [ option ] ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR1Mutator]MSP[N] { if ( debugoptions ) {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI2Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { MST[ConstructorCallMutator]MSP[N] if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) {
} if ( opthand . getDo () ) MST[rv.UOI3Mutator]MSP[S] { requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
} if ( willResponse [ option ] > 0 ) MST[rv.CRCR5Mutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.UOI1Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI2Mutator]MSP[S] throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI3Mutator]MSP[N] throws IOException {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { if ( optionHandlers [ option ] != null ) {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
final synchronized void requestDo ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { MST[rv.UOI3Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { default:
_output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; MST[rv.UOI1Mutator]MSP[N] } } final synchronized void _sendCommand ( final byte cmd ) throws IOException { _output_ . write ( TelnetCommand . IAC ) ; _output_ . write ( cmd ) ; _output_ . flush () ; }
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[VoidMethodCallMutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else MST[NonVoidMethodCallMutator]MSP[S] { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) MST[rv.ABSMutator]MSP[N] { default: break; }
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR2Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.UOI1Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI3Mutator]MSP[S] } _output_ . write ( b ) ; }
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[NegateConditionalsMutator]MSP[S] ++ doResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[InlineConstantMutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR5Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
} if ( opthand . getDo () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.CRCR4Mutator]MSP[N] {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR1Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
spy . write ( ch ) ; spy . flush () ; } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) MST[rv.UOI4Mutator]MSP[S] { if ( ! ( stateIsDo ( TelnetOption . ECHO )
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.UOI1Mutator]MSP[N] {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.UOI1Mutator]MSP[S] if ( optionHandlers [ option ] != null ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR5Mutator]MSP[S] throws IOException {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[VoidMethodCallMutator]MSP[N] protected void _connectAction_ () throws IOException {
final synchronized void requestWont ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[N] { if ( debugoptions ) {
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.CRCR1Mutator]MSP[S] {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default: break; } if ( acceptNewState )
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[rv.ROR4Mutator]MSP[N] ++ doResponse [ option ] ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.CRCR4Mutator]MSP[N]
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[NonVoidMethodCallMutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } MST[rv.UOI3Mutator]MSP[N] setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.UOI3Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.CRCR2Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI4Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { MST[rv.ROR4Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) { switch ( option ) { default:
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI1Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.CRCR4Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; MST[rv.UOI2Mutator]MSP[N] } } } setWill ( option ) ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } MST[VoidMethodCallMutator]MSP[S] final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
final synchronized void requestDo ( final int option ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.UOI1Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI2Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[rv.UOI3Mutator]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] -- willResponse [ option ] ; } }
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { MST[rv.UOI3Mutator]MSP[N] requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[rv.UOI4Mutator]MSP[N] optionHandlers [ option ] . startSubnegotiationRemote () ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI4Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
spy . write ( ch ) ; spy . flush () ; } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) MST[rv.ABSMutator]MSP[S] { if ( ! ( stateIsDo ( TelnetOption . ECHO )
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.CRCR2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
optionHandlers [ option ] . setWill ( true ) ; MST[rv.ROR1Mutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
final synchronized void requestWont ( final int option ) MST[rv.UOI2Mutator]MSP[N] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.ROR2Mutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[InlineConstantMutator]MSP[N] {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.CRCR2Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.ABSMutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; MST[rv.ABSMutator]MSP[N] } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[rv.CRCR5Mutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( debug ) {
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } MST[rv.UOI3Mutator]MSP[N] void setWantWont ( final int option ) { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR2Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[rv.ROR4Mutator]MSP[S] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.UOI1Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ABSMutator]MSP[S] throws IOException {
aytFlag = true ; MST[VoidMethodCallMutator]MSP[S] } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.ABSMutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } MST[rv.CRCR5Mutator]MSP[N] if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[VoidMethodCallMutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
boolean stateIsWill ( final int option ) MST[rv.CRCR6Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.UOI2Mutator]MSP[N] default: break; } if ( acceptNewState )
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( optionHandlers [ ii ] != null ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR6Mutator]MSP[S] throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[InlineConstantMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR5Mutator]MSP[S] throws IOException {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
final synchronized void requestWont ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { spy . write ( ch ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI1Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[VoidMethodCallMutator]MSP[N] throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ABSMutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.AOR3Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI3Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[NegateConditionalsMutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ABSMutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.ROR3Mutator]MSP[N] }
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.ABSMutator]MSP[N] { -- doResponse [ option ] ;
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[NegateConditionalsMutator]MSP[N] {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; MST[rv.UOI3Mutator]MSP[N] sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI3Mutator]MSP[S] } _output_ . write ( b ) ; }
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI1Mutator]MSP[S]
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.ROR5Mutator]MSP[N] -- willResponse [ option ] ; } }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; MST[rv.ABSMutator]MSP[N] } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[NonVoidMethodCallMutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
spy . write ( ch ) ; spy . flush () ; MST[rv.UOI1Mutator]MSP[S] } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) { if ( ! ( stateIsDo ( TelnetOption . ECHO )
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[MathMutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR1Mutator]MSP[N] { if ( debugoptions ) {
final synchronized void processAYTResponse () MST[rv.CRCR1Mutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[rv.ROR5Mutator]MSP[N] ++ doResponse [ option ] ;
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
boolean stateIsWill ( final int option ) MST[rv.CRCR2Mutator]MSP[N] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI3Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.ABSMutator]MSP[S] throws IOException { if ( debug || debugoptions ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.UOI4Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } MST[rv.UOI3Mutator]MSP[N] void setDont ( final int option ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } MST[rv.UOI3Mutator]MSP[S] final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR5Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR1Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { MST[rv.UOI4Mutator]MSP[N] if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.ROR5Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.ROR5Mutator]MSP[S] throws IOException {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; MST[rv.ABSMutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.ROR2Mutator]MSP[N] default: break; } if ( acceptNewState )
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR1Mutator]MSP[S] throws IOException {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; MST[rv.ROR5Mutator]MSP[N] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { MST[rv.UOI2Mutator]MSP[N] -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; } if ( acceptNewState )
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR3Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[NegateConditionalsMutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI4Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR5Mutator]MSP[N] throws IOException {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { MST[rv.ABSMutator]MSP[N] requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[NegateConditionalsMutator]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( subneg != null ) MST[rv.UOI1Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; if ( opthand . getWill () ) { requestWont ( optcode ) ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.ROR3Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { MST[rv.UOI4Mutator]MSP[N] _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.UOI1Mutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.ROR5Mutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { MST[NonVoidMethodCallMutator]MSP[N] requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) MST[rv.ROR1Mutator]MSP[S] throws IOException , IllegalArgumentException , InterruptedException {
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.UOI2Mutator]MSP[N] throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; if ( optionHandlers [ ii ] != null ) { MST[rv.UOI2Mutator]MSP[N]
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.ROR4Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else MST[rv.UOI3Mutator]MSP[N] { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { MST[rv.UOI4Mutator]MSP[N] default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; }
final synchronized void requestWont ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[rv.ROR4Mutator]MSP[N] ++ doResponse [ option ] ;
final synchronized void processAYTResponse () MST[VoidMethodCallMutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.CRCR6Mutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[NegateConditionalsMutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[rv.UOI1Mutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
aytFlag = true ; } else { MST[rv.CRCR1Mutator]MSP[S] retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR3Mutator]MSP[S] throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[NegateConditionalsMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
aytFlag = true ; } else { MST[rv.CRCR5Mutator]MSP[S] retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
System . err . println ( lr_5 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_WONT , option ) ; } if ( doResponse [ option ] > 0 ) MST[rv.CRCR4Mutator]MSP[S] {
spy . write ( ch ) ; spy . flush () ; } } catch ( final IOException e ) { spyStream = null ; } } } void spyWrite ( final int ch ) MST[rv.UOI1Mutator]MSP[N] { if ( ! ( stateIsDo ( TelnetOption . ECHO )
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[VoidMethodCallMutator]MSP[N] final synchronized void requestWill ( final int option ) throws IOException {
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[rv.CRCR1Mutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; MST[rv.ROR1Mutator]MSP[N] } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[NegateConditionalsMutator]MSP[S] throws IOException {
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ROR5Mutator]MSP[N] protected void _connectAction_ () throws IOException {
final synchronized void processAYTResponse () MST[rv.CRCR6Mutator]MSP[S] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.AOR2Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.CRCR5Mutator]MSP[S] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR5Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) MST[rv.CRCR3Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR4Mutator]MSP[N] { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[VoidMethodCallMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[NegateConditionalsMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
boolean stateIsWill ( final int option ) MST[rv.CRCR6Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) MST[ConstructorCallMutator]MSP[N] { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; MST[rv.UOI2Mutator]MSP[N] final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] protected void _connectAction_ () throws IOException {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[InlineConstantMutator]MSP[N] {
aytFlag = true ; } else { retValue = true ; } } return retValue ; MST[rv.CRCR3Mutator]MSP[N] } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR4Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; MST[rv.ABSMutator]MSP[N] if ( opthand . getWill () ) { requestWont ( optcode ) ;
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI2Mutator]MSP[N] }
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[NegateConditionalsMutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI3Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[InlineConstantMutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[NegateConditionalsMutator]MSP[N] ++ doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { if ( debugoptions ) {
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) MST[rv.CRCR1Mutator]MSP[N] { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
final synchronized void requestWont ( final int option ) MST[rv.UOI3Mutator]MSP[S] throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; ++ doResponse [ option ] ;
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) MST[rv.UOI4Mutator]MSP[N] {
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else MST[ArgumentPropagationMutator]MSP[S] { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR4Mutator]MSP[N] {
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; MST[rv.UOI3Mutator]MSP[S] } _output_ . write ( b ) ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.AOR2Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[NegateConditionalsMutator]MSP[S] throws IOException {
aytFlag = true ; } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) MST[BooleanFalseReturnValsMutator]MSP[S] throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
} void spyRead ( final int ch ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { if ( ch != '\r' ) { if ( ch == '\n' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] spy . write ( '\r' ) ; }
boolean stateIsWill ( final int option ) MST[rv.CRCR1Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
void setWont ( final int option ) { options [ option ] &= ~ _WILL_MASK ; if ( optionHandlers [ option ] != null ) { MST[rv.UOI2Mutator]MSP[N] optionHandlers [ option ] . setWill ( false ) ; } } void setDont ( final int option ) {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI1Mutator]MSP[N] -- willResponse [ option ] ; } }
_output_ . write ( option ) ; _output_ . flush () ; } MST[VoidMethodCallMutator]MSP[N] final synchronized void requestDont ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
final synchronized void processAYTResponse () MST[experimental.MemberVariableMutator]MSP[S] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI4Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
boolean stateIsWill ( final int option ) MST[rv.CRCR3Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.UOI3Mutator]MSP[N]
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[rv.UOI2Mutator]MSP[S] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
} void spyRead ( final int ch ) MST[NegateConditionalsMutator]MSP[S] { final OutputStream spy = spyStream ; if ( spy != null ) { try { if ( ch != '\r' ) { if ( ch == '\n' ) { spy . write ( '\r' ) ; }
final synchronized void requestDo ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; MST[rv.ROR1Mutator]MSP[N] ++ doResponse [ option ] ;
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[InlineConstantMutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[MathMutator]MSP[N] { if ( debugoptions ) {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { MST[rv.UOI1Mutator]MSP[S] ++ willResponse [ option ] ; sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
final synchronized void requestDo ( final int option ) MST[rv.ROR4Mutator]MSP[S] throws IOException { if ( doResponse [ option ] == 0 && stateIsDo ( option ) || requestedDo ( option ) ) { return ; } setWantDo ( option ) ; ++ doResponse [ option ] ;
optionHandlers [ option ] . setWill ( true ) ; MST[NegateConditionalsMutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.AOR3Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[N] { if ( debugoptions ) {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.ROR1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.UOI2Mutator]MSP[S] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
setWantDont ( option ) ; MST[rv.ROR2Mutator]MSP[N] ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) throws IOException { if ( debug || debugoptions ) {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.ROR3Mutator]MSP[N] throws IOException { if ( debug ) {
} if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { MST[rv.UOI4Mutator]MSP[N] -- willResponse [ option ] ; } }
boolean stateIsWill ( final int option ) MST[rv.CRCR4Mutator]MSP[S] { return ( options [ option ] & _WILL_MASK ) != 0 ; } boolean stateIsWont ( final int option ) { return ! stateIsWill ( option ) ; } boolean stateIsDo ( final int option ) {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.ROR1Mutator]MSP[N] throws IOException {
if ( optionHandlers [ optcode ] == null ) { optionHandlers [ optcode ] = opthand ; MST[rv.ROR3Mutator]MSP[N] if ( isConnected () ) { if ( opthand . getInitLocal () ) { requestWill ( optcode ) ; } if ( opthand . getInitRemote () ) { requestDo ( optcode ) ;
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; MST[InlineConstantMutator]MSP[N] } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
&& requestedDo ( TelnetOption . ECHO ) ) ) { final OutputStream spy = spyStream ; if ( spy != null ) { try { MST[rv.CRCR6Mutator]MSP[N] spy . write ( ch ) ; spy . flush () ; } catch ( final IOException e ) { spyStream = null ; }
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) MST[rv.CRCR6Mutator]MSP[N] throws IOException { if ( debug ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[NonVoidMethodCallMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { default: break; MST[rv.UOI1Mutator]MSP[N] } if ( acceptNewState )
optionHandlers [ option ] . setWill ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[NegateConditionalsMutator]MSP[N] { -- doResponse [ option ] ;
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.ABSMutator]MSP[N] { switch ( option ) { default:
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[rv.CRCR3Mutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; } } } MST[InlineConstantMutator]MSP[S] if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
optionHandlers [ ii ] . setDo ( false ) ; optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; MST[rv.CRCR6Mutator]MSP[N] _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI2Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.CRCR1Mutator]MSP[N] {
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; MST[rv.UOI4Mutator]MSP[S] sendWont ( option ) ; } } else { switch ( option ) { default: break; } } } setWill ( option ) ; }
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI4Mutator]MSP[N] throws IOException {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[NegateConditionalsMutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) MST[VoidMethodCallMutator]MSP[S] { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
sendDo ( option ) ; } final synchronized void sendDont ( final int option ) MST[MathMutator]MSP[N] throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_12 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DONT ) ;
sendWont ( option ) ; } final synchronized void sendByte ( final int b ) MST[rv.CRCR6Mutator]MSP[N] throws IOException { _output_ . write ( b ) ; spyWrite ( b ) ; } final boolean _sendAYT ( final long timeout ) throws IOException , IllegalArgumentException , InterruptedException {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI4Mutator]MSP[N] final synchronized void requestWill ( final int option ) throws IOException {
final synchronized void requestWont ( final int option ) throws IOException { if ( willResponse [ option ] == 0 && stateIsWont ( option ) || requestedWont ( option ) ) { return ; } setWantWont ( option ) ; MST[rv.ROR1Mutator]MSP[S] ++ doResponse [ option ] ;
_output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI4Mutator]MSP[N] final synchronized void requestDont ( final int option ) throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI2Mutator]MSP[N] }
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.ROR1Mutator]MSP[N] {
if ( subneg != null ) MST[rv.CRCR4Mutator]MSP[N] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] }
aytFlag = true ; } else { retValue = true ; } } return retValue ; MST[rv.CRCR6Mutator]MSP[S] } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR2Mutator]MSP[S] throws IOException {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[rv.CRCR5Mutator]MSP[S] throws IOException {
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.UOI1Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throws IOException {
optionHandlers [ option ] . setWill ( true ) ; MST[rv.UOI1Mutator]MSP[S] final int subneg [] = optionHandlers [ option ] . startSubnegotiationLocal () ; if ( subneg != null ) { _sendSubnegotiation ( subneg ) ; } } } } void setDo ( final int option ) throws IOException {
final synchronized void processAYTResponse () MST[InlineConstantMutator]MSP[N] { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override protected void _connectAction_ () throws IOException {
notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_COMMAND , command ) ; } } void processDo ( final int option ) throws IOException MST[rv.ROR3Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_2 + TelnetOption . getOption ( option ) ) ; }
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.CRCR1Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
} if ( willResponse [ option ] > 0 ) MST[InlineConstantMutator]MSP[S] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
if ( subneg != null ) MST[rv.ABSMutator]MSP[S] { _sendSubnegotiation ( subneg ) ; } } } } void setWantWill ( final int option ) { options [ option ] |= _REQUESTED_WILL_MASK ; } void setWantDo ( final int option ) { options [ option ] |= _REQUESTED_DO_MASK ; }
if ( doResponse [ option ] > 0 && stateIsDo ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDont ( option ) ) { switch ( option ) { MST[rv.ABSMutator]MSP[N] default: break; } if ( acceptNewState )
options [ option ] &= ~ _DO_MASK ; if ( optionHandlers [ option ] != null ) { MST[rv.UOI3Mutator]MSP[S] optionHandlers [ option ] . setDo ( false ) ; } } void setWantWont ( final int option ) { options [ option ] &= ~ _REQUESTED_WILL_MASK ; }
if ( option == TERMINAL_TYPE ) { if ( terminalType != null && terminalType . length () > 0 ) { acceptNewState = true ; MST[rv.ROR5Mutator]MSP[N] } } } if ( willResponse [ option ] > 0 ) { -- willResponse [ option ] ;
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) MST[rv.UOI4Mutator]MSP[S] {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.CRCR5Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI1Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
final synchronized void processAYTResponse () { if ( ! aytFlag ) { synchronized ( aytMonitor ) { aytFlag = true ; aytMonitor . notifyAll () ; } } } @Override MST[rv.ROR2Mutator]MSP[N] protected void _connectAction_ () throws IOException {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[NegateConditionalsMutator]MSP[N] throws IOException {
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.AOR4Mutator]MSP[N]
{ if ( optionHandlers [ optcode ] == null ) { throw new InvalidTelnetOptionException ( lr_17 , optcode ) ; } final TelnetOptionHandler opthand = optionHandlers [ optcode ] ; optionHandlers [ optcode ] = null ; MST[ConstructorCallMutator]MSP[N] if ( opthand . getWill () ) { requestWont ( optcode ) ;
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[rv.ROR5Mutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
if ( willResponse [ option ] == 0 && requestedWill ( option ) ) { switch ( option ) { default: break; } if ( stateIsWill ( option ) || requestedWill ( option ) ) { sendWont ( option ) ; } setWantWont ( option ) ; MST[rv.UOI2Mutator]MSP[N] }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ABSMutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { doResponse [ ii ] = 0 ; willResponse [ ii ] = 0 ; options [ ii ] = 0 ; MST[rv.ROR1Mutator]MSP[N] if ( optionHandlers [ ii ] != null ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
optionHandlers [ suboption [ 0 ] ] . answerSubnegotiation ( suboption , suboptionLength ) ; MST[rv.CRCR1Mutator]MSP[N] _sendSubnegotiation ( responseSuboption ) ; } else { if ( suboptionLength > 1 ) { if ( debug ) { for ( int ii = 0 ; ii < suboptionLength ; ii ++ ) {
} if ( opthand . getDo () ) { requestDont ( optcode ) ; } } else { MST[rv.ROR1Mutator]MSP[N] throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else { MST[rv.UOI4Mutator]MSP[N] switch ( option ) { default: break; } } } setWill ( option ) ; }
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.UOI3Mutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
} if ( willResponse [ option ] > 0 ) MST[rv.UOI3Mutator]MSP[N] { -- willResponse [ option ] ; if ( willResponse [ option ] > 0 && stateIsWont ( option ) ) { -- willResponse [ option ] ; } }
setWantDont ( option ) ; ++ doResponse [ option ] ; sendDont ( option ) ; } final synchronized void sendWill ( final int option ) MST[rv.AOR4Mutator]MSP[N] throws IOException { if ( debug || debugoptions ) {
_output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestDont ( final int option ) MST[NegateConditionalsMutator]MSP[N] throws IOException { if ( doResponse [ option ] == 0 && stateIsDont ( option ) || requestedDont ( option ) ) { return ; }
optionHandlers [ ii ] . setDo ( false ) ; MST[rv.UOI3Mutator]MSP[N] optionHandlers [ ii ] . setWill ( false ) ; } } super . _connectAction_ () ; _input_ = new BufferedInputStream ( _input_ ) ; _output_ = new BufferedOutputStream ( _output_ ) ;
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[rv.UOI1Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
aytFlag = true ; MST[rv.UOI4Mutator]MSP[N] } else { retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
setWont ( option ) ; MST[rv.UOI2Mutator]MSP[N] } void processWill ( final int option ) throws IOException { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.ROR5Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.ROR1Mutator]MSP[N] {
System . err . println ( lr_13 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WILL ) ; _output_ . write ( option ) ; _output_ . flush () ; } final synchronized void requestWill ( final int option ) MST[rv.UOI1Mutator]MSP[N] throws IOException {
return ! requestedDo ( option ) ; } void setWill ( final int option ) throws IOException { options [ option ] |= _WILL_MASK ; if ( requestedWill ( option ) ) { MST[rv.UOI3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) {
if ( willResponse [ option ] > 0 && stateIsWill ( option ) ) { MST[rv.ABSMutator]MSP[N] -- willResponse [ option ] ; } } if ( willResponse [ option ] == 0 ) { if ( requestedWont ( option ) ) { switch ( option ) { default: break; }
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; MST[rv.UOI3Mutator]MSP[N] if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) { -- doResponse [ option ] ;
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) MST[rv.UOI3Mutator]MSP[N] { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } final synchronized void sendDo ( final int option ) throws IOException {
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; } void processWont ( final int option ) throws IOException MST[rv.ROR4Mutator]MSP[N] { if ( debugoptions ) {
break; } if ( stateIsDo ( option ) || requestedDo ( option ) ) { sendDont ( option ) ; } setWantDont ( option ) ; MST[NegateConditionalsMutator]MSP[N] } setDont ( option ) ; } void processSuboption ( final int suboption [] , final int suboptionLength ) throws IOException {
} if ( opthand . getDo () ) { MST[rv.ROR3Mutator]MSP[S] requestDont ( optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void _registerSpyStream ( final OutputStream spystream ) { spyStream = spystream ; } void _stopSpyStream () { spyStream = null ;
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.CRCR5Mutator]MSP[N] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
if ( acceptNewState ) { setWantWill ( option ) ; sendWill ( option ) ; } else { ++ willResponse [ option ] ; sendWont ( option ) ; } } else MST[MathMutator]MSP[N] { switch ( option ) { default: break; } } } setWill ( option ) ; }
if ( debug || debugoptions ) { System . err . println ( lr_11 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_DO ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI3Mutator]MSP[S]
for ( final int element : subn ) { final byte b = ( byte ) element ; if ( b == ( byte ) TelnetCommand . IAC ) { _output_ . write ( b ) ; } _output_ . write ( b ) ; MST[rv.UOI3Mutator]MSP[S] }
setWont ( option ) ; } void processWill ( final int option ) throws IOException MST[rv.UOI3Mutator]MSP[S] { if ( debugoptions ) { System . err . println ( lr_4 + TelnetOption . getOption ( option ) ) ; } if ( notifhand != null ) { notifhand . receivedNegotiation (
{ setWantDo ( option ) ; sendDo ( option ) ; } else { ++ doResponse [ option ] ; sendDont ( option ) ; } } setDo ( option ) ; MST[rv.ABSMutator]MSP[N] } void processWont ( final int option ) throws IOException { if ( debugoptions ) {
requestWill ( optionHandlers [ ii ] . getOptionCode () ) ; } if ( optionHandlers [ ii ] . getInitRemote () ) { requestDo ( optionHandlers [ ii ] . getOptionCode () ) ; } } } } MST[VoidMethodCallMutator]MSP[N] final synchronized void sendDo ( final int option ) throws IOException {
if ( debug ) { System . err . println ( lr_6 ) ; } if ( suboptionLength > 0 ) { if ( optionHandlers [ suboption [ 0 ] ] != null ) { final int responseSuboption [] = MST[ConditionalsBoundaryMutator]MSP[N]
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[IncrementsMutator]MSP[N] {
_output_ . write ( terminalType . getBytes ( getCharset () ) ) ; MST[rv.ROR5Mutator]MSP[N] _output_ . write ( _COMMAND_SE ) ; _output_ . flush () ; } } final synchronized void _sendSubnegotiation ( final int subn [] ) throws IOException { if ( debug ) {
for ( int ii = 0 ; ii < TelnetOption . MAX_OPTION_VALUE + 1 ; ii ++ ) { if ( optionHandlers [ ii ] != null ) { if ( optionHandlers [ ii ] . getInitLocal () ) MST[rv.UOI4Mutator]MSP[N] {
if ( notifhand != null ) { notifhand . receivedNegotiation ( TelnetNotificationHandler . RECEIVED_DO , option ) ; MST[NegateConditionalsMutator]MSP[N] } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptLocal () ; } else {
options [ option ] |= _DO_MASK ; if ( requestedDo ( option ) ) { MST[InlineConstantMutator]MSP[N] if ( optionHandlers [ option ] != null ) { optionHandlers [ option ] . setDo ( true ) ; final int subneg [] = optionHandlers [ option ] . startSubnegotiationRemote () ;
if ( willResponse [ option ] == 0 && stateIsWill ( option ) || requestedWill ( option ) ) { return ; } setWantWill ( option ) ; ++ doResponse [ option ] ; sendWill ( option ) ; } final synchronized void sendWont ( final int option ) MST[rv.ABSMutator]MSP[N]
aytFlag = true ; } else { MST[InlineConstantMutator]MSP[S] retValue = true ; } } return retValue ; } void addOptionHandler ( final TelnetOptionHandler opthand ) throws InvalidTelnetOptionException , IOException { final int optcode = opthand . getOptionCode () ; if ( TelnetOption . isValidOption ( optcode ) ) {
-- doResponse [ option ] ; if ( doResponse [ option ] > 0 && stateIsDont ( option ) ) { -- doResponse [ option ] ; } } if ( doResponse [ option ] == 0 && requestedDo ( option ) ) MST[rv.AOR4Mutator]MSP[N] { switch ( option ) { default:
TelnetNotificationHandler . RECEIVED_WILL , option ) ; } boolean acceptNewState = false ; if ( optionHandlers [ option ] != null ) { acceptNewState = optionHandlers [ option ] . getAcceptRemote () ; } if ( doResponse [ option ] > 0 ) MST[rv.UOI1Mutator]MSP[N] { -- doResponse [ option ] ;
} } } else { throw new InvalidTelnetOptionException ( lr_15 , optcode ) ; } } else { throw new InvalidTelnetOptionException ( lr_16 , optcode ) ; } } void deleteOptionHandler ( final int optcode ) MST[rv.UOI2Mutator]MSP[N] throws InvalidTelnetOptionException , IOException { if ( TelnetOption . isValidOption ( optcode ) )
throws IOException { if ( debug || debugoptions ) { System . err . println ( lr_14 + TelnetOption . getOption ( option ) ) ; } _output_ . write ( _COMMAND_WONT ) ; _output_ . write ( option ) ; _output_ . flush () ; } MST[rv.UOI3Mutator]MSP[N]
