public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[NegateConditionalsMutator]MSP[S] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getUseClientMode () ; } return false ; } public void setEnabledCipherSuites ( final String [] cipherSuites ) { MST[ReturnValsMutator]MSP[S] suites = new String [ cipherSuites . length ] ;
public void setAuthValue ( final String auth ) { MST[rv.UOI1Mutator]MSP[N] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR2Mutator]MSP[N]
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[NonVoidMethodCallMutator]MSP[N]
} public int execAUTH ( final String mechanism ) throws IOException { return sendCommand ( CMD_AUTH , mechanism ) ; } public int execADAT ( final byte [] data ) throws IOException MST[NonVoidMethodCallMutator]MSP[S] { if ( data != null ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override MST[VoidMethodCallMutator]MSP[N] protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { MST[rv.ABSMutator]MSP[N] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override MST[ReturnValsMutator]MSP[N]
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR3Mutator]MSP[N] }
public void setAuthValue ( final String auth ) { MST[InlineConstantMutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
} else if ( FTPReply . SECURITY_DATA_EXCHANGE_COMPLETE != replyCode ) { throw new SSLException ( getReplyString () ) ; } } private void initSslContext () throws IOException { if ( context == null ) { MST[NonVoidMethodCallMutator]MSP[N] context = SSLContextUtils . createSSLContext ( protocol , getKeyManager () , getTrustManager () ) ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI3Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.CRCR3Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[InlineConstantMutator]MSP[S] }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new SSLException ( getReplyString () ) ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[NonVoidMethodCallMutator]MSP[N]
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[rv.ROR5Mutator]MSP[N] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR3Mutator]MSP[S] throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR4Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
throw new IllegalArgumentException () ; MST[VoidMethodCallMutator]MSP[S] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR2Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[ReturnValsMutator]MSP[S] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; MST[ReturnValsMutator]MSP[S] } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[NonVoidMethodCallMutator]MSP[S] if ( prot == null ) {
} else if ( FTPReply . SECURITY_DATA_EXCHANGE_COMPLETE != replyCode ) { throw new SSLException ( getReplyString () ) ; } } private void initSslContext () throws IOException { if ( context == null ) { context = SSLContextUtils . createSSLContext ( protocol , getKeyManager () , getTrustManager () ) ; MST[NonVoidMethodCallMutator]MSP[N]
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR4Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
throw new IllegalArgumentException () ; MST[rv.UOI2Mutator]MSP[N] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[experimental.MemberVariableMutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI3Mutator]MSP[N] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[NegateConditionalsMutator]MSP[S] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR2Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR4Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR5Mutator]MSP[S] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[NegateConditionalsMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR5Mutator]MSP[S] }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI2Mutator]MSP[N] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( prot == null ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR4Mutator]MSP[S] if ( prot == null ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[VoidMethodCallMutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
if ( protocols != null ) { sslSocket . setEnabledProtocols ( protocols ) ; } sslSocket . startHandshake () ; } return socket ; } protected void _prepareDataSocket_ ( final Socket socket ) MST[experimental.MemberVariableMutator]MSP[N] throws IOException { } public TrustManager getTrustManager () { return trustManager ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[InlineConstantMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR4Mutator]MSP[N]
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[BooleanTrueReturnValsMutator]MSP[S] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.ABSMutator]MSP[N] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[BooleanTrueReturnValsMutator]MSP[S] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[NegateConditionalsMutator]MSP[S] throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.ABSMutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI3Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR1Mutator]MSP[S] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[rv.ROR5Mutator]MSP[S] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
public void setAuthValue ( final String auth ) { MST[rv.CRCR1Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[NegateConditionalsMutator]MSP[S] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; } public boolean isEndpointCheckingEnabled () MST[NonVoidMethodCallMutator]MSP[N] { return tlsEndpointChecking ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR5Mutator]MSP[S] throw new SSLException ( getReplyString () ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR3Mutator]MSP[S] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException MST[NonVoidMethodCallMutator]MSP[N] { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[rv.ROR5Mutator]MSP[S] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR4Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[ReturnValsMutator]MSP[S] }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR6Mutator]MSP[S] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR5Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR1Mutator]MSP[S] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[InlineConstantMutator]MSP[S] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR2Mutator]MSP[S] if ( prot == null ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[VoidMethodCallMutator]MSP[N] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
return ( ( SSLSocket ) _socket_ ) . getUseClientMode () ; } return false ; } public void setEnabledCipherSuites ( final String [] cipherSuites ) { MST[experimental.MemberVariableMutator]MSP[S] suites = new String [ cipherSuites . length ] ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[N] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
if ( ! isImplicit ) { MST[NonVoidMethodCallMutator]MSP[S] execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR5Mutator]MSP[S]
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new SSLException ( getReplyString () ) ; }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[InlineConstantMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI3Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setAuthValue ( final String auth ) { MST[VoidMethodCallMutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI2Mutator]MSP[N] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR6Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.ABSMutator]MSP[N] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR2Mutator]MSP[N] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR2Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI2Mutator]MSP[N] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI1Mutator]MSP[N] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR2Mutator]MSP[N] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR2Mutator]MSP[N] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR2Mutator]MSP[S] }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR4Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.UOI4Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR2Mutator]MSP[N] throw new SSLException ( getReplyString () ) ; }
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI3Mutator]MSP[N] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR6Mutator]MSP[S] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI2Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR6Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR2Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR5Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[ReturnValsMutator]MSP[S] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.CRCR1Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR1Mutator]MSP[S] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } setSocketFactory ( null ) ; setServerSocketFactory ( null ) ;
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR5Mutator]MSP[S] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[NonVoidMethodCallMutator]MSP[N]
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI4Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR1Mutator]MSP[S] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override MST[NullReturnValsMutator]MSP[N]
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[BooleanTrueReturnValsMutator]MSP[S] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI1Mutator]MSP[N] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI2Mutator]MSP[N] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[NonVoidMethodCallMutator]MSP[S] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
public void setAuthValue ( final String auth ) { MST[rv.ROR3Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR6Mutator]MSP[S] }
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR4Mutator]MSP[N] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR1Mutator]MSP[S] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR3Mutator]MSP[S] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[InlineConstantMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override @Deprecated MST[NonVoidMethodCallMutator]MSP[S] protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[ReturnValsMutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setAuthValue ( final String auth ) { MST[rv.CRCR6Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[InlineConstantMutator]MSP[S] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR3Mutator]MSP[S] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[NegateConditionalsMutator]MSP[S] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
} public int execAUTH ( final String mechanism ) throws IOException MST[NonVoidMethodCallMutator]MSP[S] { return sendCommand ( CMD_AUTH , mechanism ) ; } public int execADAT ( final byte [] data ) throws IOException { if ( data != null ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR5Mutator]MSP[S] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR5Mutator]MSP[S] if ( prot == null ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[N] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR3Mutator]MSP[N] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI2Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[N] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR6Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR6Mutator]MSP[S] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; } setSocketFactory ( null ) ; MST[NonVoidMethodCallMutator]MSP[N] setServerSocketFactory ( null ) ;
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new SSLException ( getReplyString () ) ; }
public void setAuthValue ( final String auth ) { MST[rv.CRCR4Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR3Mutator]MSP[S]
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[InlineConstantMutator]MSP[S] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[InlineConstantMutator]MSP[S] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[NegateConditionalsMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR5Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR3Mutator]MSP[N] if ( prot == null ) {
public int execMIC ( final byte [] data ) throws IOException MST[ArgumentPropagationMutator]MSP[S] { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.UOI4Mutator]MSP[N] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[NegateConditionalsMutator]MSP[S]
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; MST[rv.CRCR4Mutator]MSP[N] }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[NegateConditionalsMutator]MSP[S] if ( prot == null ) {
public void setAuthValue ( final String auth ) { MST[rv.UOI2Mutator]MSP[N] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[rv.ROR5Mutator]MSP[S] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[rv.CRCR5Mutator]MSP[S] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR4Mutator]MSP[S] throw new SSLException ( getReplyString () ) ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[NegateConditionalsMutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
socket . getOutputStream () , getControlEncoding () ) ) ; if ( isClientMode ) { if ( hostnameVerifier != null && ! hostnameVerifier . verify ( _hostname_ , socket . getSession () ) ) { MST[experimental.MemberVariableMutator]MSP[N] throw new SSLHandshakeException ( lr_1 ) ; } } } private KeyManager getKeyManager () {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR4Mutator]MSP[N] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; MST[NegateConditionalsMutator]MSP[S] } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) { MST[experimental.MemberVariableMutator]MSP[N]
throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[N] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
public void setAuthValue ( final String auth ) { MST[NegateConditionalsMutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR4Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[InlineConstantMutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.ABSMutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; } public boolean isEndpointCheckingEnabled () MST[NonVoidMethodCallMutator]MSP[S] { return tlsEndpointChecking ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[ReturnValsMutator]MSP[S] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR3Mutator]MSP[S] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public void setEnabledProtocols ( final String [] protocolVersions ) { MST[ReturnValsMutator]MSP[S] protocols = new String [ protocolVersions . length ] ; System . arraycopy ( protocolVersions , 0 , protocols , 0 , protocolVersions . length ) ; } public String [] getEnabledProtocols () {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[InlineConstantMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR4Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[experimental.MemberVariableMutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException MST[NonVoidMethodCallMutator]MSP[S] { if ( data != null ) { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setAuthValue ( final String auth ) { MST[rv.CRCR5Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR6Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override MST[VoidMethodCallMutator]MSP[S] protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
throw new IllegalArgumentException () ; MST[rv.UOI1Mutator]MSP[N] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.ROR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { MST[rv.CRCR5Mutator]MSP[S] this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[ReturnValsMutator]MSP[S] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { MST[rv.ROR1Mutator]MSP[S] throw new SSLException ( getReplyString () ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[rv.ROR5Mutator]MSP[S] }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR3Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( prot == null ) {
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
public void setAuthValue ( final String auth ) { this . auth = auth ; } public String getAuthValue () { MST[rv.ROR3Mutator]MSP[S] return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[ReturnValsMutator]MSP[S] }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR2Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI1Mutator]MSP[N] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
private boolean checkPROTValue ( final String prot ) { for ( final String element : PROT_COMMAND_VALUE ) { MST[NonVoidMethodCallMutator]MSP[S] if ( element . equals ( prot ) ) { return true ; } } return false ; } @Override
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[BooleanTrueReturnValsMutator]MSP[S] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
throw new IllegalArgumentException () ; MST[rv.UOI4Mutator]MSP[N] } final int status = sendCommand ( CMD_PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND_OK != status ) { throw new SSLException ( getReplyString () ) ; } }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR3Mutator]MSP[S] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
throw new SSLException ( getReplyString () ) ; } } return repCode ; } @Override MST[rv.UOI4Mutator]MSP[N] @Deprecated protected Socket _openDataConnection_ ( final int command , final String arg ) throws IOException { return _openDataConnection_ ( FTPCommand . getCommand ( command ) , arg ) ; } @Override
public void setAuthValue ( final String auth ) { MST[rv.UOI3Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public void setEndpointCheckingEnabled ( final boolean enable ) { tlsEndpointChecking = enable ; } @Override public void disconnect () throws IOException { super . disconnect () ; if ( plainSocket != null ) { plainSocket . close () ; } setSocketFactory ( null ) ; MST[NonVoidMethodCallMutator]MSP[S] setServerSocketFactory ( null ) ;
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ROR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { MST[InlineConstantMutator]MSP[S] this . isClientMode = isClientMode ; } public boolean getUseClientMode () { if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR1Mutator]MSP[N] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException MST[NonVoidMethodCallMutator]MSP[S] { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; }
if ( DEFAULT_PROT . equals ( prot ) ) { setSocketFactory ( null ) ; MST[rv.CRCR6Mutator]MSP[S] setServerSocketFactory ( null ) ; } else { setSocketFactory ( new FTPSSocketFactory ( context ) ) ; setServerSocketFactory ( new FTPSServerSocketFactory ( context ) ) ; initSslContext () ; } }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI4Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR6Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
if ( suites != null ) { socket . setEnabledCipherSuites ( suites ) ; } socket . startHandshake () ; _socket_ = socket ; MST[ReturnValsMutator]MSP[S] _controlInput_ = new BufferedReader ( new InputStreamReader ( socket . getInputStream () , getControlEncoding () ) ) ; _controlOutput_ = new BufferedWriter ( new OutputStreamWriter (
public void setTrustManager ( final TrustManager trustManager ) { this . trustManager = trustManager ; } public HostnameVerifier getHostnameVerifier () MST[NonVoidMethodCallMutator]MSP[S] { return hostnameVerifier ; } public void setHostnameVerifier ( final HostnameVerifier newHostnameVerifier ) { hostnameVerifier = newHostnameVerifier ; } public boolean isEndpointCheckingEnabled () { return tlsEndpointChecking ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI2Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { MST[rv.UOI1Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) MST[NonVoidMethodCallMutator]MSP[S] { return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[NegateConditionalsMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public void execPROT ( String prot ) throws SSLException , IOException { if ( prot == null ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[rv.CRCR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.ABSMutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ABSMutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { MST[rv.ROR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.ROR1Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.UOI4Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
public void setAuthValue ( final String auth ) { MST[EmptyObjectReturnValsMutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[NegateConditionalsMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[rv.CRCR1Mutator]MSP[S] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
public void setAuthValue ( final String auth ) { MST[rv.CRCR2Mutator]MSP[S] this . auth = auth ; } public String getAuthValue () { return this . auth ; } @Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { sslNegotiation () ; } super . _connectAction_ () ;
return sendCommand ( CMD_ADAT , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_ADAT ) ; } public int execCCC () throws IOException { final int repCode = sendCommand ( CMD_CCC ) ; return repCode ; MST[NegateConditionalsMutator]MSP[S] }
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) { MST[rv.ROR1Mutator]MSP[S]
if ( suites != null ) { socket . setEnabledCipherSuites ( suites ) ; } socket . startHandshake () ; _socket_ = socket ; MST[NullReturnValsMutator]MSP[N] _controlInput_ = new BufferedReader ( new InputStreamReader ( socket . getInputStream () , getControlEncoding () ) ) ; _controlOutput_ = new BufferedWriter ( new OutputStreamWriter (
} else if ( FTPReply . SECURITY_DATA_EXCHANGE_COMPLETE != replyCode ) { throw new SSLException ( getReplyString () ) ; } } private void initSslContext () throws IOException { MST[VoidMethodCallMutator]MSP[N] if ( context == null ) { context = SSLContextUtils . createSSLContext ( protocol , getKeyManager () , getTrustManager () ) ;
final long replysz = Long . parseLong ( remainder ) ; if ( replysz < minvalue ) { minvalue = replysz ; } } return minvalue ; } public void execPROT ( String prot ) throws SSLException , IOException { MST[rv.ROR1Mutator]MSP[S] if ( prot == null ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.CRCR1Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
prot = DEFAULT_PROT ; } if ( ! checkPROTValue ( prot ) ) { throw new IllegalArgumentException () ; MST[rv.UOI3Mutator]MSP[S] } if ( FTPReply . COMMAND_OK != sendCommand ( CMD_PROT , prot ) ) { throw new SSLException ( getReplyString () ) ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
public int execMIC ( final byte [] data ) throws IOException { if ( data != null ) { MST[rv.ROR2Mutator]MSP[S] return sendCommand ( CMD_MIC , Base64 . encodeBase64StringUnChunked ( data ) ) ; } return sendCommand ( CMD_MIC , lr_3 ) ; }
return ( ( SSLSocket ) _socket_ ) . getEnableSessionCreation () ; } return false ; } public void setNeedClientAuth ( final boolean isNeedClientAuth ) { this . isNeedClientAuth = isNeedClientAuth ; } public boolean getNeedClientAuth () { MST[rv.UOI1Mutator]MSP[N] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[experimental.MemberVariableMutator]MSP[N] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () { MST[rv.ROR5Mutator]MSP[S] if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; }
if ( ! isImplicit ) { execAUTH () ; sslNegotiation () ; } } protected void execAUTH () throws SSLException , IOException { final int replyCode = sendCommand ( CMD_AUTH , auth ) ; MST[NegateConditionalsMutator]MSP[N] if ( FTPReply . SECURITY_MECHANISM_IS_OK == replyCode ) {
return ( ( SSLSocket ) _socket_ ) . getWantClientAuth () ; } return false ; } public void setUseClientMode ( final boolean isClientMode ) { this . isClientMode = isClientMode ; } public boolean getUseClientMode () { MST[experimental.MemberVariableMutator]MSP[S] if ( _socket_ instanceof SSLSocket ) {
return ( ( SSLSocket ) _socket_ ) . getNeedClientAuth () ; } return false ; } public void setWantClientAuth ( final boolean isWantClientAuth ) { MST[ReturnValsMutator]MSP[S] this . isWantClientAuth = isWantClientAuth ; } public boolean getWantClientAuth () { if ( _socket_ instanceof SSLSocket ) {
return keyManager ; } public void setKeyManager ( final KeyManager keyManager ) { this . keyManager = keyManager ; MST[rv.ROR5Mutator]MSP[S] } public void setEnabledSessionCreation ( final boolean isCreation ) { this . isCreation = isCreation ; } public boolean getEnableSessionCreation () { if ( _socket_ instanceof SSLSocket ) {
