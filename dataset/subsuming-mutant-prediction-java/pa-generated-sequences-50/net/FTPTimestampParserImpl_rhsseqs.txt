if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.ABSMutator]MSP[S] working . add ( Calendar . YEAR , - 1 ) ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR3Mutator]MSP[N] } private static int indexOf ( final int calendarUnit ) {
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[NegateConditionalsMutator]MSP[N] if ( recentDateFormat != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[InlineConstantMutator]MSP[S] case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI4Mutator]MSP[N] final int value = working . get ( field ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR4Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[ArgumentPropagationMutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR2Mutator]MSP[N] return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.ABSMutator]MSP[N] } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR5Mutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI4Mutator]MSP[N] return i ; } } return 0 ; }
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ; MST[VoidMethodCallMutator]MSP[N]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR1Mutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[InlineConstantMutator]MSP[N] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR1Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR4Mutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR1Mutator]MSP[N] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[PrimitiveReturnsMutator]MSP[N] } } return 0 ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR5Mutator]MSP[N] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR5Mutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[NonVoidMethodCallMutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[rv.ROR5Mutator]MSP[N] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR5Mutator]MSP[N]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[NonVoidMethodCallMutator]MSP[N]
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[rv.ROR5Mutator]MSP[N] if ( format != null ) { if ( dfs != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI2Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI2Mutator]MSP[N] working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[NonVoidMethodCallMutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR6Mutator]MSP[N] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR3Mutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR4Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ABSMutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR4Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI3Mutator]MSP[N] final int value = working . get ( field ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR1Mutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[InlineConstantMutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( recentDateFormat != null ) {
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( format != null ) { if ( dfs != null ) { MST[experimental.MemberVariableMutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
final String languageCode = config . getServerLanguageCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR5Mutator]MSP[N]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[experimental.NakedReceiverMutator]MSP[N]
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR3Mutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[InlineConstantMutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR5Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR1Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[NegateConditionalsMutator]MSP[N] if ( format != null ) { if ( dfs != null ) {
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[ConstructorCallMutator]MSP[N]
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[rv.ROR5Mutator]MSP[N] }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR3Mutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR3Mutator]MSP[N] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI1Mutator]MSP[N] return i ; } } return 0 ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[NegateConditionalsMutator]MSP[N] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR1Mutator]MSP[S] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
final String languageCode = config . getServerLanguageCode () ; MST[NegateConditionalsMutator]MSP[N] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
hackFormatter . setLenient ( false ) ; MST[NonVoidMethodCallMutator]MSP[N] hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR4Mutator]MSP[S] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( value != 0 ) { MST[rv.UOI2Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[VoidMethodCallMutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[NullReturnValsMutator]MSP[N] return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR3Mutator]MSP[N]
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[InlineConstantMutator]MSP[N] } private static int indexOf ( final int calendarUnit ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI4Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR2Mutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NegateConditionalsMutator]MSP[N]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { MST[BooleanFalseReturnValsMutator]MSP[N] return lenientFutureDates ; }
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override MST[NonVoidMethodCallMutator]MSP[N] public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOD2Mutator]MSP[N] final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR5Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[NegateConditionalsMutator]MSP[N] }
final String languageCode = config . getServerLanguageCode () ; final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( languageCode != null ) {
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( format != null ) { if ( dfs != null ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI1Mutator]MSP[N] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR2Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
final String languageCode = config . getServerLanguageCode () ; MST[NonVoidMethodCallMutator]MSP[S] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; MST[NonVoidMethodCallMutator]MSP[N] setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI2Mutator]MSP[N] } } return 0 ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI1Mutator]MSP[N] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI4Mutator]MSP[N] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR2Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.ROR4Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[ReturnValsMutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR4Mutator]MSP[N]
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; MST[NullReturnValsMutator]MSP[N] } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR2Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI1Mutator]MSP[N]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[NegateConditionalsMutator]MSP[N]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR1Mutator]MSP[N] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[NegateConditionalsMutator]MSP[N] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR4Mutator]MSP[N] final int value = working . get ( field ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI3Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI3Mutator]MSP[N] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI1Mutator]MSP[N] final int value = working . get ( field ) ;
final String languageCode = config . getServerLanguageCode () ; final String shortmonths = config . getShortMonthNames () ; MST[NonVoidMethodCallMutator]MSP[S] if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI3Mutator]MSP[N] return i ; } } return 0 ; }
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[N] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR3Mutator]MSP[N] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI3Mutator]MSP[N] final int value = working . get ( field ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR3Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR6Mutator]MSP[N] } private static int indexOf ( final int calendarUnit ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[NonVoidMethodCallMutator]MSP[N]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR1Mutator]MSP[N] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR5Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { if ( format != null ) { if ( dfs != null ) { MST[experimental.MemberVariableMutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR6Mutator]MSP[N] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ABSMutator]MSP[N] return i ; } } return 0 ; }
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; MST[ReturnValsMutator]MSP[N] } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR6Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR4Mutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[ConstructorCallMutator]MSP[N] if ( format != null ) { if ( dfs != null ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI1Mutator]MSP[N]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[NegateConditionalsMutator]MSP[N] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI4Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[ReturnValsMutator]MSP[N] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR2Mutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR6Mutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI2Mutator]MSP[N] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[NonVoidMethodCallMutator]MSP[S] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR1Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[S] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR3Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[VoidMethodCallMutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI4Mutator]MSP[N] return i ; } } return 0 ; }
if ( value != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR5Mutator]MSP[S] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI1Mutator]MSP[N] working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR5Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI2Mutator]MSP[N] final int value = working . get ( field ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[VoidMethodCallMutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[VoidMethodCallMutator]MSP[N]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI3Mutator]MSP[N] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ABSMutator]MSP[N] return i ; } } return 0 ; }
if ( value != 0 ) { MST[rv.ROR3Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[VoidMethodCallMutator]MSP[N]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { MST[ReturnValsMutator]MSP[S] return lenientFutureDates ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR5Mutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[experimental.NakedReceiverMutator]MSP[S]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR3Mutator]MSP[N]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR6Mutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR1Mutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR5Mutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[NonVoidMethodCallMutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[InlineConstantMutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR6Mutator]MSP[N] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR2Mutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR1Mutator]MSP[N] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[NonVoidMethodCallMutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
if ( value != 0 ) { } else { working . clear ( field ) ; MST[VoidMethodCallMutator]MSP[N] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI4Mutator]MSP[N] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR5Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[InlineConstantMutator]MSP[N]
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.ABSMutator]MSP[N]
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[ReturnValsMutator]MSP[N] return parseTimestamp ( timestampStr , now ) ; }
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; MST[VoidMethodCallMutator]MSP[N] } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[ArgumentPropagationMutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[NonVoidMethodCallMutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NegateConditionalsMutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR1Mutator]MSP[N] final int value = working . get ( field ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR6Mutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR3Mutator]MSP[N] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[InlineConstantMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
} else { MST[NonVoidMethodCallMutator]MSP[S] this . recentDateFormat = null ; } this . recentDateSmallestUnitIndex = getEntry ( this . recentDateFormat ) ; } public String [] getShortMonths () { return defaultDateFormat . getDateFormatSymbols () . getShortMonths () ; } public TimeZone getServerTimeZone () {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR2Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI4Mutator]MSP[N]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[InlineConstantMutator]MSP[N] final int value = working . get ( field ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI1Mutator]MSP[N] } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI1Mutator]MSP[N] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[NegateConditionalsMutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[experimental.MemberVariableMutator]MSP[N]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[MathMutator]MSP[N] final int value = working . get ( field ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ABSMutator]MSP[N] return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR6Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR1Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR2Mutator]MSP[N]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { MST[BooleanTrueReturnValsMutator]MSP[S] return lenientFutureDates ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[rv.ROR5Mutator]MSP[N] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[experimental.NakedReceiverMutator]MSP[N]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI1Mutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
} else { MST[experimental.MemberVariableMutator]MSP[S] this . recentDateFormat = null ; } this . recentDateSmallestUnitIndex = getEntry ( this . recentDateFormat ) ; } public String [] getShortMonths () { return defaultDateFormat . getDateFormatSymbols () . getShortMonths () ; } public TimeZone getServerTimeZone () {
if ( format != null ) { if ( dfs != null ) { MST[ConstructorCallMutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR6Mutator]MSP[S] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ABSMutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[VoidMethodCallMutator]MSP[N] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR5Mutator]MSP[N] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[ArgumentPropagationMutator]MSP[N] return parseTimestamp ( timestampStr , now ) ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[rv.ROR5Mutator]MSP[N] if ( recentDateFormat != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI1Mutator]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[PrimitiveReturnsMutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR1Mutator]MSP[S] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR5Mutator]MSP[N] } private static int indexOf ( final int calendarUnit ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI2Mutator]MSP[N] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI2Mutator]MSP[N] final int value = working . get ( field ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[ArgumentPropagationMutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR4Mutator]MSP[N] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR2Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[ConstructorCallMutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[rv.CRCR1Mutator]MSP[N] } private static int indexOf ( final int calendarUnit ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.ABSMutator]MSP[N]
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[ReturnValsMutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR1Mutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ArgumentPropagationMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override MST[NonVoidMethodCallMutator]MSP[N] public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; MST[ReturnValsMutator]MSP[N] } private static int indexOf ( final int calendarUnit ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR6Mutator]MSP[N]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[NegateConditionalsMutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[rv.CRCR3Mutator]MSP[N] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[rv.CRCR3Mutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR2Mutator]MSP[N]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR3Mutator]MSP[N]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[ConstructorCallMutator]MSP[N]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[InlineConstantMutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; MST[ReturnValsMutator]MSP[N] }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR5Mutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] } final String recentFormatString = config . getRecentDateFormatStr () ; setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI4Mutator]MSP[N] working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI4Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI4Mutator]MSP[N] } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI3Mutator]MSP[N]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI3Mutator]MSP[N] return i ; } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR4Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.UOI2Mutator]MSP[N] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ; MST[VoidMethodCallMutator]MSP[N]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; MST[NonVoidMethodCallMutator]MSP[N] for( final char ch : FORMAT_CHARS . toCharArray () ) {
working . setTime ( parsed ) ; } else { throw new ParseException ( MST[ConstructorCallMutator]MSP[N] lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( value != 0 ) { MST[rv.ROR2Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR3Mutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[NonVoidMethodCallMutator]MSP[N]
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR4Mutator]MSP[N]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR2Mutator]MSP[N] final int value = working . get ( field ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( recentDateFormat != null ) {
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[VoidMethodCallMutator]MSP[N] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI2Mutator]MSP[N]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI3Mutator]MSP[N]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[InlineConstantMutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NegateConditionalsMutator]MSP[N]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[NegateConditionalsMutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override MST[VoidMethodCallMutator]MSP[N] public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; MST[NonVoidMethodCallMutator]MSP[N] if ( recentDateFormat != null ) {
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI3Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR6Mutator]MSP[N] final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR2Mutator]MSP[N] final int value = working . get ( field ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[ReturnValsMutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI1Mutator]MSP[N] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[N] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI3Mutator]MSP[N] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR6Mutator]MSP[S] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[ArgumentPropagationMutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.UOI1Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[rv.ROR5Mutator]MSP[N]
if ( value != 0 ) { } else { working . clear ( field ) ; MST[rv.ABSMutator]MSP[N] } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[InlineConstantMutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.UOI4Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR1Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { MST[ArgumentPropagationMutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR3Mutator]MSP[N] final int value = working . get ( field ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI2Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_5]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_4]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR4Mutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_3]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( format != null ) { if ( dfs != null ) {
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR1Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR5Mutator]MSP[N] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI2Mutator]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { MST[NonVoidMethodCallMutator]MSP[S] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR6Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.ABSMutator]MSP[N]
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.ABSMutator]MSP[N] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[InlineConstantMutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR3Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR5Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( value != 0 ) { MST[rv.ROR1Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ConstructorCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR5Mutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[PrimitiveReturnsMutator]MSP[N]
if ( defaultFormatString == null ) { throw new IllegalArgumentException ( lr_7 ) ; } setDefaultDateFormat ( defaultFormatString , dfs ) ; MST[experimental.MemberVariableMutator]MSP[N] setServerTimeZone ( config . getServerTimeZoneId () ) ; this . lenientFutureDates = config . isLenientFutureDates () ; } boolean isLenientFutureDates () { return lenientFutureDates ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[VoidMethodCallMutator]MSP[S] working . add ( Calendar . YEAR , - 1 ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( value != 0 ) { } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; MST[NonVoidMethodCallMutator]MSP[N] return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR5Mutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR4Mutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI1Mutator]MSP[N] return i ; } } return 0 ; }
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.ABSMutator]MSP[N] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[NegateConditionalsMutator]MSP[N]
if ( value != 0 ) { MST[NegateConditionalsMutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[NegateConditionalsMutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.ROR5Mutator]MSP[N] return i ; } } return 0 ; }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.ROR1Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return i ; } } return 0 ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; MST[NullReturnValsMutator]MSP[N] }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR6Mutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR2Mutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( format != null ) { if ( dfs != null ) { this . recentDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[rv.CRCR6Mutator]MSP[N] this . recentDateFormat = new SimpleDateFormat ( format ) ; } this . recentDateFormat . setLenient ( false ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI3Mutator]MSP[N]
if ( value != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI2Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[InlineConstantMutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[VoidMethodCallMutator]MSP[N] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[rv.CRCR4Mutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR4Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR2Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; setRecentDateFormat ( recentFormatString , dfs ) ; MST[ConstructorCallMutator]MSP[S] final String defaultFormatString = config . getDefaultDateFormatStr () ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
working . setTime ( parsed ) ; } else { throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , MST[rv.UOI4Mutator]MSP[N] pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { MST[VoidMethodCallMutator]MSP[N] serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[NegateConditionalsMutator]MSP[N] return i ; } } return 0 ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[rv.UOI3Mutator]MSP[N] } } return 0 ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI2Mutator]MSP[N]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[rv.ROR5Mutator]MSP[N]
if ( value != 0 ) { MST[rv.ABSMutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { MST[VoidMethodCallMutator]MSP[N] this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { this . defaultDateFormat = null ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ConstructorCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR4Mutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
this . defaultDateFormat . setTimeZone ( serverTimeZone ) ; if ( this . recentDateFormat != null ) { this . recentDateFormat . setTimeZone ( serverTimeZone ) ; } } @Override MST[NonVoidMethodCallMutator]MSP[N] public void configure ( final FTPClientConfig config ) { DateFormatSymbols dfs = null ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; MST[ReturnValsMutator]MSP[N] } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.CRCR4Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[NegateConditionalsMutator]MSP[N] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI3Mutator]MSP[N]
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[NonVoidMethodCallMutator]MSP[N] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) { MST[rv.ROR2Mutator]MSP[N]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[InlineConstantMutator]MSP[N] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; MST[rv.CRCR3Mutator]MSP[N] } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) {
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[PrimitiveReturnsMutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR4Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[ConstructorCallMutator]MSP[N]
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.UOI1Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI3Mutator]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[rv.CRCR6Mutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[ConstructorCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; final String timeStampStrPlusYear = timestampStr + lr_2 + year ; MST[InlineConstantMutator]MSP[N] final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[InlineConstantMutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[VoidMethodCallMutator]MSP[S] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.ABSMutator]MSP[N] final int value = working . get ( field ) ;
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR2Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[NonVoidMethodCallMutator]MSP[S] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
if ( value != 0 ) { MST[rv.UOI3Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[experimental.MemberVariableMutator]MSP[N] if ( format != null ) { if ( dfs != null ) {
final String languageCode = config . getServerLanguageCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
public SimpleDateFormat getDefaultDateFormat () { return defaultDateFormat ; } public String getDefaultDateFormatString () { return defaultDateFormat . toPattern () ; } private void setDefaultDateFormat ( final String format , final DateFormatSymbols dfs ) { if ( format != null ) { if ( dfs != null ) { MST[ConstructorCallMutator]MSP[N]
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[VoidMethodCallMutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[rv.ROR5Mutator]MSP[N]
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI4Mutator]MSP[N]
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[rv.ROR5Mutator]MSP[N] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.CRCR5Mutator]MSP[N] final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR3Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.UOI4Mutator]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
dfs = FTPClientConfig . lookupDateFormatSymbols ( languageCode ) ; } else { dfs = FTPClientConfig . lookupDateFormatSymbols ( lr_6 ) ; } final String recentFormatString = config . getRecentDateFormatStr () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] setRecentDateFormat ( recentFormatString , dfs ) ; final String defaultFormatString = config . getDefaultDateFormatStr () ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[experimental.SwitchMutator]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
working . setTime ( parsed ) ; } else { throw new ParseException ( MST[NonVoidMethodCallMutator]MSP[N] lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { MST[experimental.MemberVariableMutator]MSP[N] this . defaultDateFormat = null ; }
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { if ( calendarUnit == CALENDAR_UNITS [ i ] ) { MST[rv.UOI2Mutator]MSP[N] return i ; } } return 0 ; }
if ( pattern . indexOf ( ch ) != - 1 ) { MST[rv.ROR5Mutator]MSP[N] switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { MST[rv.ABSMutator]MSP[N] case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.ROR3Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ; MST[rv.UOI1Mutator]MSP[N]
this . defaultDateFormat = new SimpleDateFormat ( format , dfs ) ; } else { this . defaultDateFormat = new SimpleDateFormat ( format ) ; } this . defaultDateFormat . setLenient ( false ) ; } else { MST[NonVoidMethodCallMutator]MSP[N] this . defaultDateFormat = null ; }
case 'H' : return indexOf ( Calendar . HOUR_OF_DAY ) ; case 'd' : return indexOf ( Calendar . DAY_OF_MONTH ) ; MST[PrimitiveReturnsMutator]MSP[N] case 'M' : return indexOf ( Calendar . MONTH ) ; } } } return 0 ; } private static int indexOf ( final int calendarUnit ) {
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.UOI4Mutator]MSP[N] final int value = working . get ( field ) ;
final String languageCode = config . getServerLanguageCode () ; MST[rv.ROR5Mutator]MSP[N] final String shortmonths = config . getShortMonthNames () ; if ( shortmonths != null ) { dfs = FTPClientConfig . getDateFormatSymbols ( shortmonths ) ; } else if ( languageCode != null ) {
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { MST[rv.CRCR2Mutator]MSP[N] working . setTime ( parsed ) ; if ( working . after ( now ) ) { working . add ( Calendar . YEAR , - 1 ) ; }
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.ABSMutator]MSP[N]
int i ; for( i = 0 ; i < CALENDAR_UNITS . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( calendarUnit == CALENDAR_UNITS [ i ] ) { return i ; } } return 0 ; }
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[rv.ROR3Mutator]MSP[S] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; }
if ( value != 0 ) { MST[rv.ROR5Mutator]MSP[N] } else { working . clear ( field ) ; } } @Override public Calendar parseTimestamp ( final String timestampStr ) throws ParseException { final Calendar now = Calendar . getInstance () ; return parseTimestamp ( timestampStr , now ) ; }
setPrecision ( recentDateSmallestUnitIndex , working ) ; return working ; } } final ParsePosition pp = new ParsePosition ( 0 ) ; parsed = defaultDateFormat . parse ( timestampStr , pp ) ; if ( parsed != null && pp . getIndex () == timestampStr . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[rv.CRCR3Mutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[rv.CRCR5Mutator]MSP[N]
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOR4Mutator]MSP[N] final int value = working . get ( field ) ;
working . setTime ( parsed ) ; } else { MST[experimental.NakedReceiverMutator]MSP[S] throw new ParseException ( lr_4 + timestampStr + lr_5 + serverTime . getTime () . toString () , pp . getErrorIndex () ) ; } setPrecision ( defaultDateSmallestUnitIndex , working ) ; return working ; }
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; MST[rv.CRCR1Mutator]MSP[N] case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ;
private static int getEntry ( final SimpleDateFormat dateFormat ) { if ( dateFormat == null ) { return 0 ; } final String FORMAT_CHARS = lr_1 ; final String pattern = dateFormat . toPattern () ; for( final char ch : FORMAT_CHARS . toCharArray () ) { MST[rv.UOI4Mutator]MSP[N]
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; MST[NonVoidMethodCallMutator]MSP[N] case 'm' : return indexOf ( Calendar . MINUTE ) ;
hackFormatter . setLenient ( false ) ; hackFormatter . setTimeZone ( recentDateFormat . getTimeZone () ) ; final ParsePosition pp = new ParsePosition ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] parsed = hackFormatter . parse ( timeStampStrPlusYear , pp ) ;
if ( pattern . indexOf ( ch ) != - 1 ) { switch( ch ) { case 'S' : return indexOf ( Calendar . MILLISECOND ) ; case 's' : return indexOf ( Calendar . SECOND ) ; case 'm' : return indexOf ( Calendar . MINUTE ) ; MST[ReturnValsMutator]MSP[N]
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[InlineConstantMutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
return this . defaultDateFormat . getTimeZone () ; } private void setServerTimeZone ( final String serverTimeZoneId ) { TimeZone serverTimeZone = TimeZone . getDefault () ; if ( serverTimeZoneId != null ) { serverTimeZone = TimeZone . getTimeZone ( serverTimeZoneId ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( parsed != null && pp . getIndex () == timeStampStrPlusYear . length () ) { working . setTime ( parsed ) ; if ( working . after ( now ) ) { MST[rv.UOI3Mutator]MSP[N] working . add ( Calendar . YEAR , - 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { MST[rv.UOI1Mutator]MSP[N] return; } final int field = CALENDAR_UNITS [ index - 1 ] ; final int value = working . get ( field ) ;
final Calendar now = ( Calendar ) serverTime . clone () ; now . setTimeZone ( this . getServerTimeZone () ) ; if ( lenientFutureDates ) { MST[rv.CRCR3Mutator]MSP[N] now . add ( Calendar . DAY_OF_MONTH , 1 ) ; }
private static void setPrecision ( final int index , final Calendar working ) { if ( index <= 0 ) { return; } final int field = CALENDAR_UNITS [ index - 1 ] ; MST[rv.AOD1Mutator]MSP[N] final int value = working . get ( field ) ;
final String year = Integer . toString ( now . get ( Calendar . YEAR ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final String timeStampStrPlusYear = timestampStr + lr_2 + year ; final SimpleDateFormat hackFormatter = new SimpleDateFormat ( recentDateFormat . toPattern () + lr_3 , recentDateFormat . getDateFormatSymbols () ) ;
public Calendar parseTimestamp ( final String timestampStr , final Calendar serverTime ) throws ParseException { MST[NonVoidMethodCallMutator]MSP[N] final Calendar working = ( Calendar ) serverTime . clone () ; working . setTimeZone ( getServerTimeZone () ) ; Date parsed = null ; if ( recentDateFormat != null ) {
this . defaultDateSmallestUnitIndex = getEntry ( this . defaultDateFormat ) ; } public SimpleDateFormat getRecentDateFormat () { return recentDateFormat ; } public String getRecentDateFormatString () { return recentDateFormat . toPattern () ; } private void setRecentDateFormat ( final String format , final DateFormatSymbols dfs ) { MST[experimental.MemberVariableMutator]MSP[N]
