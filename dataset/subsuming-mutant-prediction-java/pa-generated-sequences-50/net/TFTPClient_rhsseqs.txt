final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR2Mutator]MSP[S] boolean wantReply = true ; int timeouts = 0 ; do { try {
int hostPort = 0 ; int dataLength = 0 ; totalBytesReceived = 0 ; if ( mode == TFTP . ASCII_MODE ) { output = new FromNetASCIIOutputStream ( output ) ; MST[NonVoidMethodCallMutator]MSP[N] } TFTPPacket sent = new TFTPReadRequestPacket ( host , port , fileName , mode ) ;
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[InlineConstantMutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI3Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
public void sendFile ( final String fileName , final int mode , InputStream input , MST[VoidMethodCallMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] endBufferedOps () ; } }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[NegateConditionalsMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.ABSMutator]MSP[N] endBufferedOps () ; } }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.UOI4Mutator]MSP[N] } } else {
int hostPort = 0 ; int dataLength = 0 ; totalBytesReceived = 0 ; MST[rv.CRCR1Mutator]MSP[N] if ( mode == TFTP . ASCII_MODE ) { output = new FromNetASCIIOutputStream ( output ) ; } TFTPPacket sent = new TFTPReadRequestPacket ( host , port , fileName , mode ) ;
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI2Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ABSMutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) { MST[rv.UOI1Mutator]MSP[N]
public void sendFile ( final String fileName , final int mode , final InputStream input , final String hostname , final int port ) MST[rv.CRCR5Mutator]MSP[S] throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , port ) ; }
final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress , recdPort , MST[rv.CRCR1Mutator]MSP[S] TFTPErrorPacket . UNKNOWN_TID , lr_9 ) ; bufferedSend ( error ) ; } } catch ( final SocketException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.CRCR4Mutator]MSP[N] } } else {
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: MST[experimental.RemoveIncrementsMutator]MSP[N] throw new IOException ( lr_7 + received . getType () + lr_8 ) ; } } else {
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.ROR1Mutator]MSP[N] } } else {
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR6Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } while( wantReply );
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI4Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[InlineConstantMutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI1Mutator]MSP[N] endBufferedOps () ; } }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI3Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.ROR5Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.ABSMutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.CRCR5Mutator]MSP[N] final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; boolean wantReply = true ; int timeouts = 0 ; do { MST[rv.CRCR4Mutator]MSP[N] try {
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
host = recdAddress ; data . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { MST[rv.CRCR3Mutator]MSP[N] case TFTPPacket . ERROR :
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI3Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
host = recdAddress ; data . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { MST[rv.CRCR6Mutator]MSP[N] case TFTPPacket . ERROR :
lastBlock = data . getBlockNumber () ; if ( lastBlock == block ) { try { output . write ( data . getData () , data . getDataOffset () , dataLength ) ; } catch ( final IOException e ) { error = new TFTPErrorPacket ( host , hostPort , MST[NonVoidMethodCallMutator]MSP[N]
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) MST[rv.CRCR3Mutator]MSP[N] throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) MST[rv.CRCR6Mutator]MSP[N] throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; MST[rv.CRCR1Mutator]MSP[N] if ( justStarted ) { justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.UOI4Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
final TFTPPacket received = bufferedReceive () ; MST[VoidMethodCallMutator]MSP[N] final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress , recdPort , MST[rv.CRCR6Mutator]MSP[S] TFTPErrorPacket . UNKNOWN_TID , lr_9 ) ; bufferedSend ( error ) ; } } catch ( final SocketException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.UOI3Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[rv.ABSMutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR1Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[NegateConditionalsMutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI1Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI3Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.ROR3Mutator]MSP[N] endBufferedOps () ; } }
public void setMaxTimeouts ( final int numTimeouts ) MST[rv.UOI4Mutator]MSP[S] { if ( numTimeouts < 1 ) { maxTimeouts = 1 ; } else { maxTimeouts = numTimeouts ; } } public int getMaxTimeouts () { return maxTimeouts ; } public long getTotalBytesReceived () { return totalBytesReceived ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ROR3Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[NegateConditionalsMutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
host = recdAddress ; MST[NegateConditionalsMutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[NonVoidMethodCallMutator]MSP[N] while ( dataLength > 0 &&
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR5Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[NegateConditionalsMutator]MSP[N]
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.UOI4Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI3Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.UOI2Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[ConditionalsBoundaryMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
host = recdAddress ; MST[rv.ROR3Mutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI2Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.ABSMutator]MSP[N]
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI3Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[NegateConditionalsMutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[rv.ROR2Mutator]MSP[N]
host = recdAddress ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.UOI1Mutator]MSP[N] } } else {
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR6Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) { MST[rv.UOI4Mutator]MSP[N]
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI2Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.ROR3Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.ROR1Mutator]MSP[N]
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) MST[rv.CRCR1Mutator]MSP[N] throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.ROR5Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
host = recdAddress ; data . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { MST[rv.CRCR1Mutator]MSP[N] case TFTPPacket . ERROR :
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.ROR4Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.ROR5Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; MST[rv.CRCR3Mutator]MSP[N] }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; MST[rv.CRCR6Mutator]MSP[N] if ( justStarted ) { justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.ROR4Mutator]MSP[N] } } else {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI4Mutator]MSP[N] endBufferedOps () ; } }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR5Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { MST[rv.CRCR5Mutator]MSP[N] throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } } else {
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[rv.ROR4Mutator]MSP[N] while ( dataLength > 0 &&
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.UOI3Mutator]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.CRCR4Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR1Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
public void sendFile ( final String fileName , final int mode , InputStream input , MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.CRCR3Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[rv.ROR5Mutator]MSP[N]
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; boolean wantReply = true ; int timeouts = 0 ; do { MST[InlineConstantMutator]MSP[N] try {
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[InlineConstantMutator]MSP[N] } } else {
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI1Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
final TFTPErrorPacket error = ( TFTPErrorPacket ) received ; throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] case TFTPPacket . ACKNOWLEDGEMENT : final int lastBlock = ( ( TFTPAckPacket ) received ) . getBlockNumber () ;
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[NonVoidMethodCallMutator]MSP[N]
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[NegateConditionalsMutator]MSP[N]
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI1Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] endBufferedOps () ; } }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[InlineConstantMutator]MSP[N] final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.UOI2Mutator]MSP[N] } } else {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.ROR2Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.ROR4Mutator]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI4Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
int hostPort = 0 ; int dataLength = 0 ; totalBytesReceived = 0 ; MST[rv.CRCR3Mutator]MSP[N] if ( mode == TFTP . ASCII_MODE ) { output = new FromNetASCIIOutputStream ( output ) ; } TFTPPacket sent = new TFTPReadRequestPacket ( host , port , fileName , mode ) ;
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) { MST[rv.UOI3Mutator]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.CRCR2Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ROR1Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.UOI2Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public void sendFile ( final String fileName , final int mode , InputStream input , MST[IncrementsMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.UOI1Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.ABSMutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[rv.ROR5Mutator]MSP[N]
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[rv.ROR4Mutator]MSP[N]
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) MST[NonVoidMethodCallMutator]MSP[N] {
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI1Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.ROR1Mutator]MSP[N] endBufferedOps () ; } }
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI1Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
host = recdAddress ; MST[rv.ROR2Mutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: MST[IncrementsMutator]MSP[N] throw new IOException ( lr_7 + received . getType () + lr_8 ) ; } } else {
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.ABSMutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; MST[rv.CRCR1Mutator]MSP[N] }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.CRCR3Mutator]MSP[N] final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.CRCR6Mutator]MSP[N] final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; boolean wantReply = true ; int timeouts = 0 ; do { MST[rv.CRCR2Mutator]MSP[N] try {
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : MST[experimental.RemoveSwitchMutator_0]MSP[N] final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.ROR2Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : MST[experimental.RemoveSwitchMutator_1]MSP[N] final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[rv.UOI4Mutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] while ( dataLength > 0 &&
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI1Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI3Mutator]MSP[N] endBufferedOps () ; } }
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
int hostPort = 0 ; int dataLength = 0 ; totalBytesReceived = 0 ; MST[InlineConstantMutator]MSP[N] if ( mode == TFTP . ASCII_MODE ) { output = new FromNetASCIIOutputStream ( output ) ; } TFTPPacket sent = new TFTPReadRequestPacket ( host , port , fileName , mode ) ;
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR5Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[rv.ROR2Mutator]MSP[N] while ( dataLength > 0 &&
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI3Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress , recdPort , MST[rv.CRCR3Mutator]MSP[S] TFTPErrorPacket . UNKNOWN_TID , lr_9 ) ; bufferedSend ( error ) ; } } catch ( final SocketException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , final String hostname , final int port ) MST[rv.CRCR3Mutator]MSP[S] throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , port ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , final String hostname , final int port ) MST[rv.CRCR6Mutator]MSP[S] throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , port ) ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI1Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.UOI4Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.CRCR5Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , final String hostname , final int port ) MST[InlineConstantMutator]MSP[S] throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , port ) ; }
final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress , recdPort , MST[InlineConstantMutator]MSP[S] TFTPErrorPacket . UNKNOWN_TID , lr_9 ) ; bufferedSend ( error ) ; } } catch ( final SocketException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.ROR3Mutator]MSP[N] } } else {
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.ROR3Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR3Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[InlineConstantMutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { MST[InlineConstantMutator]MSP[N] throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.ABSMutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.UOI3Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.UOI1Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI4Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
host = recdAddress ; MST[rv.ROR5Mutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.UOI2Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[NonVoidMethodCallMutator]MSP[N]
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[VoidMethodCallMutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.ROR4Mutator]MSP[N] endBufferedOps () ; } }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI4Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ROR4Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI4Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.CRCR1Mutator]MSP[N] } } else {
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.CRCR1Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
public void setMaxTimeouts ( final int numTimeouts ) MST[rv.UOI2Mutator]MSP[S] { if ( numTimeouts < 1 ) { maxTimeouts = 1 ; } else { maxTimeouts = numTimeouts ; } } public int getMaxTimeouts () { return maxTimeouts ; } public long getTotalBytesReceived () { return totalBytesReceived ; }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.UOI2Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
int hostPort = 0 ; int dataLength = 0 ; totalBytesReceived = 0 ; MST[rv.CRCR6Mutator]MSP[N] if ( mode == TFTP . ASCII_MODE ) { output = new FromNetASCIIOutputStream ( output ) ; } TFTPPacket sent = new TFTPReadRequestPacket ( host , port , fileName , mode ) ;
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.ROR3Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.CRCR1Mutator]MSP[N] final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[rv.UOI2Mutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; boolean wantReply = true ; int timeouts = 0 ; do { MST[rv.CRCR5Mutator]MSP[N] try {
host = recdAddress ; data . setAddress ( host ) ; MST[VoidMethodCallMutator]MSP[N] sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI4Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) MST[rv.CRCR4Mutator]MSP[N] throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; MST[rv.CRCR6Mutator]MSP[N] }
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.ROR2Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI4Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { MST[rv.CRCR3Mutator]MSP[N] throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
host = recdAddress ; MST[NonVoidMethodCallMutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI2Mutator]MSP[N] endBufferedOps () ; } }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR3Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.CRCR6Mutator]MSP[N] } } else {
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[ReturnValsMutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.UOI1Mutator]MSP[N]
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.UOI4Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
host = recdAddress ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ABSMutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.CRCR6Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[rv.ROR2Mutator]MSP[N]
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.ROR5Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
( bytesRead = input . read ( sendBuffer , offset , dataLength ) ) > 0 ) { offset += bytesRead ; dataLength -= bytesRead ; MST[experimental.RemoveSwitchMutator_0]MSP[N] totalThisPacket += bytesRead ; } if( totalThisPacket < TFTPPacket . SEGMENT_SIZE ) { lastAckWait = true ; }
( bytesRead = input . read ( sendBuffer , offset , dataLength ) ) > 0 ) { offset += bytesRead ; dataLength -= bytesRead ; MST[experimental.RemoveSwitchMutator_1]MSP[N] totalThisPacket += bytesRead ; } if( totalThisPacket < TFTPPacket . SEGMENT_SIZE ) { lastAckWait = true ; }
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[NonVoidMethodCallMutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR6Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.UOI2Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI4Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[InlineConstantMutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
public void setMaxTimeouts ( final int numTimeouts ) MST[rv.UOI3Mutator]MSP[S] { if ( numTimeouts < 1 ) { maxTimeouts = 1 ; } else { maxTimeouts = numTimeouts ; } } public int getMaxTimeouts () { return maxTimeouts ; } public long getTotalBytesReceived () { return totalBytesReceived ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI3Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.ROR4Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
int hostPort = 0 ; int dataLength = 0 ; totalBytesReceived = 0 ; MST[rv.CRCR5Mutator]MSP[N] if ( mode == TFTP . ASCII_MODE ) { output = new FromNetASCIIOutputStream ( output ) ; } TFTPPacket sent = new TFTPReadRequestPacket ( host , port , fileName , mode ) ;
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.ROR2Mutator]MSP[N]
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI4Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[experimental.RemoveIncrementsMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
public void sendFile ( final String fileName , final int mode , final InputStream input , final String hostname , final int port ) MST[rv.CRCR1Mutator]MSP[S] throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , port ) ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.CRCR4Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.ABSMutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
public long getTotalBytesSent () { return totalBytesSent ; } public int receiveFile ( final String fileName , final int mode , OutputStream output , InetAddress host , final int port ) throws IOException { int bytesRead = 0 ; MST[VoidMethodCallMutator]MSP[N] int lastBlock = 0 ; int block = 1 ;
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.ROR5Mutator]MSP[N] } } else {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.ABSMutator]MSP[N] endBufferedOps () ; } }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR6Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.ROR1Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress , recdPort , MST[rv.CRCR5Mutator]MSP[S] TFTPErrorPacket . UNKNOWN_TID , lr_9 ) ; bufferedSend ( error ) ; } } catch ( final SocketException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[NonVoidMethodCallMutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.ROR1Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.ROR5Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; MST[rv.CRCR4Mutator]MSP[N] }
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.ROR1Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI1Mutator]MSP[N] endBufferedOps () ; } }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR3Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { MST[rv.CRCR1Mutator]MSP[N] throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[NonVoidMethodCallMutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR1Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI1Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[rv.ROR1Mutator]MSP[N]
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[rv.ROR3Mutator]MSP[N]
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.UOI3Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
host = recdAddress ; MST[rv.ROR4Mutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) MST[InlineConstantMutator]MSP[N] throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.UOI3Mutator]MSP[N] } } else {
host = recdAddress ; data . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { MST[InlineConstantMutator]MSP[N] case TFTPPacket . ERROR :
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI3Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[rv.ROR5Mutator]MSP[N] while ( dataLength > 0 &&
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) { MST[rv.UOI2Mutator]MSP[N]
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR1Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI2Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI1Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[NonVoidMethodCallMutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[RemoveConditionalMutator_ORDER_IF]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.ROR2Mutator]MSP[N] endBufferedOps () ; } }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI2Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.ROR4Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ROR2Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[NonVoidMethodCallMutator]MSP[N] while ( dataLength > 0 &&
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.CRCR3Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.UOI2Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI3Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.ROR5Mutator]MSP[N]
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { MST[rv.CRCR6Mutator]MSP[N] throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[ArgumentPropagationMutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[rv.ROR3Mutator]MSP[N] while ( dataLength > 0 &&
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.UOI4Mutator]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI1Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; MST[rv.CRCR5Mutator]MSP[N] if ( justStarted ) { justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; boolean wantReply = true ; int timeouts = 0 ; do { MST[rv.CRCR3Mutator]MSP[N] try {
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR6Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.UOI2Mutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) MST[rv.CRCR2Mutator]MSP[N] throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.ROR4Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] while ( dataLength > 0 &&
public void sendFile ( final String fileName , final int mode , InputStream input , MST[InlineConstantMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[NegateConditionalsMutator]MSP[N] } } else {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) { MST[rv.ABSMutator]MSP[N]
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[ConstructorCallMutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { MST[rv.CRCR1Mutator]MSP[N] justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI2Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } } else {
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[NegateConditionalsMutator]MSP[N] while ( dataLength > 0 &&
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR5Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[NegateConditionalsMutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.CRCR3Mutator]MSP[N] } } else {
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[NonVoidMethodCallMutator]MSP[N]
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.UOI2Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI2Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.ABSMutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; MST[InlineConstantMutator]MSP[N] }
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.UOI3Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR4Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.UOI2Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.ABSMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.UOI4Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.UOI3Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[NegateConditionalsMutator]MSP[N] endBufferedOps () ; } }
public void setMaxTimeouts ( final int numTimeouts ) MST[rv.UOI1Mutator]MSP[S] { if ( numTimeouts < 1 ) { maxTimeouts = 1 ; } else { maxTimeouts = numTimeouts ; } } public int getMaxTimeouts () { return maxTimeouts ; } public long getTotalBytesReceived () { return totalBytesReceived ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI1Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[PrimitiveReturnsMutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[NegateConditionalsMutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; if ( recdPort == port ) { MST[ConstructorCallMutator]MSP[N] final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.CRCR6Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR3Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.ABSMutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[rv.ROR1Mutator]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.UOI1Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.ROR5Mutator]MSP[N] endBufferedOps () ; } }
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; MST[NonVoidMethodCallMutator]MSP[N] } while ( true ); } finally { endBufferedOps () ; } }
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI4Mutator]MSP[N] endBufferedOps () ; } }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.ABSMutator]MSP[N] } } else {
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.ABSMutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ROR5Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[NonVoidMethodCallMutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[NonVoidMethodCallMutator]MSP[N]
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI4Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.ROR4Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; MST[rv.CRCR2Mutator]MSP[N] }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) { MST[VoidMethodCallMutator]MSP[N]
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[ArgumentPropagationMutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[rv.UOI1Mutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.ROR3Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
host = recdAddress ; data . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { MST[rv.CRCR5Mutator]MSP[N] case TFTPPacket . ERROR :
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.ABSMutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; MST[rv.ROR3Mutator]MSP[N] } ++ block ; if ( block > 65535 ) { block = 0 ; } wantReply = false ; } else { discardPackets () ;
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) MST[rv.CRCR5Mutator]MSP[N] throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; }
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[InlineConstantMutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.UOI1Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
( bytesRead = input . read ( sendBuffer , offset , dataLength ) ) > 0 ) { offset += bytesRead ; dataLength -= bytesRead ; MST[experimental.SwitchMutator]MSP[N] totalThisPacket += bytesRead ; } if( totalThisPacket < TFTPPacket . SEGMENT_SIZE ) { lastAckWait = true ; }
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[ConditionalsBoundaryMutator]MSP[N] } } else {
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.CRCR2Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.CRCR2Mutator]MSP[N] } } else {
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR5Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.ROR1Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI3Mutator]MSP[N] endBufferedOps () ; } }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.UOI2Mutator]MSP[N]
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.ABSMutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; MST[InlineConstantMutator]MSP[N] if ( justStarted ) { justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.UOI4Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[ConditionalsBoundaryMutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[NegateConditionalsMutator]MSP[N]
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.ABSMutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : MST[NonVoidMethodCallMutator]MSP[N] final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.ROR2Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[InlineConstantMutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
host = recdAddress ; MST[rv.ROR1Mutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.CRCR3Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.UOI1Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
public void setMaxTimeouts ( final int numTimeouts ) MST[rv.ABSMutator]MSP[S] { if ( numTimeouts < 1 ) { maxTimeouts = 1 ; } else { maxTimeouts = numTimeouts ; } } public int getMaxTimeouts () { return maxTimeouts ; } public long getTotalBytesReceived () { return totalBytesReceived ; }
public void sendFile ( final String fileName , final int mode , InputStream input , MST[rv.CRCR5Mutator]MSP[N] InetAddress host , final int port ) throws IOException { int block = 0 ; int hostPort = 0 ; boolean justStarted = true ; boolean lastAckWait = false ; totalBytesSent = 0L ;
host = recdAddress ; ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR : MST[rv.ROR3Mutator]MSP[N]
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[NonVoidMethodCallMutator]MSP[N]
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[ConstructorCallMutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
host = recdAddress ; MST[NonVoidMethodCallMutator]MSP[N] ack . setAddress ( host ) ; sent . setAddress ( host ) ; } } if ( host . equals ( recdAddress ) && recdPort == hostPort ) { switch ( received . getType () ) { case TFTPPacket . ERROR :
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.CRCR5Mutator]MSP[N] } } else {
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.ABSMutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
public void setMaxTimeouts ( final int numTimeouts ) MST[experimental.MemberVariableMutator]MSP[S] { if ( numTimeouts < 1 ) { maxTimeouts = 1 ; } else { maxTimeouts = numTimeouts ; } } public int getMaxTimeouts () { return maxTimeouts ; } public long getTotalBytesReceived () { return totalBytesReceived ; }
( bytesRead = input . read ( sendBuffer , offset , dataLength ) ) > 0 ) { offset += bytesRead ; dataLength -= bytesRead ; MST[NonVoidMethodCallMutator]MSP[N] totalThisPacket += bytesRead ; } if( totalThisPacket < TFTPPacket . SEGMENT_SIZE ) { lastAckWait = true ; }
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; MST[rv.ROR2Mutator]MSP[N] } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply );
TFTPErrorPacket . OUT_OF_SPACE , lr_6 ) ; bufferedSend ( error ) ; throw e ; } ++ block ; if ( block > 65535 ) { block = 0 ; MST[rv.UOI3Mutator]MSP[N] } wantReply = false ; } else { discardPackets () ;
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.ABSMutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; if ( justStarted ) { justStarted = false ; MST[rv.ROR1Mutator]MSP[N] if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; boolean wantReply = true ; int timeouts = 0 ; do { MST[rv.CRCR6Mutator]MSP[N] try {
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
public void sendFile ( final String fileName , final int mode , final InputStream input , final InetAddress host ) throws IOException { sendFile ( fileName , mode , input , host , DEFAULT_PORT ) ; MST[rv.CRCR5Mutator]MSP[N] }
final TFTPPacket received = bufferedReceive () ; final InetAddress recdAddress = received . getAddress () ; final int recdPort = received . getPort () ; MST[rv.CRCR3Mutator]MSP[N] if ( justStarted ) { justStarted = false ; if ( recdPort == port ) { final TFTPErrorPacket error = new TFTPErrorPacket ( recdAddress ,
if ( lastBlock == ( block == 0 ? 65535 : block - 1 ) ) { wantReply = false ; } } break; default: throw new IOException ( lr_7 + received . getType () + lr_8 ) ; MST[rv.ROR2Mutator]MSP[N] } } else {
public int receiveFile ( final String fileName , final int mode , final OutputStream output , MST[rv.CRCR1Mutator]MSP[S] final String hostname ) throws UnknownHostException , IOException { return receiveFile ( fileName , mode , output , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; MST[rv.UOI3Mutator]MSP[N] ack . setPort ( hostPort ) ; if( ! host . equals ( recdAddress ) ) {
} catch ( final InterruptedIOException e ) { if ( ++ timeouts >= maxTimeouts ) { throw new IOException ( lr_10 ) ; } } catch ( final TFTPPacketException e ) { throw new IOException ( lr_11 + e . getMessage () ) ; } } while( wantReply ); MST[rv.ROR4Mutator]MSP[N]
recdPort , TFTPErrorPacket . UNKNOWN_TID , lr_1 ) ; MST[rv.ABSMutator]MSP[N] bufferedSend ( error ) ; throw new IOException ( lr_2 + recdPort + lr_3 ) ; } hostPort = recdPort ; data . setPort ( hostPort ) ; if ( ! host . equals ( recdAddress ) ) {
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
TFTPErrorPacket error = ( TFTPErrorPacket ) received ; throw new IOException ( lr_4 + error . getError () + lr_5 + error . getMessage () ) ; case TFTPPacket . DATA : MST[experimental.SwitchMutator]MSP[N] final TFTPDataPacket data = ( TFTPDataPacket ) received ; dataLength = data . getDataLength () ;
final TFTPDataPacket data = new TFTPDataPacket ( host , port , 0 , sendBuffer , 4 , 0 ) ; beginBufferedOps () ; try { do { bufferedSend ( sent ) ; MST[rv.UOI1Mutator]MSP[N] boolean wantReply = true ; int timeouts = 0 ; do { try {
data . setBlockNumber ( block ) ; data . setData ( sendBuffer , 4 , totalThisPacket ) ; sent = data ; totalBytesSent += totalThisPacket ; } while ( true ); } finally { MST[rv.UOI2Mutator]MSP[N] endBufferedOps () ; } }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI4Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
public void sendFile ( final String fileName , final int mode , final InputStream input , MST[rv.UOI2Mutator]MSP[N] final String hostname ) throws UnknownHostException , IOException { sendFile ( fileName , mode , input , InetAddress . getByName ( hostname ) , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; MST[rv.ROR1Mutator]MSP[N] while ( dataLength > 0 &&
public int receiveFile ( final String fileName , final int mode , final OutputStream output , final InetAddress host ) MST[rv.UOI3Mutator]MSP[N] throws IOException { return receiveFile ( fileName , mode , output , host , DEFAULT_PORT ) ; }
if ( lastAckWait ) { break; } int dataLength = TFTPPacket . SEGMENT_SIZE ; int offset = 4 ; int totalThisPacket = 0 ; int bytesRead = 0 ; while ( dataLength > 0 && MST[rv.ROR3Mutator]MSP[N]
