buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[]
if ( modulus == 0 ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[MathMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( modulus == 0 ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI2Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[InlineConstantMutator]MSP[] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
public boolean isUrlSafe () { MST[rv.CRCR5Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[VoidMethodCallMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.OBBN2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; MST[experimental.MemberVariableMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR3Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR3Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.ABSMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[]
currentLinePos += 4 ; MST[rv.CRCR4Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR3Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.OBBN1Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.ROR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NonVoidMethodCallMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[experimental.MemberVariableMutator]MSP[]
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ReturnValsMutator]MSP[] switch ( byteToCheck ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR1Mutator]MSP[] }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[] if ( eof ) { return; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR2Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , MST[ReturnValsMutator]MSP[] isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { MST[rv.ROR4Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { MST[rv.CRCR6Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ABSMutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR3Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI1Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD1Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[InlineConstantMutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[InlineConstantMutator]MSP[] decode ( pArray , 0 , - 1 ) ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[] return bigBytes ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[ArgumentPropagationMutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR5Mutator]MSP[]
public boolean isUrlSafe () { MST[rv.ROR1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
currentLinePos += 4 ; MST[rv.AOR2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD1Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI4Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR5Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[MathMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR2Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD2Mutator]MSP[] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR6Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[InlineConstantMutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
x = ( x << 8 ) + b ; MST[IncrementsMutator]MSP[] if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR1Mutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR4Mutator]MSP[] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } } return len ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR4Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR3Mutator]MSP[] }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR3Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI1Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : MST[rv.UOI3Mutator]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[] return bigBytes ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR4Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[NonVoidMethodCallMutator]MSP[] readPos += len ; if ( readPos >= pos ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI3Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI3Mutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR5Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI3Mutator]MSP[] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[NegateConditionalsMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR1Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[NegateConditionalsMutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[] currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { MST[rv.CRCR6Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = PAD ; } break; MST[experimental.MemberVariableMutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[NullReturnValsMutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR1Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR3Mutator]MSP[] + lr_3 + maxResultSize ) ; }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR6Mutator]MSP[]
currentLinePos += 4 ; MST[InlineConstantMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR5Mutator]MSP[]
if ( buffer != buf ) { MST[rv.CRCR6Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI4Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[] currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR5Mutator]MSP[] break; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR2Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR6Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR3Mutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI4Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR6Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR1Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[ReturnValsMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR2Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( modulus == 0 ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR1Mutator]MSP[] }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI3Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI3Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI1Mutator]MSP[] x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR6Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI1Mutator]MSP[] if ( buffer != null ) {
if ( modulus == 0 ) { MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI4Mutator]MSP[] + lr_3 + maxResultSize ) ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ArgumentPropagationMutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR3Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI4Mutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOD1Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] currentLinePos = 0 ; } } } } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR4Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[] currentLinePos = 0 ; } } } } }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[] return bigBytes ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ArgumentPropagationMutator]MSP[] switch ( byteToCheck ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ABSMutator]MSP[] } } return len ; }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[NonVoidMethodCallMutator]MSP[] encode ( pArray , 0 , - 1 ) ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR6Mutator]MSP[] b += 256 ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR6Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( eof ) { return; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; MST[VoidMethodCallMutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer = null ; MST[MathMutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR2Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR1Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI2Mutator]MSP[] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR4Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[] }
byte [] buf = new byte [ ( int ) len ] ; MST[NullReturnValsMutator]MSP[] setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR1Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI4Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR3Mutator]MSP[] b += 256 ; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR4Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR4Mutator]MSP[]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[NegateConditionalsMutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.CRCR5Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR1Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.CRCR4Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[InlineConstantMutator]MSP[] b += 256 ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR6Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI2Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD1Mutator]MSP[] }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI2Mutator]MSP[] encode ( pArray , 0 , - 1 ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI4Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR5Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR6Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[InlineConstantMutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[] currentLinePos = 0 ; } } } } }
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[InlineConstantMutator]MSP[] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[IncrementsMutator]MSP[] }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
public boolean isUrlSafe () { MST[rv.CRCR1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[NegateConditionalsMutator]MSP[] break; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI1Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR3Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[experimental.MemberVariableMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[experimental.RemoveIncrementsMutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOD1Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR1Mutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR2Mutator]MSP[] } } return len ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI1Mutator]MSP[] x = ( x << 6 ) + result ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR3Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR5Mutator]MSP[] return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR3Mutator]MSP[] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { MST[ConstructorCallMutator]MSP[] if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[ConditionalsBoundaryMutator]MSP[]
if ( modulus == 0 ) { MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI2Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR2Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI3Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.UOI4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI1Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[] return bigBytes ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR6Mutator]MSP[] } switch ( modulus ) { case 1 :
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[] return bigBytes ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[]
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR3Mutator]MSP[] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI4Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[NullReturnValsMutator]MSP[] switch ( byteToCheck ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOD2Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[BooleanTrueReturnValsMutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI3Mutator]MSP[] } } return len ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[MathMutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI2Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR6Mutator]MSP[] } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR1Mutator]MSP[] } } return len ; }
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[InlineConstantMutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI4Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[MathMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[] currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI2Mutator]MSP[] }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.ABSMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR3Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( buffer != buf ) { MST[rv.CRCR6Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR3Mutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR4Mutator]MSP[] }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI4Mutator]MSP[] readPos += len ; if ( readPos >= pos ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR3Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR2Mutator]MSP[] switch ( byteToCheck ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[EmptyObjectReturnValsMutator]MSP[]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI4Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR3Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NegateConditionalsMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR3Mutator]MSP[] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI1Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI4Mutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[MathMutator]MSP[]
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[] if ( eof ) { return; }
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR4Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR6Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR4Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[InlineConstantMutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[NullReturnValsMutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI1Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[IncrementsMutator]MSP[] break; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR5Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR1Mutator]MSP[] x = x << 6 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[] for ( final byte element : arrayOctet ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[NullReturnValsMutator]MSP[]
if ( modulus == 0 ) { MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR3Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOD1Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD1Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR4Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer = null ; MST[rv.UOI1Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR5Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[InlineConstantMutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR2Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR5Mutator]MSP[] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[]
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.ABSMutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR1Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR5Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR3Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[InlineConstantMutator]MSP[] return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[InlineConstantMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI4Mutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR3Mutator]MSP[] } } } } }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR2Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI2Mutator]MSP[] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
case ' ' : case '\n' : case '\r' : MST[rv.UOI4Mutator]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.ABSMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
public boolean isUrlSafe () { MST[rv.CRCR5Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
currentLinePos += 4 ; MST[rv.AOD1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( buffer != null ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR5Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[InlineConstantMutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR1Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR6Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[experimental.MemberVariableMutator]MSP[] b += 256 ; }
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR6Mutator]MSP[] break; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[]
if ( modulus == 0 ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI3Mutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR2Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.ABSMutator]MSP[] }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI2Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( chunkSize > 0 ) { MST[NegateConditionalsMutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[MathMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI1Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[] return bigBytes ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI2Mutator]MSP[] if ( buffer != null ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[ArgumentPropagationMutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI4Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[experimental.MemberVariableMutator]MSP[] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI4Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[NegateConditionalsMutator]MSP[] x = x << 6 ;
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR5Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[] return bigBytes ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI3Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR1Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public boolean isUrlSafe () { MST[experimental.MemberVariableMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } } return len ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.UOI1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR4Mutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[MathMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR3Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( chunkSize > 0 ) { MST[rv.UOI4Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[InlineConstantMutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[NonVoidMethodCallMutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ReturnValsMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[]
buffer [ pos ++ ] = PAD ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
} int startSrc = 0 ; MST[rv.ROR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[ConditionalsBoundaryMutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR6Mutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR3Mutator]MSP[]
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.ABSMutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI1Mutator]MSP[] break; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( readPos >= pos ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR3Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR2Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[MathMutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.CRCR5Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
} int startSrc = 0 ; MST[ReturnValsMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR2Mutator]MSP[] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.OBBN3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.ABSMutator]MSP[] encode ( pArray , 0 , - 1 ) ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[InlineConstantMutator]MSP[] } } return len ; }
public boolean isUrlSafe () { MST[rv.ROR2Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR1Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI3Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR6Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.OBBN2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[ReturnValsMutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR2Mutator]MSP[] + lr_3 + maxResultSize ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR4Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI1Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[InlineConstantMutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[NegateConditionalsMutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR4Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( chunkSize > 0 ) { MST[rv.CRCR1Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR4Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR2Mutator]MSP[] }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR4Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI3Mutator]MSP[]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[]
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final byte element : arrayOctet ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI3Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.ABSMutator]MSP[] } } } } }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR4Mutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR6Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR5Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ABSMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR5Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI3Mutator]MSP[] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR3Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.ABSMutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[ReturnValsMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR3Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[EmptyObjectReturnValsMutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] for ( final byte element : arrayOctet ) {
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI3Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ABSMutator]MSP[] break; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ReturnValsMutator]MSP[] switch ( byteToCheck ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR4Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI4Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[experimental.MemberVariableMutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOD2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[InlineConstantMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR4Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD2Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI3Mutator]MSP[] + lr_3 + maxResultSize ) ; }
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[InlineConstantMutator]MSP[] }
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[InlineConstantMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR5Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR3Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[] currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; MST[rv.CRCR6Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI1Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI4Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI2Mutator]MSP[] } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR5Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , MST[NullReturnValsMutator]MSP[] isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[VoidMethodCallMutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR4Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR5Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR2Mutator]MSP[] }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { MST[rv.CRCR5Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI4Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ABSMutator]MSP[] if ( buffer != null ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR5Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public boolean isUrlSafe () { MST[rv.CRCR4Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI3Mutator]MSP[]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NegateConditionalsMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[NegateConditionalsMutator]MSP[]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR3Mutator]MSP[]
currentLinePos += 4 ; MST[InlineConstantMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR2Mutator]MSP[] x = x << 6 ;
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI2Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NullReturnValsMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR5Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR1Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR2Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD1Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI2Mutator]MSP[]
} int startSrc = 0 ; MST[rv.ABSMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NullReturnValsMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[MathMutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[rv.ROR5Mutator]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR2Mutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI3Mutator]MSP[] }
byte [] buf = new byte [ ( int ) len ] ; MST[ReturnValsMutator]MSP[] setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[ConditionalsBoundaryMutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI3Mutator]MSP[] break; }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR5Mutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR1Mutator]MSP[] if ( buffer != null ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI3Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI1Mutator]MSP[] encode ( pArray , 0 , - 1 ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR3Mutator]MSP[]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[] return bigBytes ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[]
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NonVoidMethodCallMutator]MSP[] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[]
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR1Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[NegateConditionalsMutator]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR4Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR4Mutator]MSP[] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR1Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[InlineConstantMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[InlineConstantMutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR2Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR5Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[ReturnValsMutator]MSP[] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
buffer = null ; MST[rv.AOR1Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR2Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD2Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI2Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR4Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI1Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] len += chunkSeparator . length ; } } return len ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR2Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI2Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR2Mutator]MSP[] } } return len ; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI3Mutator]MSP[] if ( buffer != null ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI3Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[] currentLinePos = 0 ; } } } } }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NonVoidMethodCallMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI1Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR3Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI1Mutator]MSP[]
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; MST[rv.UOI1Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD1Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR3Mutator]MSP[] return newStringUtf8 ( encode ( pArray ) ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[InlineConstantMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[ReturnValsMutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR5Mutator]MSP[] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; }
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI1Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI3Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR3Mutator]MSP[] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOD1Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR6Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR5Mutator]MSP[] } } return len ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR1Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI1Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI3Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI2Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR6Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[] currentLinePos = 0 ; } } } } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.ABSMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[VoidMethodCallMutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
final byte [] result = new byte [ pos ] ; MST[InlineConstantMutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
case ' ' : case '\n' : case '\r' : MST[experimental.SwitchMutator]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR5Mutator]MSP[] b += 256 ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.ABSMutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NegateConditionalsMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR6Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI4Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; }
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR1Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR4Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR4Mutator]MSP[] }
currentLinePos += 4 ; MST[InlineConstantMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR2Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer = null ; } } else { MST[experimental.MemberVariableMutator]MSP[] buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR5Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI3Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR5Mutator]MSP[] } } return len ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI4Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[NegateConditionalsMutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[InlineConstantMutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR4Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[InlineConstantMutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[InlineConstantMutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI3Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR1Mutator]MSP[]
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( buffer != null ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.UOI4Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR1Mutator]MSP[] }
public byte [] encode ( final byte [] pArray ) { MST[VoidMethodCallMutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI2Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ABSMutator]MSP[] return bigBytes ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[]
private static String newStringUtf8 ( final byte [] encode ) { MST[ArgumentPropagationMutator]MSP[] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR5Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR4Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR1Mutator]MSP[] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR6Mutator]MSP[] return newStringUtf8 ( encode ( pArray ) ) ; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[InlineConstantMutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.ABSMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR3Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR4Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[MathMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD2Mutator]MSP[] }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NullReturnValsMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[MathMutator]MSP[] b += 256 ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR5Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[BooleanTrueReturnValsMutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] bigBytes = bigInt . toByteArray () ; MST[NonVoidMethodCallMutator]MSP[] if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR6Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR4Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.CRCR2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR6Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[] currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR1Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOD2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer = null ; MST[rv.UOI4Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR3Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR2Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR3Mutator]MSP[] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI4Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
case ' ' : case '\n' : case '\r' : MST[rv.UOI2Mutator]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.ABSMutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[] return bigBytes ;
public boolean isUrlSafe () { MST[rv.CRCR3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[InlineConstantMutator]MSP[] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.ABSMutator]MSP[] }
currentLinePos += 4 ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI2Mutator]MSP[] }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[MathMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] + lr_3 + maxResultSize ) ; }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[]
currentLinePos += 4 ; MST[rv.AOR4Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR4Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI1Mutator]MSP[] if ( buffer != null ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[ConditionalsBoundaryMutator]MSP[] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR3Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[NegateConditionalsMutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR4Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[MathMutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR4Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[NegateConditionalsMutator]MSP[] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; MST[VoidMethodCallMutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
public boolean isUrlSafe () { MST[rv.CRCR6Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR3Mutator]MSP[] b += 256 ; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR2Mutator]MSP[] if ( buffer != null ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI2Mutator]MSP[] } } return len ; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR3Mutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR6Mutator]MSP[] }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI3Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR4Mutator]MSP[] switch ( byteToCheck ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR4Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR5Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[] if ( eof ) { return; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR1Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI2Mutator]MSP[] break; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[] }
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI2Mutator]MSP[] }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[MathMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
case ' ' : case '\n' : case '\r' : MST[rv.ABSMutator]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[ConstructorCallMutator]MSP[] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI3Mutator]MSP[] + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI4Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR4Mutator]MSP[]
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[rv.ROR5Mutator]MSP[] if ( readPos >= pos ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOD2Mutator]MSP[] } } return len ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[InlineConstantMutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI2Mutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR4Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[]
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR3Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( modulus == 0 ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI1Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[NullReturnValsMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI4Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; MST[rv.ABSMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI4Mutator]MSP[] x = ( x << 6 ) + result ;
public boolean isUrlSafe () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR3Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[NegateConditionalsMutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD1Mutator]MSP[] b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD1Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR5Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = PAD ; MST[rv.ROR5Mutator]MSP[] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR5Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI3Mutator]MSP[] x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[experimental.MemberVariableMutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR4Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI4Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR4Mutator]MSP[] } } return len ; }
currentLinePos += 4 ; MST[rv.AOR1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR5Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[MathMutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR6Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
currentLinePos = 0 ; MST[experimental.MemberVariableMutator]MSP[] modulus = 0 ; eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[NegateConditionalsMutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ;
} int startSrc = 0 ; MST[NegateConditionalsMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI3Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR3Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI4Mutator]MSP[] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR1Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[NonVoidMethodCallMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR5Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR3Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[] if ( eof ) { return; }
public boolean isUrlSafe () { MST[rv.CRCR3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] len += chunkSeparator . length ; } } return len ; }
} int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[InlineConstantMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.CRCR5Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR5Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR2Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR1Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR3Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[experimental.MemberVariableMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
} int startSrc = 0 ; MST[rv.ROR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public byte [] encode ( final byte [] pArray ) { MST[EmptyObjectReturnValsMutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR5Mutator]MSP[] + lr_3 + maxResultSize ) ; }
public boolean isUrlSafe () { MST[InlineConstantMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR1Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.OBBN1Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI4Mutator]MSP[] if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI3Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[] currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR3Mutator]MSP[] break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( modulus == 0 ) { MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[BooleanTrueReturnValsMutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR2Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; MST[rv.CRCR2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR4Mutator]MSP[] }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR2Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR4Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[experimental.MemberVariableMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR6Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR2Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR4Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
currentLinePos += 4 ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI3Mutator]MSP[]
currentLinePos += 4 ; MST[rv.UOI4Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[InlineConstantMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI3Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.SwitchMutator]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI4Mutator]MSP[]
buffer = null ; MST[rv.AOR2Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( modulus == 0 ) { MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ABSMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR6Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[NegateConditionalsMutator]MSP[]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR6Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
final byte [] result = new byte [ pos ] ; MST[VoidMethodCallMutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.OBBN2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
private static String newStringUtf8 ( final byte [] encode ) { MST[EmptyObjectReturnValsMutator]MSP[] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR3Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR2Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR5Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI1Mutator]MSP[] + lr_3 + maxResultSize ) ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR1Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( modulus == 0 ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR4Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR3Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[BooleanTrueReturnValsMutator]MSP[] return newStringUtf8 ( encode ( pArray ) ) ; }
currentLinePos += 4 ; MST[rv.OBBN1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.OBBN1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR2Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer != buf ) { MST[rv.CRCR5Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR6Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI3Mutator]MSP[] return bigBytes ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR3Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[NegateConditionalsMutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI1Mutator]MSP[] }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR5Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[InlineConstantMutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.ABSMutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[MathMutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI4Mutator]MSP[] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[MathMutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR4Mutator]MSP[]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[experimental.RemoveIncrementsMutator]MSP[] break; }
public boolean isUrlSafe () { MST[rv.CRCR6Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOD2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[NegateConditionalsMutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final byte [] buf = new byte [ ( int ) len ] ; MST[ReturnValsMutator]MSP[] setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[experimental.MemberVariableMutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR4Mutator]MSP[] x = x << 6 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR3Mutator]MSP[] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[] currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI1Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[MathMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI4Mutator]MSP[] }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_IF]MSP[] x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI2Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR5Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR1Mutator]MSP[] }
if ( chunkSize > 0 ) { MST[rv.ROR3Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI1Mutator]MSP[] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI1Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI3Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD1Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[NullReturnValsMutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI4Mutator]MSP[] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI4Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[InlineConstantMutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI2Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR3Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.ABSMutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR6Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR2Mutator]MSP[] b += 256 ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.ABSMutator]MSP[]
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[VoidMethodCallMutator]MSP[] } } } } }
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.ABSMutator]MSP[] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[] if ( eof ) { return; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[rv.ROR5Mutator]MSP[] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOR1Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR1Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[ConditionalsBoundaryMutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR2Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR2Mutator]MSP[]
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR6Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[] return bigBytes ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[rv.UOI3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI1Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR3Mutator]MSP[]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ABSMutator]MSP[]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI1Mutator]MSP[] x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR4Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ABSMutator]MSP[]
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI4Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR3Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR5Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[]
currentLinePos += 4 ; MST[rv.CRCR1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.ROR4Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI4Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR5Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[ArgumentPropagationMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NullReturnValsMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR4Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI1Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR2Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ABSMutator]MSP[] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR5Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] x = x << 6 ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR4Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI4Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[] return bigBytes ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI1Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
if ( buffer != buf ) { MST[rv.CRCR5Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI1Mutator]MSP[] }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; }
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR4Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR2Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR1Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR5Mutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR5Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; MST[rv.UOI4Mutator]MSP[]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR6Mutator]MSP[] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[experimental.MemberVariableMutator]MSP[] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[NegateConditionalsMutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[]
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR4Mutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR1Mutator]MSP[]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR2Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI2Mutator]MSP[]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI3Mutator]MSP[] break; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR1Mutator]MSP[] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR3Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR1Mutator]MSP[]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[] return bigBytes ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR5Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[InlineConstantMutator]MSP[] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR2Mutator]MSP[] b += 256 ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI3Mutator]MSP[] }
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN2Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[experimental.MemberVariableMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[InlineConstantMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR1Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[InlineConstantMutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR1Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI3Mutator]MSP[] } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[MathMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR1Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD1Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR3Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[ReturnValsMutator]MSP[] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR4Mutator]MSP[] }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[NegateConditionalsMutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR1Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR2Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR6Mutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[] if ( eof ) { return; }
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[ReturnValsMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI1Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR4Mutator]MSP[] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI3Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR2Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( modulus == 0 ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
currentLinePos += 4 ; MST[rv.CRCR4Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[] return bigBytes ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI1Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ABSMutator]MSP[] break; }
} int startSrc = 0 ; MST[rv.ROR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[InlineConstantMutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD2Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR3Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.ABSMutator]MSP[] }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.ABSMutator]MSP[] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ConditionalsBoundaryMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR5Mutator]MSP[] x = x << 6 ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR3Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI3Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[ConstructorCallMutator]MSP[] }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI3Mutator]MSP[] x = ( x << 6 ) + result ;
if ( buffer != buf ) { MST[VoidMethodCallMutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR1Mutator]MSP[]
if ( modulus == 0 ) { MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ABSMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI1Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI4Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[rv.CRCR5Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[] currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR2Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR3Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR3Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[experimental.SwitchMutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR3Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR1Mutator]MSP[] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR3Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI1Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[EmptyObjectReturnValsMutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI2Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI4Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[rv.CRCR1Mutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI3Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[InlineConstantMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR6Mutator]MSP[]
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( chunkSize > 0 ) { MST[rv.CRCR3Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR4Mutator]MSP[]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI4Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI1Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR5Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { MST[rv.ROR1Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI3Mutator]MSP[] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD2Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI4Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[MathMutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( eof ) { return; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI3Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[]
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[NullReturnValsMutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR1Mutator]MSP[]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR2Mutator]MSP[] break; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI3Mutator]MSP[] if ( buffer != null ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR3Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR6Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[] if ( eof ) { return; }
if ( modulus == 0 ) { MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR3Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[MathMutator]MSP[] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR1Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR2Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[ConstructorCallMutator]MSP[] switch ( byteToCheck ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[MathMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR5Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
private static String newStringUtf8 ( final byte [] encode ) { MST[ConstructorCallMutator]MSP[] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD2Mutator]MSP[] }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.ABSMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI2Mutator]MSP[] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; MST[experimental.MemberVariableMutator]MSP[] } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI2Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[]
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; MST[NonVoidMethodCallMutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[InlineConstantMutator]MSP[] } } return len ; }
if ( modulus == 0 ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR1Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[ReturnValsMutator]MSP[] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[] }
currentLinePos += 4 ; MST[rv.CRCR2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( eof ) { return; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI3Mutator]MSP[] }
} int startSrc = 0 ; MST[rv.ROR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer = null ; MST[rv.AOR3Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI2Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR3Mutator]MSP[] b += 256 ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[experimental.MemberVariableMutator]MSP[] } switch ( modulus ) { case 1 :
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOD1Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[NegateConditionalsMutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR3Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR4Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ABSMutator]MSP[] break; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[IncrementsMutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR6Mutator]MSP[]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.CRCR1Mutator]MSP[]
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR5Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.OBBN3Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR4Mutator]MSP[] if ( buffer != null ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI1Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[] return bigBytes ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR5Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final byte element : arrayOctet ) {
buffer = null ; MST[rv.AOD1Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR5Mutator]MSP[] switch ( byteToCheck ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[ReturnValsMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI3Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR5Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI4Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[NegateConditionalsMutator]MSP[] x = x << 6 ;
public boolean isUrlSafe () { MST[rv.CRCR5Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR6Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI2Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[]
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[rv.CRCR1Mutator]MSP[] return newStringUtf8 ( encode ( pArray ) ) ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR2Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI2Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR1Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR5Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR1Mutator]MSP[] b += 256 ; }
if ( buffer != buf ) { MST[VoidMethodCallMutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR6Mutator]MSP[] }
} int startSrc = 0 ; MST[MathMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[MathMutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI3Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR2Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI4Mutator]MSP[]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR2Mutator]MSP[]
final byte [] result = new byte [ pos ] ; MST[VoidMethodCallMutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI3Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[MathMutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR1Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR2Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[] currentLinePos = 0 ; } } } } }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR2Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[NonVoidMethodCallMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[]
currentLinePos += 4 ; MST[rv.UOI1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR3Mutator]MSP[] } switch ( modulus ) { case 1 :
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer = null ; MST[rv.UOI3Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[]
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR2Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI1Mutator]MSP[] readPos += len ; if ( readPos >= pos ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[ReturnValsMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI4Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR3Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[InlineConstantMutator]MSP[] } switch ( modulus ) { case 1 :
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR6Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { MST[rv.CRCR3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI1Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR3Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR3Mutator]MSP[] } } return len ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[VoidMethodCallMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( buffer != buf ) { MST[rv.CRCR3Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[] if ( eof ) { return; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI1Mutator]MSP[]
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI2Mutator]MSP[] b += 256 ; }
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR6Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public byte [] decode ( final byte [] pArray ) { MST[rv.ABSMutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI4Mutator]MSP[] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR5Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR1Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR3Mutator]MSP[] break; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR5Mutator]MSP[] } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[ReturnValsMutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[PrimitiveReturnsMutator]MSP[] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[rv.ROR5Mutator]MSP[]
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[InlineConstantMutator]MSP[] break; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[] return bigBytes ;
public boolean isUrlSafe () { MST[NegateConditionalsMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[InlineConstantMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR3Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR3Mutator]MSP[] } } return len ; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR2Mutator]MSP[] if ( eof ) { return; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR6Mutator]MSP[] b += 256 ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI1Mutator]MSP[]
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[NegateConditionalsMutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR1Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR4Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer = null ; } } else { buffer = null ; } return len ; MST[experimental.MemberVariableMutator]MSP[] } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { MST[rv.CRCR5Mutator]MSP[] final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI1Mutator]MSP[] + lr_3 + maxResultSize ) ; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR1Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[MathMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
buffer = null ; MST[rv.UOI2Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[experimental.MemberVariableMutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI4Mutator]MSP[] if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR5Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR5Mutator]MSP[] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR5Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final byte element : arrayOctet ) {
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.UOI4Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[InlineConstantMutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[]
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[ArgumentPropagationMutator]MSP[]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR4Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; MST[VoidMethodCallMutator]MSP[] if ( b == PAD ) { eof = true ; break; }
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[experimental.MemberVariableMutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI1Mutator]MSP[] return bigBytes ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[experimental.MemberVariableMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[ReturnValsMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
public boolean isUrlSafe () { MST[rv.ROR5Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[IncrementsMutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( chunkSize > 0 ) { MST[rv.UOI2Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD1Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( modulus == 0 ) { MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR4Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI4Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[MathMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[] }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI4Mutator]MSP[] currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[VoidMethodCallMutator]MSP[] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI1Mutator]MSP[] break; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[NonVoidMethodCallMutator]MSP[] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[NegateConditionalsMutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI2Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public boolean isUrlSafe () { MST[rv.UOI3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
} int startSrc = 0 ; MST[rv.UOI1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public boolean isUrlSafe () { MST[rv.CRCR1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR4Mutator]MSP[] b += 256 ; }
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI3Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR4Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[] currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final byte element : arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR3Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer = null ; MST[experimental.MemberVariableMutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI3Mutator]MSP[] x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.ABSMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR1Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI2Mutator]MSP[]
currentLinePos += 4 ; MST[rv.UOI1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR6Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[InlineConstantMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[experimental.RemoveIncrementsMutator]MSP[] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR5Mutator]MSP[] } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI4Mutator]MSP[] encode ( pArray , 0 , - 1 ) ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI1Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR5Mutator]MSP[] if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR6Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI3Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR4Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { MST[rv.UOI4Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[InlineConstantMutator]MSP[]
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR5Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
} int startSrc = 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( buffer != buf ) { MST[rv.CRCR3Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR6Mutator]MSP[]
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[ReturnValsMutator]MSP[]
currentLinePos += 4 ; MST[rv.CRCR3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI1Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI2Mutator]MSP[] currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[ConditionalsBoundaryMutator]MSP[] len += chunkSeparator . length ; } } return len ; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[InlineConstantMutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR6Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD2Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[MathMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR6Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[NonVoidMethodCallMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.UOI2Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NonVoidMethodCallMutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[MathMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR5Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR1Mutator]MSP[] }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR2Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
case ' ' : case '\n' : case '\r' : MST[rv.UOI1Mutator]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
if ( chunkSize > 0 ) { MST[rv.ABSMutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR2Mutator]MSP[]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI2Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.ROR5Mutator]MSP[]
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI1Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( modulus == 0 ) { MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR4Mutator]MSP[] } switch ( modulus ) { case 1 :
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( eof ) { return; }
buffer = null ; MST[rv.UOI4Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR6Mutator]MSP[] } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR1Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[experimental.RemoveSwitchMutator_0]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[] currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[experimental.RemoveSwitchMutator_1]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR6Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[InlineConstantMutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[NullReturnValsMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR3Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR3Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR1Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR5Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI2Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOD1Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
} int startSrc = 0 ; MST[rv.AOD2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[] currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.UOI2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI2Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[MathMutator]MSP[] } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR2Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[ArgumentPropagationMutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR1Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[InlineConstantMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; }
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[NegateConditionalsMutator]MSP[]
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR3Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI2Mutator]MSP[] readPos += len ; if ( readPos >= pos ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR1Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[ConstructorCallMutator]MSP[] }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[NegateConditionalsMutator]MSP[]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR5Mutator]MSP[]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[]
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR6Mutator]MSP[]
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[BooleanTrueReturnValsMutator]MSP[] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI1Mutator]MSP[] } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOD2Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR5Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer = null ; MST[rv.AOR4Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI3Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
} int startSrc = 0 ; MST[rv.ROR5Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI3Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR6Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[NegateConditionalsMutator]MSP[] if ( buffer != null ) {
if ( modulus == 0 ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR2Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.ABSMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[] currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[] return bigBytes ;
} int startSrc = 0 ; MST[NegateConditionalsMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.ROR4Mutator]MSP[] } } return len ; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos = 0 ; modulus = 0 ; MST[experimental.MemberVariableMutator]MSP[] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
x = ( x << 8 ) + b ; MST[experimental.RemoveIncrementsMutator]MSP[] if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI3Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR4Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[ArgumentPropagationMutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[BooleanFalseReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.ROR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.ABSMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[MathMutator]MSP[]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.ABSMutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.ABSMutator]MSP[] readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOD2Mutator]MSP[] }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[MathMutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR1Mutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD2Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR4Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR3Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
buffer = null ; MST[rv.UOI3Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { MST[ReturnValsMutator]MSP[] return newStringUtf8 ( encode ( pArray ) ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR4Mutator]MSP[] b += 256 ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR2Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
public byte [] encode ( final byte [] pArray ) { MST[rv.ABSMutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR1Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR5Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] currentLinePos = 0 ; } } } } }
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR5Mutator]MSP[]
currentLinePos += 4 ; MST[rv.CRCR1Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { MST[rv.UOI1Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ABSMutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI4Mutator]MSP[] x = ( x << 6 ) + result ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR5Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI3Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.ROR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.ABSMutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR5Mutator]MSP[] }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[rv.ROR3Mutator]MSP[]
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[InlineConstantMutator]MSP[] switch ( byteToCheck ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR1Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[] return bigBytes ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[BooleanTrueReturnValsMutator]MSP[] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI4Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR2Mutator]MSP[]
currentLinePos += 4 ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[] }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[InlineConstantMutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI1Mutator]MSP[] }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR1Mutator]MSP[] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR1Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD2Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR3Mutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR3Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[] if ( eof ) { return; }
if ( modulus == 0 ) { MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[ArgumentPropagationMutator]MSP[] readPos += len ; if ( readPos >= pos ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[NonVoidMethodCallMutator]MSP[]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI3Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR1Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
public byte [] decode ( final byte [] pArray ) { MST[VoidMethodCallMutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR2Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
if ( chunkSize > 0 ) { MST[InlineConstantMutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI2Mutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI1Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
final byte [] result = new byte [ pos ] ; readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { MST[InlineConstantMutator]MSP[]
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[NonVoidMethodCallMutator]MSP[]
} int startSrc = 0 ; MST[MathMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR2Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR6Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR2Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( modulus == 0 ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR2Mutator]MSP[] break; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI2Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR5Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI3Mutator]MSP[] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR6Mutator]MSP[] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR1Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[rv.AOR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[rv.UOI1Mutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR4Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
if ( modulus == 0 ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR2Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI4Mutator]MSP[] x = x << 6 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR2Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR6Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_IF]MSP[] x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOR3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[] return bigBytes ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR5Mutator]MSP[] } switch ( modulus ) { case 1 :
} int startSrc = 0 ; MST[rv.CRCR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[experimental.MemberVariableMutator]MSP[]
public byte [] encode ( final byte [] pArray ) { MST[ReturnValsMutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[InlineConstantMutator]MSP[] decode ( pArray , 0 , - 1 ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI4Mutator]MSP[] } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.AOD1Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI1Mutator]MSP[]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOD1Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ReturnValsMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { MST[rv.UOI3Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.ABSMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[InlineConstantMutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR5Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[InlineConstantMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.CRCR5Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR1Mutator]MSP[] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI3Mutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.OBBN1Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[NegateConditionalsMutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[InlineConstantMutator]MSP[] } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[]
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[] readPos += len ; if ( readPos >= pos ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR2Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR4Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI1Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[] currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR2Mutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR4Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.ABSMutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ABSMutator]MSP[]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR3Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR3Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[NonVoidMethodCallMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI3Mutator]MSP[]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ROR3Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR3Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOR1Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI4Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI1Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.CRCR6Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( buffer != buf ) { MST[InlineConstantMutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
} int startSrc = 0 ; MST[rv.UOI2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOD2Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.CRCR5Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[] return bigBytes ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.CRCR3Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos += 4 ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.ABSMutator]MSP[] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final byte element : arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOD2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.RemoveSwitchMutator_0]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[experimental.RemoveSwitchMutator_1]MSP[] break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
public boolean isUrlSafe () { MST[rv.ROR3Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.UOI4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI3Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[InlineConstantMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR5Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR6Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[MathMutator]MSP[] }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ABSMutator]MSP[] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR1Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[NegateConditionalsMutator]MSP[] } } return len ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI4Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
private static String newStringUtf8 ( final byte [] encode ) { MST[ReturnValsMutator]MSP[] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
} int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( modulus == 0 ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[InlineConstantMutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR4Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[ReturnValsMutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR3Mutator]MSP[] b += 256 ; }
currentLinePos += 4 ; MST[rv.OBBN2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[NegateConditionalsMutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI3Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; MST[rv.UOI3Mutator]MSP[] encode ( pArray , 0 , - 1 ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.UOI2Mutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[]
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR4Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[RemoveConditionalMutator_ORDER_IF]MSP[]
public boolean isUrlSafe () { MST[rv.CRCR1Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[NonVoidMethodCallMutator]MSP[] switch ( byteToCheck ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[MathMutator]MSP[] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR5Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; MST[NonVoidMethodCallMutator]MSP[] readPos += len ; if ( readPos >= pos ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR5Mutator]MSP[] } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; MST[rv.UOI3Mutator]MSP[]
if ( buffer != buf ) { MST[rv.CRCR1Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.CRCR1Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[experimental.MemberVariableMutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[rv.CRCR1Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.AOD2Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[EmptyObjectReturnValsMutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[MathMutator]MSP[]
buffer = null ; MST[rv.ABSMutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.ROR5Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI1Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.OBBN2Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { MST[rv.ABSMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[experimental.MemberVariableMutator]MSP[] b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[InlineConstantMutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI2Mutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR3Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.ABSMutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR3Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[InlineConstantMutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOD1Mutator]MSP[] }
public byte [] encode ( final byte [] pArray ) { MST[rv.UOI1Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ;
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR6Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( modulus == 0 ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI2Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD1Mutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[ArgumentPropagationMutator]MSP[]
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR5Mutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.OBBN3Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[InlineConstantMutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOD2Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[InlineConstantMutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.ROR2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { MST[rv.ROR5Mutator]MSP[] System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI1Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR3Mutator]MSP[] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ABSMutator]MSP[] x = x << 6 ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( eof ) { return; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { MST[NullReturnValsMutator]MSP[] return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI4Mutator]MSP[] }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR4Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.ABSMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR6Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI2Mutator]MSP[] } } } } }
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR6Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI2Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[NegateConditionalsMutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR4Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
} int startSrc = 0 ; MST[NullReturnValsMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR5Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.UOI2Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.ROR3Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR3Mutator]MSP[] x = x << 6 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR2Mutator]MSP[] x = x << 6 ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[NegateConditionalsMutator]MSP[] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[MathMutator]MSP[] b += 256 ; }
currentLinePos += 4 ; MST[rv.AOD2Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[MathMutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[] return bigBytes ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[rv.CRCR2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[BooleanFalseReturnValsMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.ROR5Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[] if ( eof ) { return; }
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) { MST[NullReturnValsMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR6Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR3Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.AOR1Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR1Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[BooleanFalseReturnValsMutator]MSP[] switch ( byteToCheck ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[] currentLinePos = 0 ; } } } } }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR3Mutator]MSP[]
} int startSrc = 0 ; MST[InlineConstantMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } switch ( modulus ) { MST[VoidMethodCallMutator]MSP[] case 1 :
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
} int startSrc = 0 ; MST[rv.ROR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI4Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[NegateConditionalsMutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
final byte [] result = new byte [ pos ] ; MST[rv.CRCR3Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI4Mutator]MSP[]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ABSMutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR4Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI3Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOR3Mutator]MSP[] }
currentLinePos = 0 ; modulus = 0 ; eof = false ; MST[rv.CRCR6Mutator]MSP[] } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[InlineConstantMutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR1Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[NegateConditionalsMutator]MSP[] len += chunkSeparator . length ; } } return len ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[ConditionalsBoundaryMutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.UOI2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) { MST[NonVoidMethodCallMutator]MSP[] return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.UOI2Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOD2Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[ArgumentPropagationMutator]MSP[]
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; if ( readPos >= pos ) { MST[rv.ABSMutator]MSP[]
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI2Mutator]MSP[] x = ( x << 6 ) + result ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.ROR2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public boolean isUrlSafe () { MST[InlineConstantMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.ABSMutator]MSP[] x = ( x << 6 ) + result ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.ROR5Mutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
public boolean isUrlSafe () { MST[InlineConstantMutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR3Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( buffer != buf ) { MST[InlineConstantMutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[ConditionalsBoundaryMutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[] if ( eof ) { return; }
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR1Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
} int startSrc = 0 ; MST[rv.ROR5Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( modulus == 0 ) { MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI1Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
} int startSrc = 0 ; MST[rv.AOR4Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[NegateConditionalsMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI4Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.AOR2Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.UOI2Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { MST[rv.CRCR5Mutator]MSP[] final byte [] smallerBuf = new byte [ pos ] ;
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR1Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
if ( chunkSize > 0 ) { MST[rv.ROR5Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[]
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[ReturnValsMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[] return bigBytes ;
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR3Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR6Mutator]MSP[]
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; MST[rv.CRCR1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI2Mutator]MSP[] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] x = x << 6 ;
if ( chunkSize > 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[NegateConditionalsMutator]MSP[] if ( readPos >= pos ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR3Mutator]MSP[] }
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = PAD ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
if ( buffer != buf ) { MST[rv.CRCR1Mutator]MSP[] readResults ( buf , 0 , buf . length ) ; } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
public boolean isUrlSafe () { MST[rv.UOI2Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI4Mutator]MSP[] break; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.AOD1Mutator]MSP[] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR6Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.ROR5Mutator]MSP[] x = x << 6 ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR2Mutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR1Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[experimental.NakedReceiverMutator]MSP[] }
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOD2Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI2Mutator]MSP[] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR2Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.UOI4Mutator]MSP[] } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOD1Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR1Mutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR2Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR4Mutator]MSP[]
private static String newStringUtf8 ( final byte [] encode ) { MST[NonVoidMethodCallMutator]MSP[] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.UOI2Mutator]MSP[] }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR2Mutator]MSP[] if ( eof ) { return; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; }
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[] return bigBytes ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[MathMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[]
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.CRCR4Mutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; readPos = 0 ; MST[rv.CRCR3Mutator]MSP[] } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI4Mutator]MSP[] }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR2Mutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[experimental.MemberVariableMutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI4Mutator]MSP[] break; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.AOR2Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ROR2Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = PAD ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[rv.AOR3Mutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI1Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.CRCR6Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI4Mutator]MSP[] }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.ABSMutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[] if ( eof ) { return; }
} int startSrc = 0 ; MST[rv.AOR1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) { MST[ReturnValsMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = PAD ; } break; MST[rv.UOI4Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR1Mutator]MSP[] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[] return bigBytes ;
public byte [] decode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final byte [] buf = new byte [ ( int ) len ] ; MST[NullReturnValsMutator]MSP[] setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR4Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[MathMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI2Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.ABSMutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.CRCR1Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI4Mutator]MSP[] } } return len ; }
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR5Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; MST[rv.UOI2Mutator]MSP[] } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ;
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR6Mutator]MSP[] switch ( byteToCheck ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR1Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[ConditionalsBoundaryMutator]MSP[] if ( buffer != null ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[rv.CRCR1Mutator]MSP[] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[PrimitiveReturnsMutator]MSP[] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR1Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.UOI3Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR1Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[rv.UOI2Mutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOD1Mutator]MSP[]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
} int startSrc = 0 ; MST[NonVoidMethodCallMutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[InlineConstantMutator]MSP[]
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[InlineConstantMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ROR3Mutator]MSP[] len += chunkSeparator . length ; } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.UOI2Mutator]MSP[]
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.UOI1Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.UOI3Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI4Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = PAD ; MST[NegateConditionalsMutator]MSP[] } break; case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR2Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.ABSMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[InlineConstantMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[rv.CRCR5Mutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
currentLinePos += 4 ; MST[rv.UOI4Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR1Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ; MST[rv.UOI1Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR1Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ConstructorCallMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[]
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[ConditionalsBoundaryMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[rv.ROR5Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ROR3Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.CRCR5Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOD1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
currentLinePos += 4 ; MST[rv.CRCR3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR4Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR3Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOD2Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { MST[rv.ABSMutator]MSP[] len += chunkSeparator . length ; } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI3Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.OBBN3Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = PAD ; } break; MST[MathMutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ABSMutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.UOI2Mutator]MSP[] if ( buffer != null ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR1Mutator]MSP[] break; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.UOI3Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.UOI3Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR4Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( chunkSize > 0 ) { MST[rv.ROR2Mutator]MSP[] final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.OBBN3Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR2Mutator]MSP[] }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.UOI2Mutator]MSP[] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
final byte [] bigBytes = bigInt . toByteArray () ; if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[] return bigBytes ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ABSMutator]MSP[] + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR4Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } private void reset () { MST[rv.ABSMutator]MSP[] buffer = null ; pos = 0 ; readPos = 0 ;
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR2Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.UOI2Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer = null ; MST[rv.ABSMutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.UOI1Mutator]MSP[] } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.CRCR4Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR1Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
} int startSrc = 0 ; MST[rv.CRCR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR1Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[MathMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ; MST[rv.CRCR5Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI1Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.CRCR5Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.CRCR4Mutator]MSP[] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ROR3Mutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR6Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[rv.AOR3Mutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
} int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[rv.CRCR1Mutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.ROR2Mutator]MSP[] for ( final byte element : arrayOctet ) {
currentLinePos += 4 ; MST[rv.AOR3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[ReturnValsMutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.CRCR3Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[IncrementsMutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[rv.ABSMutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.UOI3Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR4Mutator]MSP[] } } return len ; }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.UOI1Mutator]MSP[]
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; MST[rv.UOI1Mutator]MSP[] }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR3Mutator]MSP[] } } return len ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI4Mutator]MSP[] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
currentLinePos = 0 ; modulus = 0 ; MST[InlineConstantMutator]MSP[] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; MST[rv.CRCR1Mutator]MSP[] } } } } }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR3Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI1Mutator]MSP[] b += 256 ; }
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI1Mutator]MSP[] break; }
} int startSrc = 0 ; MST[rv.AOD1Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.UOI3Mutator]MSP[] break; }
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR1Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
if ( isBase64 ( element ) ) { return true ; MST[rv.ABSMutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return newStringUtf8 ( encodeBase64 ( binaryData , useChunking ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { MST[NonVoidMethodCallMutator]MSP[] return encodeBase64 ( binaryData , false , true ) ; } public static String encodeBase64URLSafeString ( final byte [] binaryData ) {
public byte [] decode ( final byte [] pArray ) { MST[rv.UOI1Mutator]MSP[] reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = ( pArray . length * 3 ) / 4 ;
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[InlineConstantMutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
return newStringUtf8 ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { MST[rv.CRCR6Mutator]MSP[] return encodeBase64 ( binaryData , true ) ; } public byte [] decode ( final String pArray ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.ROR4Mutator]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI4Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( buffer == null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; pos = 0 ; MST[NegateConditionalsMutator]MSP[] readPos = 0 ; } else { final byte [] b = new byte [ buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ;
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[MathMutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR2Mutator]MSP[] b += 256 ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.AOR4Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.AOD1Mutator]MSP[] } } return len ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ROR5Mutator]MSP[] for ( final byte element : arrayOctet ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.ROR5Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[] currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
} int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; MST[rv.CRCR6Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR6Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR4Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[NonVoidMethodCallMutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR3Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
currentLinePos += 4 ; MST[MathMutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_3]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_2]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : MST[rv.UOI3Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ;
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR4Mutator]MSP[] + lr_3 + maxResultSize ) ; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.UOI3Mutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.UOI3Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_1]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.UOI2Mutator]MSP[] + lr_3 + maxResultSize ) ; }
case ' ' : case '\n' : case '\r' : MST[experimental.RemoveSwitchMutator_0]MSP[] case '\t' : return true ; default : return false ; } } public String encodeToString ( final byte [] pArray ) { return newStringUtf8 ( encode ( pArray ) ) ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ;
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR6Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} int startSrc = 0 ; MST[rv.AOR2Mutator]MSP[] int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR4Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI1Mutator]MSP[] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.AOR2Mutator]MSP[] }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; MST[NegateConditionalsMutator]MSP[] } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) {
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : MST[rv.UOI2Mutator]MSP[] x = x << 6 ;
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[experimental.MemberVariableMutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ROR3Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[] currentLinePos = 0 ; } } } } }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; MST[rv.ABSMutator]MSP[] } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR3Mutator]MSP[] if ( eof ) { return; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ABSMutator]MSP[] if ( eof ) { return; }
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; MST[rv.CRCR5Mutator]MSP[] }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ROR3Mutator]MSP[] if ( buffer != null ) {
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR4Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.ABSMutator]MSP[] for ( final byte element : arrayOctet ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
buffer [ pos ++ ] = PAD ; } break; MST[rv.AOR3Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR4Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( modulus == 0 ) { buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[RemoveConditionalMutator_ORDER_IF]MSP[] + lr_3 + maxResultSize ) ; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { MST[ReturnValsMutator]MSP[] return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[]
buffer = null ; MST[rv.AOD2Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; MST[rv.ROR1Mutator]MSP[] readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { if ( eof ) { return; }
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
return new Base64 () . decode ( base64String ) ; } public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } private static boolean isWhiteSpace ( final byte byteToCheck ) { MST[rv.CRCR3Mutator]MSP[] switch ( byteToCheck ) {
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.UOI4Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR6Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; MST[rv.ROR4Mutator]MSP[] break; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI2Mutator]MSP[] if ( eof ) { return; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ABSMutator]MSP[] buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; MST[rv.CRCR3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.AOR1Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( modulus == 0 ) { MST[experimental.MemberVariableMutator]MSP[] buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ;
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOR2Mutator]MSP[] b += 256 ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ConditionalsBoundaryMutator]MSP[] for ( final byte element : arrayOctet ) {
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[NonVoidMethodCallMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[NonVoidMethodCallMutator]MSP[]
final byte [] result = new byte [ pos ] ; MST[rv.CRCR3Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[ConditionalsBoundaryMutator]MSP[] for ( final byte element : arrayOctet ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] result = new byte [ pos ] ; MST[rv.CRCR6Mutator]MSP[] readResults ( result , 0 , result . length ) ; return result ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len MST[rv.ROR1Mutator]MSP[] + lr_3 + maxResultSize ) ; }
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.AOR2Mutator]MSP[] if ( eof ) { return; }
currentLinePos += 4 ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { MST[rv.ROR5Mutator]MSP[] return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
buffer [ pos ++ ] = (byte) ( x & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[] } } } } if ( eof && modulus != 0 ) { x = x << 6 ; switch ( modulus ) { case 2 : x = x << 6 ;
if ( isBase64 ( element ) ) { return true ; MST[rv.UOI2Mutator]MSP[] } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[MathMutator]MSP[] } private void reset () { buffer = null ; pos = 0 ; readPos = 0 ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR1Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
public byte [] encode ( final byte [] pArray ) { reset () ; if ( pArray == null || pArray . length == 0 ) { return pArray ; } final long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; MST[rv.ROR3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR4Mutator]MSP[]
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.ABSMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.ROR5Mutator]MSP[] if ( eof ) { return; }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
public static BigInteger decodeInteger ( final byte [] pArray ) { MST[rv.UOI1Mutator]MSP[] return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( lr_4 ) ; }
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.CRCR3Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
public boolean isUrlSafe () { MST[rv.CRCR2Mutator]MSP[] return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
final byte [] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; MST[rv.AOR4Mutator]MSP[] decode ( pArray , 0 , - 1 ) ;
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.CRCR5Mutator]MSP[] b += 256 ; }
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR4Mutator]MSP[] buffer [ pos ++ ] = PAD ;
currentLinePos += 4 ; MST[rv.UOI4Mutator]MSP[] if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[ReturnValsMutator]MSP[]
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[rv.ABSMutator]MSP[]
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[VoidMethodCallMutator]MSP[]
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[rv.ABSMutator]MSP[] }
buffer = null ; MST[rv.UOI2Mutator]MSP[] } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () { MST[MathMutator]MSP[]
buffer [ pos ++ ] = PAD ; } break; MST[rv.CRCR6Mutator]MSP[] case 2 : buffer [ pos ++ ] = encodeTable [ ( x >> 10 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( buf , 0 , smallerBuf , 0 , pos ) ; buf = smallerBuf ; } return buf ; } private static long getEncodeLength ( final byte [] pArray , int chunkSize , final byte [] chunkSeparator ) { MST[rv.AOR1Mutator]MSP[]
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[] } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
} int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR3Mutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = encodeTable [ ( x >> 6 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ;
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
currentLinePos = 0 ; modulus = 0 ; eof = false ; } int getLineLength () { MST[rv.CRCR6Mutator]MSP[] return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } boolean hasData () { MST[rv.CRCR3Mutator]MSP[] return this . buffer != null ; } int avail () { return buffer != null ? pos - readPos : 0 ; } private void resizeBuffer () {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[InlineConstantMutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
x = ( x << 8 ) + b ; if ( 0 == modulus ) { buffer [ pos ++ ] = encodeTable [ ( x >> 18 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[]
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; MST[rv.CRCR4Mutator]MSP[] pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.UOI2Mutator]MSP[] x = ( x << 6 ) + result ;
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; MST[rv.CRCR2Mutator]MSP[] } switch ( modulus ) { case 1 :
chunkSize = ( chunkSize / 4 ) * 4 ; long len = ( pArray . length * 4 ) / 3 ; final long mod = len % 4 ; MST[rv.CRCR2Mutator]MSP[] if ( mod != 0 ) { len += 4 - mod ; }
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[rv.AOR1Mutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } public static byte [] decodeBase64 ( final String base64String ) { MST[ConstructorCallMutator]MSP[]
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; MST[InlineConstantMutator]MSP[] } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { if ( buffer != null ) {
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { modulus = ( ++ modulus ) % 4 ; MST[rv.ABSMutator]MSP[] x = ( x << 6 ) + result ;
if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR4Mutator]MSP[] modulus = ( ++ modulus ) % 4 ; x = ( x << 6 ) + result ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: MST[MathMutator]MSP[] break; } } } public static boolean isBase64 ( final byte octet ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[rv.UOI1Mutator]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
if ( buffer != buf ) { readResults ( buf , 0 , buf . length ) ; MST[rv.CRCR6Mutator]MSP[] } if ( isUrlSafe () && pos < buf . length ) { final byte [] smallerBuf = new byte [ pos ] ;
buffer [ pos ++ ] = (byte) ( ( x >> 8 ) & MASK_8BITS ) ; break; default: break; MST[rv.ABSMutator]MSP[] } } } public static boolean isBase64 ( final byte octet ) {
currentLinePos = 0 ; modulus = 0 ; MST[rv.CRCR1Mutator]MSP[] eof = false ; } int getLineLength () { return lineLength ; } byte [] getLineSeparator () { return lineSeparator . clone () ; }
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; MST[rv.ABSMutator]MSP[] len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; } } return len ; }
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.CRCR5Mutator]MSP[] buffer [ pos ++ ] = PAD ;
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { MST[rv.CRCR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; }
System . arraycopy ( buffer , 0 , b , 0 , buffer . length ) ; buffer = b ; } } int readResults ( final byte [] b , final int bPos , final int bAvail ) { MST[rv.ABSMutator]MSP[] if ( buffer != null ) {
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[experimental.MemberVariableMutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { MST[rv.CRCR1Mutator]MSP[] System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int maxResultSize ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; }
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.AOR2Mutator]MSP[] buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
return decode ( getBytesUtf8 ( pArray ) ) ; } private byte [] getBytesUtf8 ( final String pArray ) { MST[ArgumentPropagationMutator]MSP[] try { return pArray . getBytes ( lr_1 ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI4Mutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; default: break; } if ( lineLength > 0 && pos > 0 ) {
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.CRCR3Mutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.UOI1Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
return newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } public static String encodeBase64StringUnChunked ( final byte [] binaryData ) { return newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } public static String encodeBase64String ( final byte [] binaryData , final boolean useChunking ) { MST[InlineConstantMutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[rv.UOI4Mutator]MSP[] if ( eof ) { return; }
if ( chunkSize > 0 ) { final boolean lenChunksPerfectly = len % chunkSize == 0 ; len += ( len / chunkSize ) * chunkSeparator . length ; if ( ! lenChunksPerfectly ) { len += chunkSeparator . length ; MST[rv.CRCR6Mutator]MSP[] } } return len ; }
void decode ( final byte [] in , int inPos , final int inAvail ) { MST[InlineConstantMutator]MSP[] if ( eof ) { return; } if ( inAvail < 0 ) { eof = true ; } for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( buffer == null || buffer . length - pos < decodeSize ) { resizeBuffer () ; MST[rv.CRCR6Mutator]MSP[] } final byte b = in [ inPos ++ ] ; if ( b == PAD ) { eof = true ; break; }
final int len = Math . min ( avail () , bAvail ) ; if ( buffer != b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos += len ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( readPos >= pos ) {
private static String newStringUtf8 ( final byte [] encode ) { MST[NonVoidMethodCallMutator]MSP[] String str = null ; try { str = new String ( encode , lr_1 ) ; } catch ( final UnsupportedEncodingException ue ) { throw new RuntimeException ( ue ) ; } return str ; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[] for ( final byte element : arrayOctet ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.UOI1Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( isBase64 ( element ) ) { return true ; } } return false ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { MST[InlineConstantMutator]MSP[] return encodeBase64 ( binaryData , false ) ; } public static String encodeBase64String ( final byte [] binaryData ) {
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[InlineConstantMutator]MSP[] for ( final byte element : arrayOctet ) {
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[NonVoidMethodCallMutator]MSP[] for ( final byte element : arrayOctet ) {
buffer [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ pos ++ ] = PAD ; } break; MST[InlineConstantMutator]MSP[] default: break; } if ( lineLength > 0 && pos > 0 ) {
final long len = getEncodeLength ( binaryData , isChunked ? CHUNK_SIZE : 0 , isChunked ? CHUNK_SEPARATOR : EMPTY_BYTE_ARRAY ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_2 + len + lr_3 + maxResultSize ) ; MST[rv.UOI1Mutator]MSP[] }
if ( inAvail < 0 ) { eof = true ; if ( buffer == null || buffer . length - pos < encodeSize ) { MST[rv.ABSMutator]MSP[] resizeBuffer () ; } switch ( modulus ) { case 1 :
return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { MST[rv.AOR1Mutator]MSP[] int bitlen = bigInt . bitLength () ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ;
System . arraycopy ( lineSeparator , 0 , buffer , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { MST[MathMutator]MSP[] for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( eof ) { return; }
return octet == PAD || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
if ( buffer == null || buffer . length - pos < encodeSize ) { resizeBuffer () ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.AOD2Mutator]MSP[] b += 256 ; }
buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; break; case 3 : buffer [ pos ++ ] = (byte) ( ( x >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[]
if ( out != null && out . length == outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } void encode ( final byte [] in , int inPos , final int inAvail ) { MST[NegateConditionalsMutator]MSP[] if ( eof ) { return; }
buffer = null ; } } else { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } void setInitialBuffer ( final byte [] out , final int outPos , final int outAvail ) { MST[experimental.MemberVariableMutator]MSP[]
buffer [ pos ++ ] = encodeTable [ ( x >> 2 ) & MASK_6BITS ] ; buffer [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.UOI1Mutator]MSP[] buffer [ pos ++ ] = PAD ;
if ( ! isBase64 ( element ) && ! isWhiteSpace ( element ) ) { return false ; } } return true ; } private static boolean containsBase64Byte ( final byte [] arrayOctet ) { MST[rv.CRCR3Mutator]MSP[] for ( final byte element : arrayOctet ) {
