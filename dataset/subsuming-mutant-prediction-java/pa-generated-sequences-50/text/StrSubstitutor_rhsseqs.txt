substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[N] } return replace ( source , 0 , source . length () ) ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[InlineConstantMutator]MSP[N] return false ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR4Mutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
return setVariablePrefixMatcher ( StrMatcher . stringMatcher ( prefix ) ) ; } public StrMatcher getVariableSuffixMatcher () { return suffixMatcher ; } public StrSubstitutor setVariableSuffixMatcher ( final StrMatcher suffixMatcher ) { Validate . isTrue ( suffixMatcher != null , lr_6 ) ; MST[rv.ROR5Mutator]MSP[N] this . suffixMatcher = suffixMatcher ; return this ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.ABSMutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR6Mutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; return buf . toString () ; }
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
return enableSubstitutionInVariables ; MST[BooleanFalseReturnValsMutator]MSP[S] } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
return replaceIn ( source , 0 , source . length () ) ; MST[ReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
final Map < String , V > valueMap , final String prefix , final String suffix ) { return new StrSubstitutor ( valueMap , prefix , suffix ) . replace ( source ) ; MST[ReturnValsMutator]MSP[S] } public static String replace ( final Object source , final Properties valueProperties ) {
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
this . escapeChar = escapeCharacter ; } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; MST[rv.ROR5Mutator]MSP[N] this . prefixMatcher = prefixMatcher ; return this ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[rv.ROR3Mutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.ABSMutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N]
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { MST[rv.ABSMutator]MSP[N] if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.AOR3Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[InlineConstantMutator]MSP[S] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI3Mutator]MSP[N] }
if ( ! substitute ( buf , 0 , length ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
final int varLen = varValue . length () ; buf . replace ( startPos , endPos , varValue ) ; altered = true ; int change = 0 ; if ( ! substitutionInValuesDisabled ) { MST[rv.ABSMutator]MSP[S] change = substitute ( buf , startPos , varLen , priorVariables ) ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
change = change MST[rv.ABSMutator]MSP[N] + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; break; } nestedVarCount -- ;
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR3Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR3Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
final StrMatcher valueDelimMatcher = getValueDelimiterMatcher () ; MST[NonVoidMethodCallMutator]MSP[N] final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables () ; final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues () ; final boolean top = priorVariables == null ; boolean altered = false ; int lengthChange = 0 ; char [] chars = buf . buffer ;
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI3Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[rv.ABSMutator]MSP[N] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.CRCR5Mutator]MSP[N] return source ; } return buf . toString () ; }
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; MST[NullReturnValsMutator]MSP[N] } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; } public boolean isEnableSubstitutionInVariables () {
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; MST[InlineConstantMutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[ReturnValsMutator]MSP[N] }
return setVariableSuffixMatcher ( StrMatcher . stringMatcher ( suffix ) ) ; } public StrMatcher getValueDelimiterMatcher () { return valueDelimiterMatcher ; } public StrSubstitutor setValueDelimiterMatcher ( final StrMatcher valueDelimiterMatcher ) { this . valueDelimiterMatcher = valueDelimiterMatcher ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public StrSubstitutor setValueDelimiter ( final char valueDelimiter ) {
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; } return resolver . lookup ( variableName ) ; MST[ReturnValsMutator]MSP[N] } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR6Mutator]MSP[N] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[rv.UOI1Mutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOD2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[rv.UOI2Mutator]MSP[N] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.ROR1Mutator]MSP[N] return source ; } return buf . toString () ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI2Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { return source ; } return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled MST[rv.UOI1Mutator]MSP[S] && pfxMatcher . isMatch ( chars ,
public static < V > String replace ( final Object source , final Map < String , V > valueMap ) { return new StrSubstitutor ( valueMap ) . replace ( source ) ; MST[ReturnValsMutator]MSP[N] } public static < V > String replace ( final Object source ,
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[rv.ROR3Mutator]MSP[S]
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
substitute ( buf , 0 , length ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
int bufEnd = offset + length ; MST[rv.UOI4Mutator]MSP[N] int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
final String propName = ( String ) propNames . nextElement () ; final String propValue = valueProperties . getProperty ( propName ) ; valueMap . put ( propName , propValue ) ; } return StrSubstitutor . replace ( source , valueMap ) ; MST[ReturnValsMutator]MSP[S] }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI4Mutator]MSP[N] }
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.AOD2Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
return setVariablePrefixMatcher ( StrMatcher . stringMatcher ( prefix ) ) ; } public StrMatcher getVariableSuffixMatcher () { return suffixMatcher ; } public StrSubstitutor setVariableSuffixMatcher ( final StrMatcher suffixMatcher ) { Validate . isTrue ( suffixMatcher != null , lr_6 ) ; MST[NegateConditionalsMutator]MSP[N] this . suffixMatcher = suffixMatcher ; return this ;
substitute ( buf , 0 , length ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[rv.ROR3Mutator]MSP[N] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { return source ; } return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[rv.CRCR6Mutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
return setVariableSuffixMatcher ( StrMatcher . stringMatcher ( suffix ) ) ; } public StrMatcher getValueDelimiterMatcher () { return valueDelimiterMatcher ; } public StrSubstitutor setValueDelimiterMatcher ( final StrMatcher valueDelimiterMatcher ) { this . valueDelimiterMatcher = valueDelimiterMatcher ; return this ; MST[NullReturnValsMutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final char valueDelimiter ) {
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[rv.CRCR6Mutator]MSP[N] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; } return resolver . lookup ( variableName ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR3Mutator]MSP[S] }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } return replace ( source , 0 , source . length () ) ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
this . escapeChar = escapeCharacter ; } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; MST[NegateConditionalsMutator]MSP[N] this . prefixMatcher = prefixMatcher ; return this ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI1Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return substitute ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[ConstructorCallMutator]MSP[S] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[S] buf . append ( lr_2 ) ;
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[rv.CRCR3Mutator]MSP[N] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ;
final StrBuilder bufName = new StrBuilder ( varNameExpr ) ; substitute ( bufName , 0 , bufName . length () ) ; varNameExpr = bufName . toString () ; } pos += endMatchLen ; MST[rv.UOI1Mutator]MSP[S] final int endPos = pos ; String varName = varNameExpr ; String varDefaultValue = null ;
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[NegateConditionalsMutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[ReturnValsMutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
if ( valueProperties == null ) { MST[NegateConditionalsMutator]MSP[S] return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ; MST[ConstructorCallMutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
final String propName = ( String ) propNames . nextElement () ; MST[NonVoidMethodCallMutator]MSP[S] final String propValue = valueProperties . getProperty ( propName ) ; valueMap . put ( propName , propValue ) ; } return StrSubstitutor . replace ( source , valueMap ) ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } return replace ( source , 0 , source . length () ) ; }
final StrBuilder bufName = new StrBuilder ( varNameExpr ) ; substitute ( bufName , 0 , bufName . length () ) ; MST[NonVoidMethodCallMutator]MSP[S] varNameExpr = bufName . toString () ; } pos += endMatchLen ; final int endPos = pos ; String varName = varNameExpr ; String varDefaultValue = null ;
if ( valueDelimMatcher != null ) { final char [] varNameExprChars = varNameExpr . toCharArray () ; int valueDelimiterMatchLen = 0 ; for ( int i = 0 ; i < varNameExprChars . length ; i ++ ) { if ( ! substitutionInVariablesEnabled MST[rv.UOI3Mutator]MSP[N] && pfxMatcher . isMatch ( varNameExprChars ,
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[InlineConstantMutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI3Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
if ( valueProperties == null ) { MST[rv.ROR5Mutator]MSP[S] return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.AOR4Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
return setVariableSuffixMatcher ( StrMatcher . stringMatcher ( suffix ) ) ; } public StrMatcher getValueDelimiterMatcher () { return valueDelimiterMatcher ; MST[NullReturnValsMutator]MSP[N] } public StrSubstitutor setValueDelimiterMatcher ( final StrMatcher valueDelimiterMatcher ) { this . valueDelimiterMatcher = valueDelimiterMatcher ; return this ; } public StrSubstitutor setValueDelimiter ( final char valueDelimiter ) {
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.ROR3Mutator]MSP[N] }
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.UOI4Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
this . escapeChar = escapeCharacter ; } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; MST[NullReturnValsMutator]MSP[N] } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR6Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
this . escapeChar = escapeCharacter ; MST[rv.UOI3Mutator]MSP[N] } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; MST[ConstructorCallMutator]MSP[N] substitute ( buf , 0 , source . length ) ; return buf . toString () ; }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[ReturnValsMutator]MSP[N] }
final Map < String , V > valueMap , final String prefix , final String suffix ) { return new StrSubstitutor ( valueMap , prefix , suffix ) . replace ( source ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public static String replace ( final Object source , final Properties valueProperties ) {
return substitute ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR1Mutator]MSP[N] return false ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[rv.ROR5Mutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI3Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , length ) ; MST[rv.ABSMutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
int bufEnd = offset + length ; int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , MST[rv.UOI3Mutator]MSP[N] bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR3Mutator]MSP[N] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; MST[experimental.NakedReceiverMutator]MSP[S] return this ; }
private int substitute ( final StrBuilder buf , final int offset , final int length , List < String > priorVariables ) { final StrMatcher pfxMatcher = getVariablePrefixMatcher () ; final StrMatcher suffMatcher = getVariableSuffixMatcher () ; final char escape = getEscapeChar () ; MST[NonVoidMethodCallMutator]MSP[N]
substitute ( buf , 0 , length ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
return substitute ( source , 0 , source . length () ) ; MST[rv.CRCR5Mutator]MSP[S] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; MST[NullReturnValsMutator]MSP[N] }
return replaceIn ( source , 0 , source . length () ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[S] buf . append ( lr_2 ) ;
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[NegateConditionalsMutator]MSP[N] return source ; } return buf . toString () ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; MST[NullReturnValsMutator]MSP[N] } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; } public boolean isEnableSubstitutionInVariables () {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder () . append ( source ) ;
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.ROR5Mutator]MSP[N] return source ; } return buf . toString () ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ConstructorCallMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; MST[experimental.NakedReceiverMutator]MSP[N] substitute ( buf , 0 , source . length ) ; return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI2Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
pos , offset , bufEnd ) != 0 ) { endMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; nestedVarCount ++ ; pos += endMatchLen ; continue; } endMatchLen = suffMatcher . isMatch ( chars , pos , offset , MST[rv.UOI1Mutator]MSP[N] bufEnd ) ;
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[rv.UOI3Mutator]MSP[N] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
substitute ( buf , 0 , length ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR3Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , length ) ; MST[rv.UOI3Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
final int varLen = varValue . length () ; buf . replace ( startPos , endPos , varValue ) ; altered = true ; int change = 0 ; if ( ! substitutionInValuesDisabled ) { MST[rv.UOI2Mutator]MSP[N] change = substitute ( buf , startPos , varLen , priorVariables ) ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI1Mutator]MSP[N] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
change = change MST[rv.UOI2Mutator]MSP[S] + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; break; } nestedVarCount -- ;
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String replace ( final String source ) { if ( source == null ) { return null ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { MST[rv.UOI2Mutator]MSP[S] if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[rv.CRCR3Mutator]MSP[N] }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.AOD1Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; }
int bufEnd = offset + length ; MST[rv.UOI1Mutator]MSP[N] int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[InlineConstantMutator]MSP[N] }
final String propName = ( String ) propNames . nextElement () ; final String propValue = valueProperties . getProperty ( propName ) ; valueMap . put ( propName , propValue ) ; MST[ArgumentPropagationMutator]MSP[S] } return StrSubstitutor . replace ( source , valueMap ) ; }
final Map < String , V > valueMap , final String prefix , final String suffix ) { return new StrSubstitutor ( valueMap , prefix , suffix ) . replace ( source ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static String replace ( final Object source , final Properties valueProperties ) {
final StrBuilder bufName = new StrBuilder ( varNameExpr ) ; substitute ( bufName , 0 , bufName . length () ) ; varNameExpr = bufName . toString () ; } pos += endMatchLen ; MST[rv.UOI4Mutator]MSP[N] final int endPos = pos ; String varName = varNameExpr ; String varDefaultValue = null ;
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean isEnableSubstitutionInVariables () {
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled MST[rv.ABSMutator]MSP[N] && pfxMatcher . isMatch ( chars ,
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.ABSMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI4Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return enableSubstitutionInVariables ; } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; MST[rv.UOI3Mutator]MSP[S] } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
return substitute ( source , 0 , source . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; }
final String propName = ( String ) propNames . nextElement () ; final String propValue = valueProperties . getProperty ( propName ) ; MST[NonVoidMethodCallMutator]MSP[S] valueMap . put ( propName , propValue ) ; } return StrSubstitutor . replace ( source , valueMap ) ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[rv.CRCR5Mutator]MSP[N] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
substitute ( buf , 0 , length ) ; MST[rv.UOI3Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
final StrBuilder bufName = new StrBuilder ( varNameExpr ) ; substitute ( bufName , 0 , bufName . length () ) ; varNameExpr = bufName . toString () ; } pos += endMatchLen ; MST[rv.UOI3Mutator]MSP[N] final int endPos = pos ; String varName = varNameExpr ; String varDefaultValue = null ;
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR2Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return preserveEscapes ; MST[BooleanTrueReturnValsMutator]MSP[S] } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[rv.UOI4Mutator]MSP[N] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { MST[rv.UOI1Mutator]MSP[S] if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
return preserveEscapes ; } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; MST[rv.UOI3Mutator]MSP[S] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI4Mutator]MSP[N] }
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.AOD1Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
final String propName = ( String ) propNames . nextElement () ; final String propValue = valueProperties . getProperty ( propName ) ; valueMap . put ( propName , propValue ) ; } return StrSubstitutor . replace ( source , valueMap ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[S]
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR5Mutator]MSP[N] }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; MST[InlineConstantMutator]MSP[S] }
if ( ! priorVariables . contains ( varName ) ) { MST[rv.ROR3Mutator]MSP[N] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
substitute ( buf , 0 , length ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.ABSMutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ; MST[rv.ROR5Mutator]MSP[N]
if ( ! priorVariables . contains ( varName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
final int varLen = varValue . length () ; buf . replace ( startPos , endPos , varValue ) ; altered = true ; int change = 0 ; if ( ! substitutionInValuesDisabled ) { MST[rv.UOI1Mutator]MSP[N] change = substitute ( buf , startPos , varLen , priorVariables ) ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[rv.ABSMutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI3Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
substitute ( buf , 0 , length ) ; MST[rv.UOI3Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; MST[ReturnValsMutator]MSP[S] }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
change = change MST[rv.UOI1Mutator]MSP[N] + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; break; } nestedVarCount -- ;
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
public static < V > String replace ( final Object source , final Map < String , V > valueMap ) { return new StrSubstitutor ( valueMap ) . replace ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static < V > String replace ( final Object source ,
return substitute ( source , 0 , source . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] buf . append ( lr_2 ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ABSMutator]MSP[N] return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR3Mutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
if ( valueDelimMatcher != null ) { final char [] varNameExprChars = varNameExpr . toCharArray () ; int valueDelimiterMatchLen = 0 ; for ( int i = 0 ; i < varNameExprChars . length ; i ++ ) { if ( ! substitutionInVariablesEnabled MST[rv.ABSMutator]MSP[N] && pfxMatcher . isMatch ( varNameExprChars ,
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR2Mutator]MSP[N] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
return substitute ( source , 0 , source . length () ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { MST[rv.UOI4Mutator]MSP[S] if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
int bufEnd = offset + length ; int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , MST[rv.ABSMutator]MSP[N] bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR3Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ConstructorCallMutator]MSP[N]
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ABSMutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; } public String replace ( final String source ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] }
return substitute ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[rv.ROR2Mutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
int bufEnd = offset + length ; MST[rv.UOI3Mutator]MSP[N] int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N]
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
final StrMatcher valueDelimMatcher = getValueDelimiterMatcher () ; final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables () ; MST[NonVoidMethodCallMutator]MSP[S] final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues () ; final boolean top = priorVariables == null ; boolean altered = false ; int lengthChange = 0 ; char [] chars = buf . buffer ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI2Mutator]MSP[N] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.AOR1Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[NonVoidMethodCallMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; } public String replace ( final String source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[MathMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
pos , offset , bufEnd ) != 0 ) { endMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; nestedVarCount ++ ; pos += endMatchLen ; continue; } endMatchLen = suffMatcher . isMatch ( chars , pos , offset , MST[rv.UOI3Mutator]MSP[N] bufEnd ) ;
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.ABSMutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; } public boolean isEnableSubstitutionInVariables () {
return substitute ( source , offset , length ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; } return buf . toString () ; MST[ReturnValsMutator]MSP[N] } public String replace ( final char [] source ) { if ( source == null ) {
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[rv.UOI1Mutator]MSP[N] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.ABSMutator]MSP[N] }
substitute ( buf , 0 , length ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.CRCR6Mutator]MSP[N] return source ; } return buf . toString () ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR6Mutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; }
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; } public String replace ( final String source ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; MST[InlineConstantMutator]MSP[S] }
return setVariablePrefixMatcher ( StrMatcher . stringMatcher ( prefix ) ) ; } public StrMatcher getVariableSuffixMatcher () { return suffixMatcher ; MST[NullReturnValsMutator]MSP[N] } public StrSubstitutor setVariableSuffixMatcher ( final StrMatcher suffixMatcher ) { Validate . isTrue ( suffixMatcher != null , lr_6 ) ; this . suffixMatcher = suffixMatcher ; return this ;
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; } return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String replace ( final char [] source ) { if ( source == null ) {
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI4Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR6Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ConstructorCallMutator]MSP[N]
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.ROR4Mutator]MSP[N] return source ; } return buf . toString () ; }
change = change + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; MST[rv.AOR1Mutator]MSP[S] break; } nestedVarCount -- ;
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; MST[NonVoidMethodCallMutator]MSP[S] return this ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; MST[ReturnValsMutator]MSP[N] } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; } public boolean isEnableSubstitutionInVariables () {
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
bufEnd -- ; } else { final int startPos = pos ; MST[rv.UOI3Mutator]MSP[N] pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[InlineConstantMutator]MSP[N] }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[rv.UOI4Mutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.UOI3Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
substitute ( buf , 0 , length ) ; MST[rv.UOI2Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.ROR4Mutator]MSP[N] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[ReturnValsMutator]MSP[N] }
return replaceIn ( source , 0 , source . length () ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.AOR1Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
this . escapeChar = escapeCharacter ; } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] this . prefixMatcher = prefixMatcher ; return this ; }
return enableSubstitutionInVariables ; } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; MST[rv.UOI2Mutator]MSP[N] } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
this . escapeChar = escapeCharacter ; } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; MST[ReturnValsMutator]MSP[N] } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[rv.CRCR2Mutator]MSP[N] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
final StrLookup < ? > resolver = getVariableResolver () ; MST[NonVoidMethodCallMutator]MSP[N] if ( resolver == null ) { return null ; } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; }
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR1Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[NonVoidMethodCallMutator]MSP[S]
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.CRCR3Mutator]MSP[N] return source ; } return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOD2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; MST[ReturnValsMutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public String replace ( final String source ) { if ( source == null ) { return null ; }
int bufEnd = offset + length ; int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , MST[rv.UOI2Mutator]MSP[N] bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { return source ; MST[ReturnValsMutator]MSP[N] } return buf . toString () ; }
if ( valueDelimMatcher != null ) { final char [] varNameExprChars = varNameExpr . toCharArray () ; int valueDelimiterMatchLen = 0 ; for ( int i = 0 ; i < varNameExprChars . length ; i ++ ) { if ( ! substitutionInVariablesEnabled MST[rv.UOI2Mutator]MSP[N] && pfxMatcher . isMatch ( varNameExprChars ,
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI1Mutator]MSP[N] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[NullReturnValsMutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
int bufEnd = offset + length ; int pos = offset ; MST[rv.UOI3Mutator]MSP[N] while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
change = change + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; MST[rv.AOD1Mutator]MSP[S] break; } nestedVarCount -- ;
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[NegateConditionalsMutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ABSMutator]MSP[N] return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
substitute ( buf , 0 , length ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; MST[ReturnValsMutator]MSP[S] } public String replace ( final String source ) { if ( source == null ) { return null ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled MST[rv.UOI4Mutator]MSP[S] && pfxMatcher . isMatch ( chars ,
return replaceIn ( source , 0 , source . length () ) ; MST[InlineConstantMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; MST[ReturnValsMutator]MSP[S] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI2Mutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[rv.ROR5Mutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI2Mutator]MSP[S] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
if ( ! substitute ( buf , 0 , length ) ) { MST[NonVoidMethodCallMutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[NullReturnValsMutator]MSP[N] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
substitute ( buf , 0 , length ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return replaceIn ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR3Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { return source ; MST[EmptyObjectReturnValsMutator]MSP[S] } return buf . toString () ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.AOR4Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
if ( valueProperties == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOD1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
int bufEnd = offset + length ; int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , MST[rv.UOI1Mutator]MSP[N] bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[ConstructorCallMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } return replace ( source , 0 , source . length () ) ; }
return setVariablePrefixMatcher ( StrMatcher . stringMatcher ( prefix ) ) ; } public StrMatcher getVariableSuffixMatcher () { return suffixMatcher ; } public StrSubstitutor setVariableSuffixMatcher ( final StrMatcher suffixMatcher ) { Validate . isTrue ( suffixMatcher != null , lr_6 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] this . suffixMatcher = suffixMatcher ; return this ;
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[InlineConstantMutator]MSP[N] }
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.ABSMutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[rv.CRCR1Mutator]MSP[N] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
source . replace ( offset , offset + length , buf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI1Mutator]MSP[S] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
return substitute ( source , 0 , source . length () ) ; MST[InlineConstantMutator]MSP[S] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI2Mutator]MSP[N] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } return replace ( source , 0 , source . length () ) ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR1Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; MST[NonVoidMethodCallMutator]MSP[S] while ( propNames . hasMoreElements () ) {
private int substitute ( final StrBuilder buf , final int offset , final int length , List < String > priorVariables ) { final StrMatcher pfxMatcher = getVariablePrefixMatcher () ; MST[NonVoidMethodCallMutator]MSP[N] final StrMatcher suffMatcher = getVariableSuffixMatcher () ; final char escape = getEscapeChar () ;
return substitute ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.ROR1Mutator]MSP[S] }
this . escapeChar = escapeCharacter ; MST[rv.UOI1Mutator]MSP[N] } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
final StrBuilder buf = new StrBuilder ( source ) ; MST[ConstructorCallMutator]MSP[N] if ( ! substitute ( buf , 0 , source . length () ) ) { return source ; } return buf . toString () ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI4Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
return substitute ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
substitute ( buf , 0 , length ) ; MST[rv.UOI1Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI4Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[ArgumentPropagationMutator]MSP[N] }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ; MST[experimental.NakedReceiverMutator]MSP[N]
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[NegateConditionalsMutator]MSP[S]
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.ABSMutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
return substitute ( source , offset , length ) ; MST[ReturnValsMutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[rv.UOI3Mutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR5Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
change = change + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; MST[MathMutator]MSP[S] break; } nestedVarCount -- ;
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[ArgumentPropagationMutator]MSP[S] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
return substitute ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
final StrBuilder bufName = new StrBuilder ( varNameExpr ) ; substitute ( bufName , 0 , bufName . length () ) ; varNameExpr = bufName . toString () ; } pos += endMatchLen ; MST[rv.UOI2Mutator]MSP[N] final int endPos = pos ; String varName = varNameExpr ; String varDefaultValue = null ;
substitute ( buf , 0 , buf . length () ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR1Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
this . escapeChar = escapeCharacter ; } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] this . prefixMatcher = prefixMatcher ; return this ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[NegateConditionalsMutator]MSP[N] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[rv.ROR2Mutator]MSP[N]
if ( ! priorVariables . contains ( varName ) ) { MST[rv.ROR4Mutator]MSP[N] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
substitute ( buf , 0 , length ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
return setVariableSuffixMatcher ( StrMatcher . stringMatcher ( suffix ) ) ; } public StrMatcher getValueDelimiterMatcher () { return valueDelimiterMatcher ; } public StrSubstitutor setValueDelimiterMatcher ( final StrMatcher valueDelimiterMatcher ) { this . valueDelimiterMatcher = valueDelimiterMatcher ; return this ; MST[ReturnValsMutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final char valueDelimiter ) {
this . escapeChar = escapeCharacter ; MST[rv.UOI4Mutator]MSP[N] } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
substitute ( buf , 0 , buf . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; }
return setVariableSuffixMatcher ( StrMatcher . stringMatcher ( suffix ) ) ; } public StrMatcher getValueDelimiterMatcher () { return valueDelimiterMatcher ; MST[ReturnValsMutator]MSP[N] } public StrSubstitutor setValueDelimiterMatcher ( final StrMatcher valueDelimiterMatcher ) { this . valueDelimiterMatcher = valueDelimiterMatcher ; return this ; } public StrSubstitutor setValueDelimiter ( final char valueDelimiter ) {
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI4Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[S]
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; MST[ReturnValsMutator]MSP[N] } public void setEscapeChar ( final char escapeCharacter ) {
bufEnd -- ; } else { final int startPos = pos ; MST[rv.ABSMutator]MSP[N] pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
if ( valueDelimMatcher != null ) { final char [] varNameExprChars = varNameExpr . toCharArray () ; int valueDelimiterMatchLen = 0 ; for ( int i = 0 ; i < varNameExprChars . length ; i ++ ) { if ( ! substitutionInVariablesEnabled MST[rv.UOI4Mutator]MSP[N] && pfxMatcher . isMatch ( varNameExprChars ,
return preserveEscapes ; } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; MST[rv.UOI2Mutator]MSP[N] }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] substitute ( buf , 0 , source . length ) ; return buf . toString () ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; MST[ConstructorCallMutator]MSP[S] } public String replace ( final String source ) { if ( source == null ) { return null ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR2Mutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return source ; } return buf . toString () ; }
return replaceIn ( source , 0 , source . length () ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[N] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return replaceIn ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
if ( ! substitute ( buf , 0 , length ) ) { MST[InlineConstantMutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
substitute ( buf , 0 , length ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.ABSMutator]MSP[N] }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[rv.CRCR5Mutator]MSP[N] }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[rv.CRCR1Mutator]MSP[N] }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[rv.UOI3Mutator]MSP[N] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
substitute ( buf , 0 , length ) ; MST[rv.UOI1Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
return substitute ( source , 0 , source . length () ) ; MST[ReturnValsMutator]MSP[N] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[MathMutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[InlineConstantMutator]MSP[N] buf . append ( lr_2 ) ;
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[ReturnValsMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , length ) ; MST[rv.ABSMutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI1Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( lr_2 ) ;
buf . appendWithSeparators ( priorVariables , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalStateException ( buf . toString () ) ; } protected String resolveVariable ( final String variableName , final StrBuilder buf , final int startPos , final int endPos ) {
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[rv.ROR1Mutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
final int varLen = varValue . length () ; buf . replace ( startPos , endPos , varValue ) ; altered = true ; int change = 0 ; if ( ! substitutionInValuesDisabled ) { MST[rv.UOI4Mutator]MSP[N] change = substitute ( buf , startPos , varLen , priorVariables ) ; }
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[S] final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) {
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ConstructorCallMutator]MSP[N]
bufEnd -- ; } else { final int startPos = pos ; MST[rv.UOI2Mutator]MSP[N] pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
change = change MST[rv.UOI4Mutator]MSP[N] + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; break; } nestedVarCount -- ;
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[rv.ROR5Mutator]MSP[N] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[experimental.NakedReceiverMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
substitute ( buf , 0 , length ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
return substitute ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
return setVariablePrefixMatcher ( StrMatcher . stringMatcher ( prefix ) ) ; } public StrMatcher getVariableSuffixMatcher () { return suffixMatcher ; } public StrSubstitutor setVariableSuffixMatcher ( final StrMatcher suffixMatcher ) { Validate . isTrue ( suffixMatcher != null , lr_6 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] this . suffixMatcher = suffixMatcher ; return this ;
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.ROR3Mutator]MSP[N] return source ; } return buf . toString () ; }
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; MST[ReturnValsMutator]MSP[N] } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; } public boolean isEnableSubstitutionInVariables () {
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
change = change + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; MST[rv.AOR2Mutator]MSP[S] break; } nestedVarCount -- ;
final Map < String , V > valueMap , final String prefix , final String suffix ) { return new StrSubstitutor ( valueMap , prefix , suffix ) . replace ( source ) ; MST[ConstructorCallMutator]MSP[S] } public static String replace ( final Object source , final Properties valueProperties ) {
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[MathMutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[InlineConstantMutator]MSP[N] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[InlineConstantMutator]MSP[N] }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; MST[ReturnValsMutator]MSP[N] }
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[rv.ROR2Mutator]MSP[N] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
return setVariablePrefixMatcher ( StrMatcher . stringMatcher ( prefix ) ) ; } public StrMatcher getVariableSuffixMatcher () { return suffixMatcher ; MST[ReturnValsMutator]MSP[N] } public StrSubstitutor setVariableSuffixMatcher ( final StrMatcher suffixMatcher ) { Validate . isTrue ( suffixMatcher != null , lr_6 ) ; this . suffixMatcher = suffixMatcher ; return this ;
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
return preserveEscapes ; } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; MST[rv.ABSMutator]MSP[N] }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[N] buf . append ( lr_2 ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR5Mutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[ReturnValsMutator]MSP[N] }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return source ; } return buf . toString () ; }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
this . escapeChar = escapeCharacter ; MST[experimental.MemberVariableMutator]MSP[N] } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
return enableSubstitutionInVariables ; MST[BooleanTrueReturnValsMutator]MSP[S] } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
return enableSubstitutionInVariables ; } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; MST[experimental.MemberVariableMutator]MSP[S] } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; } public boolean isEnableSubstitutionInVariables () {
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N]
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ; MST[NonVoidMethodCallMutator]MSP[N]
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[NegateConditionalsMutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[ReturnValsMutator]MSP[S] }
return enableSubstitutionInVariables ; MST[ReturnValsMutator]MSP[N] } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR5Mutator]MSP[S] }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR5Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[MathMutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI3Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.ABSMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return enableSubstitutionInVariables ; } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; MST[rv.ABSMutator]MSP[N] } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return replaceIn ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
return substitute ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled MST[rv.UOI3Mutator]MSP[S] && pfxMatcher . isMatch ( chars ,
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.UOI2Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder () . append ( source ) ;
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[InlineConstantMutator]MSP[N] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[rv.ROR5Mutator]MSP[S]
if ( ! priorVariables . contains ( varName ) ) { MST[rv.ROR1Mutator]MSP[S] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[rv.ROR4Mutator]MSP[N] setValueDelimiterMatcher ( null ) ; return this ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.ROR5Mutator]MSP[N] }
int bufEnd = offset + length ; int pos = offset ; MST[rv.UOI2Mutator]MSP[N] while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { MST[NegateConditionalsMutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ;
buf . appendWithSeparators ( priorVariables , lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] throw new IllegalStateException ( buf . toString () ) ; } protected String resolveVariable ( final String variableName , final StrBuilder buf , final int startPos , final int endPos ) {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[ConditionalsBoundaryMutator]MSP[S] }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ConstructorCallMutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR2Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
if ( valueDelimMatcher != null ) { final char [] varNameExprChars = varNameExpr . toCharArray () ; int valueDelimiterMatchLen = 0 ; for ( int i = 0 ; i < varNameExprChars . length ; i ++ ) { if ( ! substitutionInVariablesEnabled MST[rv.UOI1Mutator]MSP[N] && pfxMatcher . isMatch ( varNameExprChars ,
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI2Mutator]MSP[N] }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; MST[ReturnValsMutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[experimental.NakedReceiverMutator]MSP[N]
substitute ( buf , 0 , length ) ; MST[rv.UOI4Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ; MST[NegateConditionalsMutator]MSP[N]
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[ReturnValsMutator]MSP[N] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.AOR2Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
if ( valueProperties == null ) { return source . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
return replaceIn ( source , 0 , source . length () ) ; MST[InlineConstantMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[rv.ABSMutator]MSP[N] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
return substitute ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
final String propName = ( String ) propNames . nextElement () ; final String propValue = valueProperties . getProperty ( propName ) ; valueMap . put ( propName , propValue ) ; } return StrSubstitutor . replace ( source , valueMap ) ; MST[EmptyObjectReturnValsMutator]MSP[S] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; } public String replace ( final String source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] }
if ( ! priorVariables . contains ( varName ) ) { MST[NonVoidMethodCallMutator]MSP[S] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
return substitute ( source , offset , length ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI2Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.AOD2Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
return substitute ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; } public String replace ( final String source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.ABSMutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[rv.ROR4Mutator]MSP[S] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR1Mutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[ConstructorCallMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI4Mutator]MSP[N] return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { return null ; }
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled MST[rv.UOI2Mutator]MSP[S] && pfxMatcher . isMatch ( chars ,
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.UOI1Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[rv.ROR4Mutator]MSP[S]
if ( valueProperties == null ) { return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) { MST[rv.ROR1Mutator]MSP[S]
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.UOI3Mutator]MSP[N] }
int bufEnd = offset + length ; int pos = offset ; MST[rv.UOI1Mutator]MSP[N] while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
if ( endMatchLen == 0 ) { pos ++ ; } else { if ( nestedVarCount == 0 ) { String varNameExpr = new String ( chars , startPos MST[rv.AOR3Mutator]MSP[N] + startMatchLen , pos - startPos - startMatchLen ) ; if ( substitutionInVariablesEnabled ) {
return enableSubstitutionInVariables ; } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; MST[rv.UOI4Mutator]MSP[S] } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOD1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ; MST[NegateConditionalsMutator]MSP[N]
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[rv.UOI1Mutator]MSP[N] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; MST[ReturnValsMutator]MSP[N] }
source . replace ( offset , offset + length , buf . toString () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[ReturnValsMutator]MSP[N] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return source ; } return buf . toString () ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[BooleanTrueReturnValsMutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
substitute ( buf , 0 , length ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
return replaceIn ( source , 0 , source . length () ) ; MST[ReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
public static < V > String replace ( final Object source , final Map < String , V > valueMap ) { return new StrSubstitutor ( valueMap ) . replace ( source ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static < V > String replace ( final Object source ,
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; } return resolver . lookup ( variableName ) ; MST[ArgumentPropagationMutator]MSP[N] } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; substitute ( buf , 0 , buf . length () ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ConstructorCallMutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
substitute ( buf , 0 , length ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
final StrBuilder buf = new StrBuilder ( source . length () ) . append ( source ) ; MST[experimental.NakedReceiverMutator]MSP[N] substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; }
substitute ( buf , 0 , buf . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; }
this . escapeChar = escapeCharacter ; MST[rv.ABSMutator]MSP[N] } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return preserveEscapes ; MST[BooleanFalseReturnValsMutator]MSP[S] } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; }
return enableSubstitutionInVariables ; } public void setEnableSubstitutionInVariables ( final boolean enableSubstitutionInVariables ) { this . enableSubstitutionInVariables = enableSubstitutionInVariables ; MST[rv.UOI1Mutator]MSP[N] } public boolean isDisableSubstitutionInValues () { return disableSubstitutionInValues ; } public void setDisableSubstitutionInValues ( final boolean disableSubstitutionInValues ) { this . disableSubstitutionInValues = disableSubstitutionInValues ; } public boolean isPreserveEscapes () {
buf . appendWithSeparators ( priorVariables , lr_3 ) ; throw new IllegalStateException ( buf . toString () ) ; MST[ConstructorCallMutator]MSP[S] } protected String resolveVariable ( final String variableName , final StrBuilder buf , final int startPos , final int endPos ) {
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.AOR2Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
if ( ! priorVariables . contains ( varName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N]
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ; MST[rv.ROR5Mutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR5Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
int bufEnd = offset + length ; MST[rv.ABSMutator]MSP[N] int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.ROR2Mutator]MSP[N] }
return null ; MST[ReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; return buf . toString () ; }
final String propName = ( String ) propNames . nextElement () ; final String propValue = valueProperties . getProperty ( propName ) ; MST[ArgumentPropagationMutator]MSP[S] valueMap . put ( propName , propValue ) ; } return StrSubstitutor . replace ( source , valueMap ) ; }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[NonVoidMethodCallMutator]MSP[N]
bufEnd -- ; } else { final int startPos = pos ; MST[rv.UOI4Mutator]MSP[N] pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
return substitute ( source , 0 , source . length () ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI1Mutator]MSP[N] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
if ( ! priorVariables . contains ( varName ) ) { MST[NegateConditionalsMutator]MSP[N] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[rv.CRCR4Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.ROR2Mutator]MSP[N] return source ; } return buf . toString () ; }
return preserveEscapes ; } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; MST[experimental.MemberVariableMutator]MSP[S] }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; MST[InlineConstantMutator]MSP[N] }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N]
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[InlineConstantMutator]MSP[S] }
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; MST[rv.UOI2Mutator]MSP[N] } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { setValueDelimiterMatcher ( null ) ; return this ; }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[NonVoidMethodCallMutator]MSP[N] }
return preserveEscapes ; MST[ReturnValsMutator]MSP[S] } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; }
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( valueProperties == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return source . toString () ; } final Map < String , String > valueMap = new HashMap <> () ; final Enumeration < ? > propNames = valueProperties . propertyNames () ; while ( propNames . hasMoreElements () ) {
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { return source ; } return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
substitute ( buf , 0 , length ) ; MST[rv.UOI1Mutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
pos , offset , bufEnd ) != 0 ) { endMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; nestedVarCount ++ ; pos += endMatchLen ; continue; } endMatchLen = suffMatcher . isMatch ( chars , pos , offset , MST[rv.UOI2Mutator]MSP[N] bufEnd ) ;
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[rv.UOI2Mutator]MSP[N] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
return setValueDelimiterMatcher ( StrMatcher . charMatcher ( valueDelimiter ) ) ; } public StrSubstitutor setValueDelimiter ( final String valueDelimiter ) { if ( valueDelimiter == null || valueDelimiter . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] setValueDelimiterMatcher ( null ) ; return this ; }
if ( ! substitute ( buf , 0 , length ) ) { MST[rv.ROR4Mutator]MSP[N] return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
return substitute ( source , offset , length ) ; MST[rv.ABSMutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
private int substitute ( final StrBuilder buf , final int offset , final int length , List < String > priorVariables ) { final StrMatcher pfxMatcher = getVariablePrefixMatcher () ; final StrMatcher suffMatcher = getVariableSuffixMatcher () ; MST[NonVoidMethodCallMutator]MSP[N] final char escape = getEscapeChar () ;
pos , offset , bufEnd ) != 0 ) { endMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; nestedVarCount ++ ; pos += endMatchLen ; continue; } endMatchLen = suffMatcher . isMatch ( chars , pos , offset , MST[rv.ABSMutator]MSP[N] bufEnd ) ;
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; } return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public String replace ( final char [] source ) { if ( source == null ) {
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[InlineConstantMutator]MSP[N] return source ; } return buf . toString () ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR1Mutator]MSP[N] return false ; }
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI1Mutator]MSP[N] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; } return resolver . lookup ( variableName ) ; MST[NonVoidMethodCallMutator]MSP[N] } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
if ( ! priorVariables . contains ( varName ) ) { MST[rv.ROR5Mutator]MSP[N] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
final int varLen = varValue . length () ; buf . replace ( startPos , endPos , varValue ) ; altered = true ; int change = 0 ; if ( ! substitutionInValuesDisabled ) { MST[rv.UOI3Mutator]MSP[S] change = substitute ( buf , startPos , varLen , priorVariables ) ; }
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
if ( ! priorVariables . contains ( varName ) ) { MST[rv.ROR2Mutator]MSP[N] return; } final StrBuilder buf = new StrBuilder ( 256 ) ; buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
return substitute ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
int bufEnd = offset + length ; MST[rv.UOI2Mutator]MSP[N] int pos = offset ; while ( pos < bufEnd ) { final int startMatchLen = pfxMatcher . isMatch ( chars , pos , offset , bufEnd ) ; if ( startMatchLen == 0 ) { pos ++ ; } else {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } return replace ( source , 0 , source . length () ) ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
bufEnd -- ; } else { final int startPos = pos ; pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { MST[rv.UOI3Mutator]MSP[S] if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
} public StrSubstitutor setVariableSuffix ( final char suffix ) { return setVariableSuffixMatcher ( StrMatcher . charMatcher ( suffix ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public StrSubstitutor setVariableSuffix ( final String suffix ) { Validate . isTrue ( suffix != null , lr_7 ) ;
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N]
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; MST[PrimitiveReturnsMutator]MSP[N] } public void setEscapeChar ( final char escapeCharacter ) {
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[ReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
final String propName = ( String ) propNames . nextElement () ; final String propValue = valueProperties . getProperty ( propName ) ; valueMap . put ( propName , propValue ) ; MST[NonVoidMethodCallMutator]MSP[S] } return StrSubstitutor . replace ( source , valueMap ) ; }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[NullReturnValsMutator]MSP[N] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
return preserveEscapes ; } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; MST[rv.UOI1Mutator]MSP[N] }
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String replace ( final String source ) { if ( source == null ) { return null ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! substitute ( buf , 0 , length ) ) { return false ; }
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
public String replace ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[ConstructorCallMutator]MSP[N]
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
substitute ( buf , 0 , length ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[InlineConstantMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; MST[ReturnValsMutator]MSP[N] } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[rv.CRCR1Mutator]MSP[N] return source ; } return buf . toString () ; }
final StrBuilder bufName = new StrBuilder ( varNameExpr ) ; substitute ( bufName , 0 , bufName . length () ) ; varNameExpr = bufName . toString () ; } pos += endMatchLen ; MST[rv.ABSMutator]MSP[N] final int endPos = pos ; String varName = varNameExpr ; String varDefaultValue = null ;
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
return substitute ( source , 0 , source . length () ) ; MST[rv.CRCR1Mutator]MSP[S] } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI2Mutator]MSP[N]
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
return replaceIn ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR4Mutator]MSP[N] }
public StrSubstitutor setVariablePrefix ( final char prefix ) { return setVariablePrefixMatcher ( StrMatcher . charMatcher ( prefix ) ) ; MST[rv.UOI4Mutator]MSP[N] } public StrSubstitutor setVariablePrefix ( final String prefix ) { Validate . isTrue ( prefix != null , lr_5 ) ;
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; MST[ReturnValsMutator]MSP[N] } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
substitute ( buf , 0 , length ) ; MST[rv.ABSMutator]MSP[N] return buf . toString () ; } public String replace ( final CharSequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length () ) ; }
return substitute ( source , 0 , source . length () ) ; } public boolean replaceIn ( final StrBuilder source , final int offset , final int length ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N]
buf . appendWithSeparators ( priorVariables , lr_3 ) ; throw new IllegalStateException ( buf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected String resolveVariable ( final String variableName , final StrBuilder buf , final int startPos , final int endPos ) {
return preserveEscapes ; } public void setPreserveEscapes ( final boolean preserveEscapes ) { this . preserveEscapes = preserveEscapes ; MST[rv.UOI4Mutator]MSP[S] }
change = change MST[rv.UOI3Mutator]MSP[N] + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; break; } nestedVarCount -- ;
return replaceIn ( source , 0 , source . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
if ( ! priorVariables . contains ( varName ) ) { return; } final StrBuilder buf = new StrBuilder ( 256 ) ; MST[rv.CRCR4Mutator]MSP[N] buf . append ( lr_1 ) ; buf . append ( priorVariables . remove ( 0 ) ) ; buf . append ( lr_2 ) ;
return replaceIn ( source , 0 , source . length () ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean replaceIn ( final StringBuilder source , final int offset , final int length ) { if ( source == null ) { return false ; }
return substitute ( source , offset , length ) ; } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; MST[rv.CRCR1Mutator]MSP[S] }
return setValueDelimiterMatcher ( StrMatcher . stringMatcher ( valueDelimiter ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public StrLookup < ? > getVariableResolver () { return this . variableResolver ; } public void setVariableResolver ( final StrLookup < ? > variableResolver ) { this . variableResolver = variableResolver ; } public boolean isEnableSubstitutionInVariables () {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final StrBuilder source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
public String replace ( final CharSequence source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[experimental.NakedReceiverMutator]MSP[N]
substitute ( buf , 0 , length ) ; MST[rv.ABSMutator]MSP[N] return buf . toString () ; } public String replace ( final StringBuffer source ) { if ( source == null ) { return null ; }
this . escapeChar = escapeCharacter ; MST[rv.UOI2Mutator]MSP[N] } public StrMatcher getVariablePrefixMatcher () { return prefixMatcher ; } public StrSubstitutor setVariablePrefixMatcher ( final StrMatcher prefixMatcher ) { Validate . isTrue ( prefixMatcher != null , lr_4 ) ; this . prefixMatcher = prefixMatcher ; return this ; }
substitute ( buf , 0 , length ) ; MST[rv.UOI2Mutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
final StrLookup < ? > resolver = getVariableResolver () ; if ( resolver == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } return resolver . lookup ( variableName ) ; } public char getEscapeChar () { return this . escapeChar ; } public void setEscapeChar ( final char escapeCharacter ) {
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { return false ; }
substitute ( buf , 0 , length ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
public static String replaceSystemProperties ( final Object source ) { return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; } public String replace ( final String source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
if ( pos > offset && chars [ pos - 1 ] == escape ) { MST[rv.ROR1Mutator]MSP[N] if ( preserveEscapes ) { pos ++ ; continue; } buf . deleteCharAt ( pos - 1 ) ; chars = buf . buffer ; lengthChange -- ; altered = true ;
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.ABSMutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
if ( ! substitute ( buf , 0 , length ) ) { return source . substring ( offset , offset + length ) ; MST[rv.UOI4Mutator]MSP[S] } return buf . toString () ; } public String replace ( final char [] source ) { if ( source == null ) {
substitute ( buf , 0 , length ) ; return buf . toString () ; } public String replace ( final Object source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final StrBuilder buf = new StrBuilder () . append ( source ) ;
source . replace ( offset , offset + length , buf . toString () ) ; return true ; } public boolean replaceIn ( final StringBuilder source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
return replaceIn ( source , 0 , source . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean replaceIn ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return false ; }
final StrBuilder buf = new StrBuilder ( source ) ; if ( ! substitute ( buf , 0 , source . length () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return source ; } return buf . toString () ; }
return substitute ( source , offset , length ) ; MST[rv.UOI1Mutator]MSP[N] } protected boolean substitute ( final StrBuilder buf , final int offset , final int length ) { return substitute ( buf , offset , length , null ) > 0 ; }
source . replace ( offset , offset + length , buf . toString () ) ; MST[rv.AOR1Mutator]MSP[N] return true ; } public boolean replaceIn ( final StrBuilder source ) { if ( source == null ) { return false ; }
change = change + varLen - ( endPos - startPos ) ; pos += change ; bufEnd += change ; lengthChange += change ; chars = buf . buffer ; } priorVariables . remove ( priorVariables . size () - 1 ) ; MST[rv.AOR3Mutator]MSP[S] break; } nestedVarCount -- ;
return null ; } final StrBuilder buf = new StrBuilder ( source . length ) . append ( source ) ; substitute ( buf , 0 , source . length ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; }
public String replace ( final char [] source , final int offset , final int length ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ;
public static < V > String replace ( final Object source , final Map < String , V > valueMap ) { return new StrSubstitutor ( valueMap ) . replace ( source ) ; MST[ConstructorCallMutator]MSP[N] } public static < V > String replace ( final Object source ,
public String replace ( final StringBuffer source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI4Mutator]MSP[N]
public String replace ( final String source , final int offset , final int length ) { if ( source == null ) { return null ; } final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; MST[rv.UOI3Mutator]MSP[N]
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; }
bufEnd -- ; } else { final int startPos = pos ; MST[rv.UOI1Mutator]MSP[N] pos += startMatchLen ; int endMatchLen = 0 ; int nestedVarCount = 0 ; while ( pos < bufEnd ) { if ( substitutionInVariablesEnabled && pfxMatcher . isMatch ( chars ,
final StrBuilder buf = new StrBuilder ( length ) . append ( source , offset , length ) ; if ( ! substitute ( buf , 0 , length ) ) { MST[InlineConstantMutator]MSP[N] return false ; }
substitute ( buf , 0 , buf . length () ) ; return buf . toString () ; } public boolean replaceIn ( final StringBuffer source ) { if ( source == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
