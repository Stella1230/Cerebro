public String encode ( final String original ) throws UnsupportedEncodingException { if ( original == null ) { return null ; } final StringBuilder sb = new StringBuilder () ; for ( int i = 0 ; i < original . length () ; ) {
final int codepoint = original . codePointAt ( i ) ; final String nextLetter = originalToEncoded . get ( codepoint ) ; if ( nextLetter == null ) { throw new UnsupportedEncodingException ( lr_1 + codePointToString ( codepoint ) + lr_2 + original ) ; }
sb . append ( nextLetter ) ; i += Character . charCount ( codepoint ) ; } return sb . toString () ; } public String decode ( final String encoded ) throws UnsupportedEncodingException { if ( encoded == null ) { return null ; }
final StringBuilder result = new StringBuilder () ; for ( int j = 0 ; j < encoded . length () ; ) { final Integer i = encoded . codePointAt ( j ) ; final String s = codePointToString ( i ) ;
if ( s . equals ( originalToEncoded . get ( i ) ) ) { result . append ( s ) ; j ++ ; } else { if ( j + encodedLetterLength > encoded . length () ) { throw new UnsupportedEncodingException ( lr_3
+ lr_4 + encoded ) ; } final String nextGroup = encoded . substring ( j , j + encodedLetterLength ) ; final String next = encodedToOriginal . get ( nextGroup ) ; if ( next == null ) { throw new UnsupportedEncodingException ( lr_5
+ nextGroup + lr_6 + encoded ) ; } result . append ( next ) ; j += encodedLetterLength ; } } return result . toString () ; } public int getEncodedCharLength () { return encodedLetterLength ; } public Map < Integer , String > getOriginalToEncoded () {
return Collections . unmodifiableMap ( originalToEncoded ) ; } @SuppressWarnings ( lr_7 ) private void addSingleEncoding ( final int level , final String currentEncoding , final Collection < Integer > encoding , final Iterator < Integer > originals , final Map < Integer , String > doNotEncodeMap ) {
if ( level > 0 ) { for ( final int encodingLetter : encoding ) { if ( originals . hasNext () ) { if ( level != encodedLetterLength || ! doNotEncodeMap . containsKey ( encodingLetter ) ) { addSingleEncoding ( level - 1 , currentEncoding
+ codePointToString ( encodingLetter ) , encoding , originals , doNotEncodeMap ) ; } } else { return; } } } else { Integer next = originals . next () ; while ( doNotEncodeMap . containsKey ( next ) ) { final String originalLetterAsString = codePointToString ( next ) ;
originalToEncoded . put ( next , originalLetterAsString ) ; encodedToOriginal . put ( originalLetterAsString , originalLetterAsString ) ; if ( ! originals . hasNext () ) { return; } next = originals . next () ; } final String originalLetterAsString = codePointToString ( next ) ;
originalToEncoded . put ( next , currentEncoding ) ; encodedToOriginal . put ( currentEncoding , originalLetterAsString ) ; } } @Override public String toString () { final StringBuilder sb = new StringBuilder () ; for ( final Entry < Integer , String > entry
: originalToEncoded . entrySet () ) { sb . append ( codePointToString ( entry . getKey () ) ) . append ( ARROW ) . append ( entry . getValue () ) . append ( System . lineSeparator () ) ; } return sb . toString () ; } @Override
public boolean equals ( final Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( ! ( obj instanceof AlphabetConverter ) ) { return false ; }
final AlphabetConverter other = ( AlphabetConverter ) obj ; return originalToEncoded . equals ( other . originalToEncoded ) && encodedToOriginal . equals ( other . encodedToOriginal ) && encodedLetterLength == other . encodedLetterLength ; } @Override public int hashCode () { return Objects . hash ( originalToEncoded , encodedToOriginal ,
encodedLetterLength ) ; } public static AlphabetConverter createConverterFromMap ( final Map < Integer , String > originalToEncoded ) { final Map < Integer , String > unmodifiableOriginalToEncoded = Collections . unmodifiableMap ( originalToEncoded ) ; final Map < String , String > encodedToOriginal = new LinkedHashMap <> () ;
int encodedLetterLength = 1 ; for ( final Entry < Integer , String > e : unmodifiableOriginalToEncoded . entrySet () ) { final String originalAsString = codePointToString ( e . getKey () ) ; encodedToOriginal . put ( e . getValue () , originalAsString ) ;
if ( e . getValue () . length () > encodedLetterLength ) { encodedLetterLength = e . getValue () . length () ; } } return new AlphabetConverter ( unmodifiableOriginalToEncoded , encodedToOriginal , encodedLetterLength ) ; } public static AlphabetConverter createConverterFromChars ( final Character [] original ,
final Character [] encoding , final Character [] doNotEncode ) { return AlphabetConverter . createConverter ( convertCharsToIntegers ( original ) , convertCharsToIntegers ( encoding ) , convertCharsToIntegers ( doNotEncode ) ) ; } private static Integer [] convertCharsToIntegers ( final Character [] chars ) {
if ( chars == null || chars . length == 0 ) { return new Integer [ 0 ] ; } final Integer [] integers = new Integer [ chars . length ] ;
for ( int i = 0 ; i < chars . length ; i ++ ) { integers [ i ] = ( int ) chars [ i ] ; } return integers ; } public static AlphabetConverter createConverter ( final Integer [] original , final Integer [] encoding ,
final Integer [] doNotEncode ) { final Set < Integer > originalCopy = new LinkedHashSet <> ( Arrays . <Integer > asList ( original ) ) ; final Set < Integer > encodingCopy = new LinkedHashSet <> ( Arrays . <Integer > asList ( encoding ) ) ;
final Set < Integer > doNotEncodeCopy = new LinkedHashSet <> ( Arrays . <Integer > asList ( doNotEncode ) ) ; final Map < Integer , String > originalToEncoded = new LinkedHashMap <> () ; final Map < String , String > encodedToOriginal = new LinkedHashMap <> () ;
final Map < Integer , String > doNotEncodeMap = new HashMap <> () ; int encodedLetterLength ; for ( final int i : doNotEncodeCopy ) { if ( ! originalCopy . contains ( i ) ) { throw new IllegalArgumentException ( lr_8 + lr_9
+ codePointToString ( i ) + lr_10 ) ; } if ( ! encodingCopy . contains ( i ) ) { throw new IllegalArgumentException ( lr_11 + codePointToString ( i ) + lr_10 ) ; } doNotEncodeMap . put ( i , codePointToString ( i ) ) ; }
if ( encodingCopy . size () >= originalCopy . size () ) { encodedLetterLength = 1 ; final Iterator < Integer > it = encodingCopy . iterator () ; for ( final int originalLetter : originalCopy ) { final String originalLetterAsString = codePointToString ( originalLetter ) ;
if ( doNotEncodeMap . containsKey ( originalLetter ) ) { originalToEncoded . put ( originalLetter , originalLetterAsString ) ; encodedToOriginal . put ( originalLetterAsString , originalLetterAsString ) ; } else { Integer next = it . next () ; while ( doNotEncodeCopy . contains ( next ) ) {
next = it . next () ; } final String encodedLetter = codePointToString ( next ) ; originalToEncoded . put ( originalLetter , encodedLetter ) ; encodedToOriginal . put ( encodedLetter , originalLetterAsString ) ; } } return new AlphabetConverter ( originalToEncoded , encodedToOriginal , encodedLetterLength ) ;
} else if ( encodingCopy . size () - doNotEncodeCopy . size () < 2 ) { throw new IllegalArgumentException ( lr_12 + lr_13 + ( encodingCopy . size () - doNotEncodeCopy . size () ) ) ; } else { int lettersSoFar = 1 ;
int lettersLeft = ( originalCopy . size () - doNotEncodeCopy . size () ) / ( encodingCopy . size () - doNotEncodeCopy . size () ) ; while ( lettersLeft / encodingCopy . size () >= 1 ) { lettersLeft = lettersLeft / encodingCopy . size () ;
lettersSoFar ++ ; } encodedLetterLength = lettersSoFar + 1 ; final AlphabetConverter ac = new AlphabetConverter ( originalToEncoded , encodedToOriginal , encodedLetterLength ) ; ac . addSingleEncoding ( encodedLetterLength , lr_14 , encodingCopy , originalCopy . iterator () , doNotEncodeMap ) ; return ac ; } }
private static String codePointToString ( final int i ) { if ( Character . charCount ( i ) == 1 ) { return String . valueOf ( ( char ) i ) ; } return new String ( Character . toChars ( i ) ) ; }
