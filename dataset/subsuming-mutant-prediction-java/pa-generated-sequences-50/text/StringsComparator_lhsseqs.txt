vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ROR1Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI4Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI3Mutator]MSP[] } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ABSMutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR5Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOD2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOD2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR3Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[MathMutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
return null ; } final int delta = m - n ; MST[rv.UOI4Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; if ( middle == null MST[NegateConditionalsMutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR1Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.ABSMutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR3Mutator]MSP[]
final int i = k + offset - delta ; MST[rv.AOR3Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; MST[rv.AOD1Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI4Mutator]MSP[] if ( middle == null
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.CRCR3Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ROR1Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI2Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOD2Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[MathMutator]MSP[]
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; MST[rv.ABSMutator]MSP[] ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ABSMutator]MSP[] vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; MST[IncrementsMutator]MSP[] }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.AOR1Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
buildScript ( start1 , middle . getStart () , MST[rv.UOI2Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
buildScript ( start1 , middle . getStart () , MST[rv.UOI3Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.AOR3Mutator]MSP[] if ( m == 0 || n == 0 ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[NegateConditionalsMutator]MSP[]
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.UOI1Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[MathMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI2Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI4Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ABSMutator]MSP[]
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; MST[rv.ABSMutator]MSP[] ++ j ; } } } } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR1Mutator]MSP[] int i = start1 ; int j = start2 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.CRCR4Mutator]MSP[] } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI3Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI1Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI3Mutator]MSP[] ++ y ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR5Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[InlineConstantMutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[NegateConditionalsMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ROR2Mutator]MSP[]
buildScript ( start1 , middle . getStart () , MST[rv.ABSMutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.ROR1Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI4Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.AOR4Mutator]MSP[] } int x = vUp [ i ] - 1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ABSMutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR4Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.AOR1Mutator]MSP[] } int x = vUp [ i ] - 1 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR1Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI4Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.AOD2Mutator]MSP[] int i = start1 ; int j = start2 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.AOD2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[MathMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.CRCR3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI4Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI2Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[IncrementsMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.CRCR6Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[NonVoidMethodCallMutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI3Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[InlineConstantMutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI2Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.AOR1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR1Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[ConstructorCallMutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; MST[rv.UOI3Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR4Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI2Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR2Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR2Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[NegateConditionalsMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR5Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI3Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI3Mutator]MSP[] if ( middle == null
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI2Mutator]MSP[] int y = x - start1 + start2 - k ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.AOD2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI3Mutator]MSP[]
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR3Mutator]MSP[] return script ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.ROR1Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR4Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOD1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI4Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI3Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.ABSMutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI3Mutator]MSP[] && end < end1
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI2Mutator]MSP[] && end < end1
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI1Mutator]MSP[] && end < end1
int y = x - start1 + start2 - k ; MST[rv.AOR4Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[NegateConditionalsMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR1Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.AOR1Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.CRCR1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , MST[rv.UOI1Mutator]MSP[] middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ROR4Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.AOR2Mutator]MSP[] } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[RemoveConditionalMutator_EQUAL_IF]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
while ( i < end1 || j < end2 ) { MST[rv.UOI2Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[IncrementsMutator]MSP[] y -- ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI4Mutator]MSP[] && end < end1
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[ConditionalsBoundaryMutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI4Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.ABSMutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR3Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.UOI3Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[rv.AOR2Mutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR3Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; MST[rv.AOD2Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR1Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[NegateConditionalsMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR3Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return null ; } final int delta = m - n ; MST[rv.UOI2Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ROR3Mutator]MSP[]
while ( i < end1 || j < end2 ) { MST[rv.UOI3Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR2Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR4Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[ReturnValsMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.AOR1Mutator]MSP[] int i = start1 ; int j = start2 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[MathMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI3Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR4Mutator]MSP[] int i = start1 ; int j = start2 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.CRCR3Mutator]MSP[] } int x = vUp [ i ] - 1 ;
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.AOR4Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI1Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR6Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR2Mutator]MSP[] int i = start1 ; int j = start2 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; MST[rv.AOR2Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[ConditionalsBoundaryMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; MST[rv.UOI2Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; MST[rv.UOI1Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR4Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.AOR1Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI3Mutator]MSP[] y -- ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI2Mutator]MSP[] if ( middle == null
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR3Mutator]MSP[]
final int i = k + offset ; MST[rv.UOI2Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI1Mutator]MSP[] int y = x - start1 + start2 - k ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.ABSMutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR3Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
final int i = k + offset - delta ; MST[MathMutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; MST[MathMutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR5Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI2Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR5Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.AOR1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.AOR2Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.AOD2Mutator]MSP[] && end < end1
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI4Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.AOR4Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR6Mutator]MSP[] return script ; }
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR2Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR3Mutator]MSP[] && end < end1
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI1Mutator]MSP[]
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ROR3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI3Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( i < end1 || j < end2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR4Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[MathMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
int y = x - start1 + start2 - k ; MST[rv.AOR4Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOD2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI2Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI1Mutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[InlineConstantMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ROR5Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI3Mutator]MSP[] && end < end1
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR4Mutator]MSP[] && end < end1
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.AOD2Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI1Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI2Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[InvertNegsMutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[NegateConditionalsMutator]MSP[]
final int i = k + offset ; MST[rv.ABSMutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.AOR4Mutator]MSP[] && end < end1
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( i < end1 || j < end2 ) { MST[rv.UOI2Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[NegateConditionalsMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR3Mutator]MSP[]
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[NonVoidMethodCallMutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[ConstructorCallMutator]MSP[] } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[InlineConstantMutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOD2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[ConditionalsBoundaryMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[InlineConstantMutator]MSP[] } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI4Mutator]MSP[] int i = start1 ; int j = start2 ;
int y = x - start1 + start2 - k ; MST[rv.AOR3Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.AOR1Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.AOR2Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
int y = x - start1 + start2 - k ; MST[rv.AOD2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI4Mutator]MSP[]
while ( i < end1 || j < end2 ) { MST[rv.ROR3Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR5Mutator]MSP[]
while ( i < end1 || j < end2 ) { MST[rv.ABSMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
final int i = k + offset ; MST[rv.UOI2Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.ABSMutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI3Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
while ( i < end1 || j < end2 ) { MST[rv.UOI1Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; MST[rv.AOR2Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI4Mutator]MSP[] if ( m == 0 || n == 0 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI1Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR6Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR6Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ABSMutator]MSP[]
while ( i < end1 || j < end2 ) { MST[rv.UOI4Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.ROR1Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
final int i = k + offset - delta ; MST[rv.UOI4Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ABSMutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI1Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.CRCR6Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI1Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR5Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.UOI1Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; ++ y ; MST[experimental.RemoveIncrementsMutator]MSP[] }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOD2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.ABSMutator]MSP[] } else {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOD1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.CRCR4Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI1Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; MST[rv.AOR2Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR6Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.AOD2Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOD2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.ROR4Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI2Mutator]MSP[]
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI1Mutator]MSP[] if ( middle == null
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] vDown [ i ] = ++ x ; ++ y ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.ABSMutator]MSP[] if ( middle == null
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOD1Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR6Mutator]MSP[] return script ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ROR3Mutator]MSP[]
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.ROR4Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.ABSMutator]MSP[] } int x = vUp [ i ] - 1 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; MST[rv.UOI2Mutator]MSP[] while ( end - diag < end2 && end < end1
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ABSMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOD1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[NullReturnValsMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[NegateConditionalsMutator]MSP[] int i = start1 ; int j = start2 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NonVoidMethodCallMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[MathMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI4Mutator]MSP[] && end < end1
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.ABSMutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.ABSMutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.AOR2Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , MST[rv.UOI4Mutator]MSP[] middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR1Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR1Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI4Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.CRCR5Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI3Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[RemoveConditionalMutator_EQUAL_IF]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI4Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOD2Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI1Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[MathMutator]MSP[] } else {
final int i = k + offset - delta ; MST[rv.AOR4Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI1Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[NegateConditionalsMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
int y = x - start1 + start2 - k ; MST[rv.AOD2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.UOI1Mutator]MSP[] script ) ; } }
int y = x - start1 + start2 - k ; MST[rv.AOR1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOD1Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.AOR4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[NonVoidMethodCallMutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.AOR1Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI1Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI3Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
while ( i < end1 || j < end2 ) { MST[rv.UOI4Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI3Mutator]MSP[] } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[ConditionalsBoundaryMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { MST[rv.ABSMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; MST[rv.UOI2Mutator]MSP[] int j = start2 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[ConditionalsBoundaryMutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI3Mutator]MSP[] if ( m == 0 || n == 0 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[MathMutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI2Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.AOR3Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.AOD2Mutator]MSP[] script ) ; } }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.ABSMutator]MSP[] ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.UOI1Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.AOD1Mutator]MSP[] if ( m == 0 || n == 0 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int i = start1 ; int j = start2 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.AOR2Mutator]MSP[] && end < end1
while ( i < end1 || j < end2 ) { MST[rv.ROR2Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR3Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.CRCR5Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR1Mutator]MSP[] && end < end1
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ABSMutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ABSMutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.AOR4Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[MathMutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR1Mutator]MSP[]
return null ; } final int delta = m - n ; MST[rv.AOD2Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[NonVoidMethodCallMutator]MSP[] int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR5Mutator]MSP[] int i = start1 ; int j = start2 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR6Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR5Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
int y = x - start1 + start2 - k ; MST[rv.AOR1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[ConditionalsBoundaryMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; MST[experimental.RemoveIncrementsMutator]MSP[] ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI4Mutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.AOR4Mutator]MSP[] script ) ; } }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[MathMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.ABSMutator]MSP[] int y = x - start1 + start2 - k ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR4Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[ConditionalsBoundaryMutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOD2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR1Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ROR2Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI1Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.AOD2Mutator]MSP[] } int x = vUp [ i ] - 1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI4Mutator]MSP[] } else {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI4Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR4Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR4Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NonVoidMethodCallMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI3Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ABSMutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] vDown [ 1 + offset ] = start1 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI4Mutator]MSP[] && end < end1
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI4Mutator]MSP[] } int x = vUp [ i ] - 1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[InlineConstantMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ABSMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.AOR4Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , MST[NonVoidMethodCallMutator]MSP[] middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI4Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.CRCR2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI4Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[IncrementsMutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI3Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[NegateConditionalsMutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ; MST[rv.ABSMutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI2Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[NonVoidMethodCallMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.AOR3Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.AOR2Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
final int i = k + offset - delta ; MST[rv.AOD1Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] ++ j ; } } } } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[MathMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI4Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.AOR2Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ABSMutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[]
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[rv.AOR1Mutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[InlineConstantMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NonVoidMethodCallMutator]MSP[] vUp [ i ] = x -- ; y -- ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[experimental.RemoveIncrementsMutator]MSP[] ++ y ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] vDown [ i ] = ++ x ; ++ y ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ; MST[rv.UOI2Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; MST[ConstructorCallMutator]MSP[] ++ j ; } } } } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; MST[rv.UOI4Mutator]MSP[] while ( end - diag < end2 && end < end1
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
int y = x - start1 + start2 - k ; MST[rv.AOR2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR5Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; MST[ConstructorCallMutator]MSP[] ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; MST[rv.AOR3Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[ConditionalsBoundaryMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return null ; MST[ReturnValsMutator]MSP[] } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR1Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ABSMutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR6Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[MathMutator]MSP[] vDown [ 1 + offset ] = start1 ;
while ( i < end1 || j < end2 ) { MST[rv.ROR5Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR3Mutator]MSP[] && end < end1
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOD2Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.AOD2Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[ConditionalsBoundaryMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR4Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR1Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR2Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[ConditionalsBoundaryMutator]MSP[] && end < end1
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI2Mutator]MSP[] if ( m == 0 || n == 0 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
return null ; } final int delta = m - n ; MST[rv.AOR3Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI4Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR1Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI3Mutator]MSP[] int i = start1 ; int j = start2 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR4Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.AOD2Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI3Mutator]MSP[] } int x = vUp [ i ] - 1 ;
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI4Mutator]MSP[] } int x = vUp [ i ] - 1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[MathMutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR2Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI3Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.AOR1Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI4Mutator]MSP[] if ( middle == null
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOD2Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ROR1Mutator]MSP[]
final int i = k + offset ; MST[rv.UOI4Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR2Mutator]MSP[] && end < end1
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI3Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI2Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR4Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI1Mutator]MSP[] ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.AOD1Mutator]MSP[] && end < end1
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI2Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI2Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI3Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI1Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.AOR2Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.AOR1Mutator]MSP[] && end < end1
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ABSMutator]MSP[] && end < end1
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.AOR3Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI4Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.UOI1Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int i = start1 ; int j = start2 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.UOI4Mutator]MSP[] script ) ; } }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI3Mutator]MSP[] if ( middle == null
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; MST[rv.UOI1Mutator]MSP[] ++ j ; } } } } else {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOD1Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI1Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; MST[rv.ABSMutator]MSP[] int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[ConditionalsBoundaryMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[InvertNegsMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[NonVoidMethodCallMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI1Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI2Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR3Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ROR4Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[NonVoidMethodCallMutator]MSP[] script ) ; } }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI3Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ROR1Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI1Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI3Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI2Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ROR2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.CRCR5Mutator]MSP[] } else {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[InlineConstantMutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR2Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[MathMutator]MSP[] if ( m == 0 || n == 0 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
buildScript ( start1 , middle . getStart () , MST[rv.UOI2Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ROR5Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; MST[rv.UOI2Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
int y = x - start1 + start2 - k ; MST[rv.AOR2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[ConditionalsBoundaryMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
buildScript ( start1 , middle . getStart () , MST[rv.UOI1Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR5Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR5Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.CRCR2Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.AOR2Mutator]MSP[] } int x = vUp [ i ] - 1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI3Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI2Mutator]MSP[] y -- ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI1Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI3Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[NegateConditionalsMutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[NonVoidMethodCallMutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.ABSMutator]MSP[] } int x = vUp [ i ] - 1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI2Mutator]MSP[] ++ y ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI3Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI4Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI2Mutator]MSP[] && end < end1
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[ConditionalsBoundaryMutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI1Mutator]MSP[] && end < end1
while ( i < end1 || j < end2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset - delta ; MST[rv.UOI1Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.ABSMutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI2Mutator]MSP[] if ( middle == null
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR4Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.ROR3Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR4Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[MathMutator]MSP[] script ) ; } }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOD2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI1Mutator]MSP[] int y = x - start1 + start2 - k ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[VoidMethodCallMutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI2Mutator]MSP[] && end < end1
while ( i < end1 || j < end2 ) { MST[NegateConditionalsMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.CRCR4Mutator]MSP[] } int x = vUp [ i ] - 1 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOD1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI2Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; MST[rv.ABSMutator]MSP[] while ( end - diag < end2 && end < end1
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.AOD1Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[InlineConstantMutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[ConditionalsBoundaryMutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI1Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI4Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[MathMutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI1Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.AOD2Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[ConditionalsBoundaryMutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[RemoveConditionalMutator_EQUAL_IF]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.UOI3Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.CRCR1Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.AOR3Mutator]MSP[] } else {
while ( i < end1 || j < end2 ) { MST[rv.ABSMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[ConstructorCallMutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.ABSMutator]MSP[] y -- ; }
while ( i < end1 || j < end2 ) { MST[rv.UOI1Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOD2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI3Mutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI1Mutator]MSP[] } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI2Mutator]MSP[] } else {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI3Mutator]MSP[] && end < end1
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.AOD1Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ABSMutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR3Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI3Mutator]MSP[] } int x = vUp [ i ] - 1 ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; MST[rv.UOI4Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR1Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI2Mutator]MSP[] y -- ; }
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[InlineConstantMutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI4Mutator]MSP[] } int x = vUp [ i ] - 1 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[IncrementsMutator]MSP[] ++ y ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR5Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.ROR3Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[MathMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI1Mutator]MSP[] ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.ABSMutator]MSP[] } else {
final int i = k + offset - delta ; MST[rv.AOR1Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI3Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.AOD1Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR5Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[RemoveConditionalMutator_EQUAL_IF]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR3Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOD1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR5Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR3Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI2Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.ABSMutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI3Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NegateConditionalsMutator]MSP[] vUp [ i ] = x -- ; y -- ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI1Mutator]MSP[] if ( middle == null
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR2Mutator]MSP[]
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.ABSMutator]MSP[] if ( middle == null
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[MathMutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; return script ; MST[NullReturnValsMutator]MSP[] }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.CRCR1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[InlineConstantMutator]MSP[] } int x = vUp [ i ] - 1 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ABSMutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR2Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.CRCR4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.ABSMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[NegateConditionalsMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI3Mutator]MSP[] } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR1Mutator]MSP[] int i = start1 ; int j = start2 ;
int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ABSMutator]MSP[]
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI4Mutator]MSP[] if ( middle == null
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.ROR4Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[rv.AOD1Mutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOD2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; MST[rv.ABSMutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOD1Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[]
buildScript ( start1 , middle . getStart () , MST[rv.UOI4Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[InlineConstantMutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOD2Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.AOD1Mutator]MSP[] } int x = vUp [ i ] - 1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[NegateConditionalsMutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR3Mutator]MSP[] int i = start1 ; int j = start2 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR3Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR2Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[MathMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI3Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI1Mutator]MSP[] } int x = vUp [ i ] - 1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.CRCR3Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR4Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.AOR2Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI1Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOD1Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI1Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
int y = x - start1 + start2 - k ; MST[rv.AOD1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI2Mutator]MSP[] } int x = vUp [ i ] - 1 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR4Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.AOR3Mutator]MSP[] script ) ; } }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.UOI4Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.ABSMutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return null ; } final int delta = m - n ; MST[rv.ABSMutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[NegateConditionalsMutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , MST[rv.UOI3Mutator]MSP[] middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
while ( i < end1 || j < end2 ) { MST[rv.UOI1Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI1Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.AOD2Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[MathMutator]MSP[]
while ( i < end1 || j < end2 ) { MST[rv.UOI4Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOD1Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI3Mutator]MSP[] if ( m == 0 || n == 0 ) {
final int i = k + offset - delta ; MST[rv.UOI3Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI3Mutator]MSP[] && end < end1
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI4Mutator]MSP[] ++ y ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR5Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
final int i = k + offset ; MST[rv.AOD2Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
buildScript ( start1 , middle . getStart () , MST[rv.ABSMutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ROR5Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; MST[rv.ABSMutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { MST[rv.ROR2Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR4Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[]
final int i = k + offset ; MST[rv.UOI1Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.AOD2Mutator]MSP[] } else {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.CRCR6Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[MathMutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[NegateConditionalsMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI4Mutator]MSP[] } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.AOR4Mutator]MSP[] if ( m == 0 || n == 0 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
while ( i < end1 || j < end2 ) { MST[rv.ROR1Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.ABSMutator]MSP[] int y = x - start1 + start2 - k ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR5Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.AOD1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.ABSMutator]MSP[] } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
final int i = k + offset ; MST[rv.UOI4Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI1Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; MST[rv.UOI1Mutator]MSP[] while ( end - diag < end2 && end < end1
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI4Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; MST[InlineConstantMutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ABSMutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI4Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[MathMutator]MSP[] } int x = vUp [ i ] - 1 ;
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR1Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI4Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ABSMutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
buildScript ( start1 , middle . getStart () , MST[VoidMethodCallMutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR3Mutator]MSP[] return script ; }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI2Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ABSMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ABSMutator]MSP[] && end < end1
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ROR2Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI1Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.AOR4Mutator]MSP[] int i = start1 ; int j = start2 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; MST[rv.UOI1Mutator]MSP[] int j = start2 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.CRCR2Mutator]MSP[] } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.AOD1Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI3Mutator]MSP[] int y = x - start1 + start2 - k ;
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI3Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[NegateConditionalsMutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.CRCR5Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI3Mutator]MSP[] int i = start1 ; int j = start2 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI4Mutator]MSP[] int y = x - start1 + start2 - k ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI4Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[MathMutator]MSP[]
while ( i < end1 || j < end2 ) { MST[NegateConditionalsMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[MathMutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; return script ; MST[ReturnValsMutator]MSP[] }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; if ( middle == null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] vDown [ i ] = ++ x ; ++ y ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI4Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.ROR2Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; MST[rv.AOD2Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOD1Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI4Mutator]MSP[] y -- ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ABSMutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI1Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
while ( i < end1 || j < end2 ) { MST[rv.UOI3Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR4Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ; MST[rv.UOI1Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[MathMutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR5Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI2Mutator]MSP[] if ( m == 0 || n == 0 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
buildScript ( start1 , middle . getStart () , MST[NonVoidMethodCallMutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR4Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI3Mutator]MSP[] int i = start1 ; int j = start2 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI3Mutator]MSP[] ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR5Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; MST[rv.UOI2Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI4Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NegateConditionalsMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.AOD1Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI3Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[NegateConditionalsMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOD2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
final int i = k + offset - delta ; MST[MathMutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI2Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR6Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.ABSMutator]MSP[] } else {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.AOD1Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI3Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[NegateConditionalsMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; MST[VoidMethodCallMutator]MSP[] ++ j ; } } } } else {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI1Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.UOI3Mutator]MSP[] script ) ; } }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI4Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI3Mutator]MSP[] if ( middle == null
while ( i < end1 || j < end2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI3Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[MathMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI1Mutator]MSP[] } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.UOI3Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI1Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[ConditionalsBoundaryMutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR4Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.ABSMutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[RemoveConditionalMutator_ORDER_IF]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI2Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.AOR4Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI1Mutator]MSP[] && end < end1
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI2Mutator]MSP[] } int x = vUp [ i ] - 1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.AOR1Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR1Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[InlineConstantMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[NegateConditionalsMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ABSMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
while ( i < end1 || j < end2 ) { MST[rv.ROR4Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI2Mutator]MSP[]
return null ; } final int delta = m - n ; MST[rv.UOI1Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; ++ y ; MST[IncrementsMutator]MSP[] }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.CRCR2Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR1Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOD1Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return null ; } final int delta = m - n ; MST[rv.AOR1Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
final int i = k + offset ; MST[rv.AOR3Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI1Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; MST[rv.UOI3Mutator]MSP[] while ( end - diag < end2 && end < end1
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; MST[rv.UOI4Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; MST[IncrementsMutator]MSP[] } else { if ( end1 - start1 > end2 - start2 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[MathMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[MathMutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI4Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.AOR2Mutator]MSP[] script ) ; } }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.ABSMutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[MathMutator]MSP[]
while ( i < end1 || j < end2 ) { MST[rv.ROR5Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; MST[rv.UOI3Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI1Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
while ( i < end1 || j < end2 ) { MST[ConditionalsBoundaryMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR5Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; MST[rv.UOI4Mutator]MSP[] int j = start2 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI2Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR4Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR5Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI1Mutator]MSP[] if ( m == 0 || n == 0 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOD1Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[MathMutator]MSP[] int i = start1 ; int j = start2 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[RemoveConditionalMutator_ORDER_IF]MSP[] && end < end1
final int i = k + offset - delta ; MST[rv.AOR1Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
int y = x - start1 + start2 - k ; MST[rv.AOD1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR5Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ABSMutator]MSP[]
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI2Mutator]MSP[] if ( middle == null
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ROR3Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR5Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.CRCR5Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; MST[experimental.RemoveIncrementsMutator]MSP[] }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI1Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI1Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[NegateConditionalsMutator]MSP[] && end < end1
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.AOR3Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
buildScript ( start1 , middle . getStart () , MST[rv.UOI1Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.AOR1Mutator]MSP[] if ( m == 0 || n == 0 ) {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.ABSMutator]MSP[] if ( middle == null
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[MathMutator]MSP[] && end < end1
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.UOI3Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR2Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI1Mutator]MSP[] if ( middle == null
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.AOD1Mutator]MSP[] } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI2Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] vUp [ i ] = x -- ; y -- ; }
return null ; } final int delta = m - n ; MST[rv.UOI1Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.AOR3Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR1Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR2Mutator]MSP[]
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ROR5Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.CRCR2Mutator]MSP[] } int x = vUp [ i ] - 1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI4Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI4Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI4Mutator]MSP[] && end < end1
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI3Mutator]MSP[] && end < end1
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI4Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR5Mutator]MSP[] && end < end1
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; MST[IncrementsMutator]MSP[] } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[rv.AOD2Mutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.ABSMutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOD1Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[NonVoidMethodCallMutator]MSP[] if ( middle == null
final int i = k + offset - delta ; if ( k == delta - d MST[InlineConstantMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.AOR2Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ABSMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; if ( middle == null MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR3Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR6Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[NegateConditionalsMutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[InlineConstantMutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
final int i = k + offset ; MST[rv.UOI1Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR3Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[MathMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI1Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI4Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR3Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ABSMutator]MSP[] int i = start1 ; int j = start2 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOD2Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[ReturnValsMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
int y = x - start1 + start2 - k ; MST[rv.AOR3Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR4Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR1Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[InlineConstantMutator]MSP[] vDown [ 1 + offset ] = start1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI1Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR4Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.AOD2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ROR2Mutator]MSP[]
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI3Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR2Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.AOR2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[NonVoidMethodCallMutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR5Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR5Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.AOR3Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[ConditionalsBoundaryMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[rv.AOR4Mutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ROR5Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.ABSMutator]MSP[] y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.CRCR6Mutator]MSP[] } else {
while ( i < end1 || j < end2 ) { MST[rv.UOI1Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.CRCR3Mutator]MSP[] } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.AOR3Mutator]MSP[] int i = start1 ; int j = start2 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ; MST[rv.UOI4Mutator]MSP[]
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI2Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI4Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR5Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.CRCR5Mutator]MSP[] } int x = vUp [ i ] - 1 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.ABSMutator]MSP[] ++ y ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI2Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI3Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; MST[VoidMethodCallMutator]MSP[] ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[NegateConditionalsMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] && end < end1
final int i = k + offset ; MST[rv.AOD1Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.UOI2Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; MST[rv.UOI3Mutator]MSP[] ++ j ; } } } } else {
buildScript ( start1 , middle . getStart () , MST[rv.UOI4Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ABSMutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ABSMutator]MSP[] && end < end1
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.CRCR3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.ABSMutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[experimental.RemoveIncrementsMutator]MSP[] y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI1Mutator]MSP[] } int x = vUp [ i ] - 1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR1Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
return null ; } final int delta = m - n ; MST[rv.UOI4Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , MST[VoidMethodCallMutator]MSP[] middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI1Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR6Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset - delta ; MST[rv.AOR2Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR2Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.ABSMutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI4Mutator]MSP[] if ( middle == null
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.AOR4Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI1Mutator]MSP[] y -- ; }
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.ROR2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI3Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NonVoidMethodCallMutator]MSP[] vUp [ i ] = x -- ; y -- ; }
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI3Mutator]MSP[] ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR5Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[ConditionalsBoundaryMutator]MSP[] && end < end1
final int i = k + offset - delta ; if ( k == delta - d MST[MathMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI4Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI4Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI2Mutator]MSP[] } else {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ABSMutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI1Mutator]MSP[] } else {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI2Mutator]MSP[] && end < end1
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI4Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[MathMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ABSMutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR3Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.AOR4Mutator]MSP[]
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.AOR3Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[MathMutator]MSP[] vDown [ 1 + offset ] = start1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.AOD1Mutator]MSP[] int i = start1 ; int j = start2 ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[NegateConditionalsMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ABSMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI2Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI4Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.CRCR5Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR3Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI4Mutator]MSP[] int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[InlineConstantMutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset - delta ; MST[rv.AOR4Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.ABSMutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[]
return null ; } final int delta = m - n ; MST[rv.ABSMutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR2Mutator]MSP[] int i = start1 ; int j = start2 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset - delta ; MST[rv.UOI4Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR3Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
return null ; } final int delta = m - n ; MST[rv.AOR4Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
vUp [ 1 + offset ] = end1 + 1 ; MST[MathMutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
int y = x - start1 + start2 - k ; MST[rv.UOI1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.ABSMutator]MSP[] if ( m == 0 || n == 0 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.ROR3Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
buildScript ( start1 , middle . getStart () , MST[rv.UOI3Mutator]MSP[] start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ROR4Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.AOD2Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
final int i = k + offset - delta ; MST[rv.UOI3Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOD1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , MST[rv.UOI2Mutator]MSP[] middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ROR5Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.AOR1Mutator]MSP[] } else {
while ( i < end1 || j < end2 ) { MST[rv.UOI3Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR5Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[InlineConstantMutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI3Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[NegateConditionalsMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI1Mutator]MSP[] && end < end1
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI2Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI3Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[RemoveConditionalMutator_ORDER_IF]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[ReturnValsMutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR1Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; MST[rv.UOI2Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , MST[rv.ABSMutator]MSP[] middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR4Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.AOR3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[NegateConditionalsMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.ROR4Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ROR1Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR5Mutator]MSP[] int i = start1 ; int j = start2 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NegateConditionalsMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI4Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR6Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI1Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[NegateConditionalsMutator]MSP[] int i = start1 ; int j = start2 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI3Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.CRCR3Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ABSMutator]MSP[] int i = start1 ; int j = start2 ;
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.ROR5Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; MST[IncrementsMutator]MSP[] ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI3Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI4Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR4Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
final int i = k + offset - delta ; MST[rv.ABSMutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.UOI4Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] ++ j ; } } } } else {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.AOD2Mutator]MSP[] if ( m == 0 || n == 0 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.AOR3Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR4Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI4Mutator]MSP[] y -- ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI3Mutator]MSP[] if ( middle == null
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ABSMutator]MSP[] && end < end1
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI1Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI2Mutator]MSP[] int y = x - start1 + start2 - k ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI3Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( i < end1 || j < end2 ) { MST[ConditionalsBoundaryMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; MST[MathMutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI3Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset - delta ; MST[rv.UOI3Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.CRCR6Mutator]MSP[]
final int i = k + offset ; MST[rv.AOR1Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[NonVoidMethodCallMutator]MSP[] script ) ; } }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI4Mutator]MSP[] ++ y ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI4Mutator]MSP[] && end < end1
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[rv.UOI2Mutator]MSP[] ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[NegateConditionalsMutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.ROR2Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { MST[rv.ROR1Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR3Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR2Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ROR3Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.ABSMutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[NegateConditionalsMutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI4Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ROR4Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[InlineConstantMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; MST[rv.AOR4Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[NegateConditionalsMutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR2Mutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.AOR2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; MST[rv.UOI3Mutator]MSP[] final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR5Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR1Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.AOR4Mutator]MSP[] } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[]
int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
while ( i < end1 || j < end2 ) { MST[rv.UOI3Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[MathMutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOD1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI1Mutator]MSP[] if ( m == 0 || n == 0 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI2Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR5Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI4Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[RemoveConditionalMutator_ORDER_IF]MSP[] && end < end1
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOD2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[NegateConditionalsMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI1Mutator]MSP[] && end < end1
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI2Mutator]MSP[] ++ y ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR5Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ROR4Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR4Mutator]MSP[] && end < end1
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[NonVoidMethodCallMutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI3Mutator]MSP[] } int x = vUp [ i ] - 1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI3Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; MST[rv.UOI1Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR1Mutator]MSP[] return script ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOR1Mutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR6Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.ROR4Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[MathMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
int y = x - start1 + start2 - k ; MST[rv.UOI3Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[MathMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI2Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.ABSMutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; MST[VoidMethodCallMutator]MSP[] } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , script ) ; } }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI3Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.AOR1Mutator]MSP[] script ) ; } }
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR3Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.AOR4Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[NullReturnValsMutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI1Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI4Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOR4Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR5Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.AOR3Mutator]MSP[] } int x = vUp [ i ] - 1 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ABSMutator]MSP[] && end < end1
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.ABSMutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] && end < end1
final int i = k + offset ; MST[rv.UOI3Mutator]MSP[] if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR5Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.CRCR2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.UOI1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOR3Mutator]MSP[]
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ROR3Mutator]MSP[] int i = start1 ; int j = start2 ;
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.UOI1Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI1Mutator]MSP[] } int x = vUp [ i ] - 1 ;
int y = x - start1 + start2 - k ; MST[rv.AOR3Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ABSMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.UOI2Mutator]MSP[] } int x = vUp [ i ] - 1 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI2Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.ABSMutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.UOI1Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI3Mutator]MSP[]
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[]
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI3Mutator]MSP[] y -- ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[rv.AOR3Mutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.AOD1Mutator]MSP[]
while ( i < end1 || j < end2 ) { MST[rv.UOI2Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR3Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.ROR5Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR5Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ROR2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
final int i = k + offset - delta ; if ( k == delta - d MST[MathMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI3Mutator]MSP[] } else {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[NegateConditionalsMutator]MSP[] && end < end1
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI2Mutator]MSP[] } else {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR5Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI4Mutator]MSP[] } else {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[VoidMethodCallMutator]MSP[] return script ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[NegateConditionalsMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOD2Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[NegateConditionalsMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.CRCR4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ABSMutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI4Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[MathMutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.AOR1Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ABSMutator]MSP[]
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[NegateConditionalsMutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.ABSMutator]MSP[] script ) ; } }
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.AOR4Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.ROR5Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.UOI2Mutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.AOR3Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.CRCR6Mutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI2Mutator]MSP[] if ( middle == null
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR5Mutator]MSP[] return script ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI1Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR1Mutator]MSP[] && end < end1
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ROR1Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI4Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR1Mutator]MSP[] return script ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.AOR2Mutator]MSP[] int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR3Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI1Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR3Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; MST[rv.UOI3Mutator]MSP[] int j = start2 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.CRCR6Mutator]MSP[] } int x = vUp [ i ] - 1 ;
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI1Mutator]MSP[]
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.UOI4Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.UOI3Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI1Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.AOD1Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[ConditionalsBoundaryMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR2Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR3Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.UOI2Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.ROR3Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[InvertNegsMutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
int y = x - start1 + start2 - k ; MST[rv.ABSMutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI1Mutator]MSP[] && end < end1
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int i = start1 ; int j = start2 ;
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[NonVoidMethodCallMutator]MSP[] return script ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.ABSMutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.UOI3Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.UOI2Mutator]MSP[] script ) ; } }
int y = x - start1 + start2 - k ; MST[rv.AOD1Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
while ( i < end1 || j < end2 ) { MST[rv.ROR3Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI1Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; MST[rv.UOI1Mutator]MSP[] y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.CRCR4Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { MST[rv.ABSMutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR3Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.CRCR6Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI1Mutator]MSP[] int i = start1 ; int j = start2 ;
while ( i < end1 || j < end2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI3Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
vUp [ 1 + offset ] = end1 + 1 ; MST[MathMutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOR1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR5Mutator]MSP[] && end < end1
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ROR3Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { ++ end ; } return new Snake ( start , end , diag ) ; MST[rv.ABSMutator]MSP[] } public int getStart () { return start ; } public int getEnd () {
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR4Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI3Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.UOI1Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; if ( middle == null MST[rv.ROR5Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ABSMutator]MSP[]
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.AOR3Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI1Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
return null ; } final int delta = m - n ; final int sum = n + m ; MST[rv.UOI2Mutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
while ( i < end1 || j < end2 ) { MST[rv.ROR4Mutator]MSP[] if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.ABSMutator]MSP[] vDown [ 1 + offset ] = start1 ;
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[InlineConstantMutator]MSP[] return script ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.ABSMutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) { MST[rv.ABSMutator]MSP[]
buildScript ( start1 , middle . getStart () , start2 , middle . getStart () - middle . getDiag () , MST[MathMutator]MSP[] script ) ; for ( int i = middle . getStart () ; i < middle . getEnd () ; ++ i ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOD2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI1Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR5Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR5Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[ConditionalsBoundaryMutator]MSP[]
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { vDown [ i ] = ++ x ; MST[rv.UOI1Mutator]MSP[] ++ y ; }
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOD2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.ABSMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.AOR2Mutator]MSP[] if ( m == 0 || n == 0 ) {
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.ABSMutator]MSP[] if ( middle == null
final int i = k + offset - delta ; if ( k == delta - d MST[rv.UOI2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; MST[experimental.RemoveIncrementsMutator]MSP[] } else { if ( end1 - start1 > end2 - start2 ) {
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; if ( m == 0 || n == 0 ) { MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.UOI4Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[NonVoidMethodCallMutator]MSP[] return script ; }
private void buildScript ( final int start1 , final int end1 , final int start2 , final int end2 , final EditScript < Character > script ) { final Snake middle = getMiddleSnake ( start1 , end1 , start2 , end2 ) ; MST[rv.UOI1Mutator]MSP[] if ( middle == null
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[rv.AOD1Mutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.UOI2Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.ROR2Mutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[rv.ROR4Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.AOR3Mutator]MSP[] && end < end1
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
return null ; } final int delta = m - n ; final int sum = n + m ; MST[MathMutator]MSP[] final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.CRCR6Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.ABSMutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI3Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.UOI4Mutator]MSP[]
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; MST[rv.UOI2Mutator]MSP[] final int n = end2 - start2 ; if ( m == 0 || n == 0 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOD2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.UOI1Mutator]MSP[]
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI4Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; vDown [ 1 + offset ] = start1 ; MST[rv.ABSMutator]MSP[]
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; MST[IncrementsMutator]MSP[] } } } } else {
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.CRCR4Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; MST[rv.ABSMutator]MSP[] } int x = vUp [ i ] - 1 ;
int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI2Mutator]MSP[] && end < end1
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI3Mutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; MST[rv.ABSMutator]MSP[] } int x = vDown [ i ] ; int y = x - start1 + start2 - k ;
final int i = k + offset - delta ; if ( k == delta - d MST[NegateConditionalsMutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ROR3Mutator]MSP[]
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR2Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { MST[rv.UOI1Mutator]MSP[] for ( int k = - d ; k <= d ; k += 2 ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { if ( vUp [ i ] <= vDown [ i + delta ] ) { MST[rv.AOD1Mutator]MSP[]
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR5Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI4Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ABSMutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[rv.UOI2Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.UOI1Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.AOR1Mutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ABSMutator]MSP[] && end < end1
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI4Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ; MST[rv.UOI3Mutator]MSP[]
script . append ( new DeleteCommand <> ( left . charAt ( i ) ) ) ; ++ i ; MST[IncrementsMutator]MSP[] } else { script . append ( new InsertCommand <> ( right . charAt ( j ) ) ) ; ++ j ; } } } } else {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[rv.CRCR5Mutator]MSP[] return script ; }
vUp [ 1 + offset ] = end1 + 1 ; MST[rv.CRCR3Mutator]MSP[] for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 MST[rv.ROR2Mutator]MSP[] || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { int i = start1 ; int j = start2 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[MathMutator]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.UOI4Mutator]MSP[] int i = start1 ; int j = start2 ;
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOD1Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.CRCR2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
|| middle . getStart () == end1 && middle . getDiag () == end1 - end2 || middle . getEnd () == start1 && middle . getDiag () == start1 - start2 ) { MST[rv.ABSMutator]MSP[] int i = start1 ; int j = start2 ;
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { if ( vUp [ i - delta ] <= vDown [ i ] ) { MST[rv.AOR4Mutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) { MST[rv.ABSMutator]MSP[]
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; MST[rv.UOI3Mutator]MSP[] int y = x - start1 + start2 - k ;
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[NullReturnValsMutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[MathMutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
&& left . charAt ( end ) == right . charAt ( end - diag ) ) { MST[rv.UOI2Mutator]MSP[] ++ end ; } return new Snake ( start , end , diag ) ; } public int getStart () { return start ; } public int getEnd () {
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR2Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
vUp [ i ] = vUp [ i + 1 ] - 1 ; } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ; MST[rv.AOD1Mutator]MSP[]
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.ROR2Mutator]MSP[] && end < end1
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.AOD1Mutator]MSP[]
if ( delta % 2 != 0 && delta - d <= k && k <= delta + d ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( vUp [ i - delta ] <= vDown [ i ] ) {
vDown [ i ] = vDown [ i - 1 ] + 1 ; } int x = vDown [ i ] ; int y = x - start1 + start2 - k ; MST[MathMutator]MSP[]
final int i = k + offset - delta ; if ( k == delta - d MST[RemoveConditionalMutator_ORDER_IF]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.UOI2Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR2Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
return null ; } final int delta = m - n ; final int sum = n + m ; final int offset = ( sum % 2 == 0 ? sum : sum + 1 ) / 2 ; MST[rv.AOR2Mutator]MSP[] vDown [ 1 + offset ] = start1 ;
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { MST[rv.ABSMutator]MSP[] vDown [ i ] = vDown [ i + 1 ] ; } else {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[ConditionalsBoundaryMutator]MSP[]
return buildSnake ( vUp [ i - delta ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR3Mutator]MSP[] } } } for ( int k = delta - d ; k <= delta + d ; k += 2 ) {
int y = x - start1 + start2 - k ; MST[MathMutator]MSP[] while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; } buildScript ( middle . getEnd () , end1 , middle . getEnd () - middle . getDiag () , end2 , MST[rv.AOD1Mutator]MSP[] script ) ; } }
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.UOI4Mutator]MSP[] if ( m == 0 || n == 0 ) {
script . append ( new KeepCommand <> ( left . charAt ( i ) ) ) ; ++ i ; ++ j ; } else { if ( end1 - start1 > end2 - start2 ) { MST[rv.UOI3Mutator]MSP[]
final int i = k + offset ; if ( k == - d || k != d && vDown [ i - 1 ] < vDown [ i + 1 ] ) { vDown [ i ] = vDown [ i + 1 ] ; MST[rv.UOI1Mutator]MSP[] } else {
return buildSnake ( vUp [ i ] , k + start1 - start2 , end1 , end2 ) ; MST[rv.AOR4Mutator]MSP[] } } } } throw new RuntimeException ( lr_1 ) ; }
while ( x < end1 && y < end2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.ROR5Mutator]MSP[] vDown [ i ] = ++ x ; ++ y ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI4Mutator]MSP[] && end < end1
final int i = k + offset - delta ; if ( k == delta - d MST[rv.AOR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; MST[ConstructorCallMutator]MSP[] buildScript ( 0 , left . length () , 0 , right . length () , script ) ; return script ; }
private Snake buildSnake ( final int start , final int diag , final int end1 , final int end2 ) { int end = start ; while ( end - diag < end2 MST[rv.UOI3Mutator]MSP[] && end < end1
public EditScript < Character > getScript () { final EditScript < Character > script = new EditScript <> () ; buildScript ( 0 , left . length () , 0 , right . length () , script ) ; MST[InlineConstantMutator]MSP[] return script ; }
vUp [ 1 + offset ] = end1 + 1 ; for ( int d = 0 ; d <= offset ; ++ d ) { for ( int k = - d ; k <= d ; k += 2 ) { MST[rv.UOI4Mutator]MSP[]
private Snake getMiddleSnake ( final int start1 , final int end1 , final int start2 , final int end2 ) { final int m = end1 - start1 ; final int n = end2 - start2 ; MST[rv.ABSMutator]MSP[] if ( m == 0 || n == 0 ) {
final int i = k + offset - delta ; if ( k == delta - d MST[rv.CRCR2Mutator]MSP[] || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
final int i = k + offset - delta ; MST[rv.ABSMutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
if ( delta % 2 == 0 && - d <= k && k <= d ) { MST[rv.ROR3Mutator]MSP[] if ( vUp [ i ] <= vDown [ i + delta ] ) {
vUp [ i ] = vUp [ i + 1 ] - 1 ; MST[rv.UOI4Mutator]MSP[] } else { vUp [ i ] = vUp [ i - 1 ] ; } int x = vUp [ i ] - 1 ;
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 && left . charAt ( x ) == right . charAt ( y ) ) { MST[rv.UOI3Mutator]MSP[] vUp [ i ] = x -- ; y -- ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.UOI1Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
int y = x - start1 + start2 - k ; while ( x >= start1 && y >= start2 MST[rv.ROR1Mutator]MSP[] && left . charAt ( x ) == right . charAt ( y ) ) { vUp [ i ] = x -- ; y -- ; }
final int i = k + offset - delta ; MST[rv.AOD1Mutator]MSP[] if ( k == delta - d || k != delta + d && vUp [ i + 1 ] <= vUp [ i - 1 ] ) {
while ( i < end1 || j < end2 ) { if ( i < end1 && j < end2 && left . charAt ( i ) == right . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[]
