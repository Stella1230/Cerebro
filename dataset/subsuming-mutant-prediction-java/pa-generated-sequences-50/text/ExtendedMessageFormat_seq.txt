@Override public String toPattern () { return toPattern ; } @Override public final void applyPattern ( final String pattern ) { if ( registry == null ) { super . applyPattern ( pattern ) ; toPattern = super . toPattern () ; return; }
final ArrayList < Format > foundFormats = new ArrayList <> () ; final ArrayList < String > foundDescriptions = new ArrayList <> () ; final StringBuilder stripCustom = new StringBuilder ( pattern . length () ) ; final ParsePosition pos = new ParsePosition ( 0 ) ;
final char [] c = pattern . toCharArray () ; int fmtCount = 0 ; while ( pos . getIndex () < pattern . length () ) { switch ( c [ pos . getIndex () ] ) { case QUOTE :
appendQuotedString ( pattern , pos , stripCustom ) ; break; case START_FE : fmtCount ++ ; seekNonWs ( pattern , pos ) ; final int start = pos . getIndex () ; final int index = readArgumentIndex ( pattern , next ( pos ) ) ;
stripCustom . append ( START_FE ) . append ( index ) ; seekNonWs ( pattern , pos ) ; Format format = null ; String formatDescription = null ; if ( c [ pos . getIndex () ] == START_FMT ) { formatDescription = parseFormatDescription ( pattern ,
next ( pos ) ) ; format = getFormat ( formatDescription ) ; if ( format == null ) { stripCustom . append ( START_FMT ) . append ( formatDescription ) ; } } foundFormats . add ( format ) ;
foundDescriptions . add ( format == null ? null : formatDescription ) ; if ( foundFormats . size () != fmtCount ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( foundDescriptions . size () != fmtCount ) { throw new IllegalArgumentException ( lr_1 ) ; }
if ( c [ pos . getIndex () ] != END_FE ) { throw new IllegalArgumentException ( lr_2 + start ) ; } default: stripCustom . append ( c [ pos . getIndex () ] ) ; next ( pos ) ; } }
super . applyPattern ( stripCustom . toString () ) ; toPattern = insertFormats ( super . toPattern () , foundDescriptions ) ; if ( containsElements ( foundFormats ) ) { final Format [] origFormats = getFormats () ; int i = 0 ;
for ( final Iterator < Format > it = foundFormats . iterator () ; it . hasNext () ; i ++ ) { final Format f = it . next () ; if ( f != null ) { origFormats [ i ] = f ; } }
super . setFormats ( origFormats ) ; } } @Override public void setFormat ( final int formatElementIndex , final Format newFormat ) { throw new UnsupportedOperationException () ; } @Override public void setFormatByArgumentIndex ( final int argumentIndex , final Format newFormat ) { throw new UnsupportedOperationException () ; } @Override
public void setFormats ( final Format [] newFormats ) { throw new UnsupportedOperationException () ; } @Override public void setFormatsByArgumentIndex ( final Format [] newFormats ) { throw new UnsupportedOperationException () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) {
return true ; } if ( obj == null ) { return false ; } if ( ! Objects . equals ( getClass () , obj . getClass () ) ) { return false ; } final ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ;
if ( ! Objects . equals ( toPattern , rhs . toPattern ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } return Objects . equals ( registry , rhs . registry ) ; } @Override
public int hashCode () { int result = super . hashCode () ; result = HASH_SEED * result + Objects . hashCode ( registry ) ; result = HASH_SEED * result + Objects . hashCode ( toPattern ) ; return result ; }
private Format getFormat ( final String desc ) { if ( registry != null ) { String name = desc ; String args = null ; final int i = desc . indexOf ( START_FMT ) ; if ( i > 0 ) {
name = desc . substring ( 0 , i ) . trim () ; args = desc . substring ( i + 1 ) . trim () ; } final FormatFactory factory = registry . get ( name ) ; if ( factory != null ) {
return factory . getFormat ( name , args , getLocale () ) ; } } return null ; } private int readArgumentIndex ( final String pattern , final ParsePosition pos ) { final int start = pos . getIndex () ; seekNonWs ( pattern , pos ) ;
final StringBuilder result = new StringBuilder () ; boolean error = false ; for (; ! error && pos . getIndex () < pattern . length () ; next ( pos ) ) { char c = pattern . charAt ( pos . getIndex () ) ;
if ( Character . isWhitespace ( c ) ) { seekNonWs ( pattern , pos ) ; c = pattern . charAt ( pos . getIndex () ) ; if ( c != START_FMT && c != END_FE ) { error = true ; continue; } }
if ( ( c == START_FMT || c == END_FE ) && result . length () > 0 ) { try { return Integer . parseInt ( result . toString () ) ; } catch ( final NumberFormatException e ) { } }
error = ! Character . isDigit ( c ) ; result . append ( c ) ; } if ( error ) { throw new IllegalArgumentException ( lr_3 + start + lr_4 + pattern . substring ( start , pos . getIndex () ) ) ; }
throw new IllegalArgumentException ( lr_5 + start ) ; } private String parseFormatDescription ( final String pattern , final ParsePosition pos ) { final int start = pos . getIndex () ; seekNonWs ( pattern , pos ) ; final int text = pos . getIndex () ;
int depth = 1 ; while ( pos . getIndex () < pattern . length () ) { switch ( pattern . charAt ( pos . getIndex () ) ) { case START_FE : depth ++ ; next ( pos ) ; break; case END_FE : depth -- ;
if ( depth == 0 ) { return pattern . substring ( text , pos . getIndex () ) ; } next ( pos ) ; break; case QUOTE : getQuotedString ( pattern , pos ) ; break; default: next ( pos ) ; break; } }
throw new IllegalArgumentException ( lr_5 + start ) ; } private String insertFormats ( final String pattern , final ArrayList < String > customPatterns ) { if ( ! containsElements ( customPatterns ) ) { return pattern ; }
final StringBuilder sb = new StringBuilder ( pattern . length () * 2 ) ; final ParsePosition pos = new ParsePosition ( 0 ) ; int fe = - 1 ; int depth = 0 ; while ( pos . getIndex () < pattern . length () ) {
final char c = pattern . charAt ( pos . getIndex () ) ; switch ( c ) { case QUOTE : appendQuotedString ( pattern , pos , sb ) ; break; case START_FE : depth ++ ;
sb . append ( START_FE ) . append ( readArgumentIndex ( pattern , next ( pos ) ) ) ; if ( depth == 1 ) { fe ++ ; final String customPattern = customPatterns . get ( fe ) ; if ( customPattern != null ) {
sb . append ( START_FMT ) . append ( customPattern ) ; } } break; case END_FE : depth -- ; default: sb . append ( c ) ; next ( pos ) ; } } return sb . toString () ; }
private void seekNonWs ( final String pattern , final ParsePosition pos ) { int len = 0 ; final char [] buffer = pattern . toCharArray () ; do {
len = StringMatcherFactory . INSTANCE . splitMatcher () . isMatch ( buffer , pos . getIndex () , 0 , buffer . length ) ; pos . setIndex ( pos . getIndex () + len ) ;
} while ( len > 0 && pos . getIndex () < pattern . length () ); } private ParsePosition next ( final ParsePosition pos ) { pos . setIndex ( pos . getIndex () + 1 ) ; return pos ; }
private StringBuilder appendQuotedString ( final String pattern , final ParsePosition pos , final StringBuilder appendTo ) { assert pattern . toCharArray () [ pos . getIndex () ] == QUOTE : lr_6 ; if ( appendTo != null ) { appendTo . append ( QUOTE ) ; }
next ( pos ) ; final int start = pos . getIndex () ; final char [] c = pattern . toCharArray () ; final int lastHold = start ;
for ( int i = pos . getIndex () ; i < pattern . length () ; i ++ ) { switch ( c [ pos . getIndex () ] ) { case QUOTE : next ( pos ) ;
return appendTo == null ? null : appendTo . append ( c , lastHold , pos . getIndex () - lastHold ) ; default: next ( pos ) ; } } throw new IllegalArgumentException ( lr_7 + start ) ; }
private void getQuotedString ( final String pattern , final ParsePosition pos ) { appendQuotedString ( pattern , pos , null ) ; } private boolean containsElements ( final Collection < ? > coll ) { if ( coll == null || coll . isEmpty () ) { return false ;
} for ( final Object name : coll ) { if ( name != null ) { return true ; } } return false ; }
