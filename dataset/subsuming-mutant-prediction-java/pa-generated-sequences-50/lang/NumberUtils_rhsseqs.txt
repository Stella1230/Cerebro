public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( ! allowSigns ) { return false ; MST[rv.CRCR2Mutator]MSP[N] } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[IncrementsMutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[S]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR3Mutator]MSP[N] } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return createBigInteger ( str ) ; }
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI1Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR2Mutator]MSP[N]
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI4Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.AOD2Mutator]MSP[S]
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.ROR5Mutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.UOI3Mutator]MSP[S] }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR2Mutator]MSP[N] if ( dec == null
} catch ( final NumberFormatException nfe ) { MST[rv.ROR3Mutator]MSP[S] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short min = array [ 0 ] ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR2Mutator]MSP[N] return 1 ; } }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { MST[ConstructorCallMutator]MSP[N] if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( c < a ) { a = c ; } return a ; } public static short min ( short a , final short b , final short c ) { MST[ReturnValsMutator]MSP[N] if ( b < a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR3Mutator]MSP[S] if ( dec == null
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR1Mutator]MSP[N] double min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR1Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR5Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.ROR3Mutator]MSP[S] pfxLen ++ ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; MST[rv.CRCR1Mutator]MSP[N] int i = start ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI1Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return defaultValue ; } try {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR4Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR5Mutator]MSP[N]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI3Mutator]MSP[N] return 1 ; } }
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[NonVoidMethodCallMutator]MSP[N] try {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
if ( c < a ) { a = c ; } return a ; } public static short min ( short a , final short b , final short c ) { MST[rv.UOI4Mutator]MSP[N] if ( b < a ) { a = b ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR6Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.ROR3Mutator]MSP[S]
public static int min ( final int ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[InlineConstantMutator]MSP[S]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[rv.CRCR4Mutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.CRCR6Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.UOI3Mutator]MSP[N] if ( decPos > - 1 ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.AOR1Mutator]MSP[N] break;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR1Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static byte min ( final byte ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { MST[rv.ABSMutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[NegateConditionalsMutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] float max = array [ 0 ] ;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ABSMutator]MSP[S]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI1Mutator]MSP[N] return 1 ; } }
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR1Mutator]MSP[N]
for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR4Mutator]MSP[N] return createBigInteger ( str ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ROR2Mutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[IncrementsMutator]MSP[S] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short max = array [ 0 ] ;
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; MST[ReturnValsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.CRCR2Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.CRCR3Mutator]MSP[N] pfxLen ++ ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR6Mutator]MSP[N] }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR2Mutator]MSP[N] } else { return 1 ; } }
public static int compare ( short x , short y ) { MST[NegateConditionalsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; MST[InlineConstantMutator]MSP[N] } }
radix = 16 ; MST[rv.CRCR2Mutator]MSP[N] pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
public static byte min ( final byte ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[MathMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
int radix = 10 ; MST[rv.ROR3Mutator]MSP[S] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( c < a ) { a = c ; } return a ; } public static int min ( int a , final int b , final int c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b < a ) { a = b ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI4Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR5Mutator]MSP[N] return createBigInteger ( str ) ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.ROR5Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.UOI3Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[InlineConstantMutator]MSP[N] case 'l' : case 'L' : if ( dec == null
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR3Mutator]MSP[S] return createBigInteger ( str ) ; }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR1Mutator]MSP[N] return createBigInteger ( str ) ; }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR2Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] try {
public static byte min ( final byte ... array ) { MST[IncrementsMutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR1Mutator]MSP[N] return 1 ; } }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.AOD1Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR1Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI1Mutator]MSP[S] return false ; } i ++ ; } if ( i < chars . length ) {
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[rv.ROR5Mutator]MSP[N] pfxLen += pfx . length () ; break;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI1Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI3Mutator]MSP[N] return 1 ; } }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] try {
long min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
public static int compare ( int x , int y ) { MST[rv.ROR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if( numDecimals <= 7 ) { MST[rv.CRCR5Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
return false ; MST[ReturnValsMutator]MSP[N] } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.AOR1Mutator]MSP[N] }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; MST[InlineConstantMutator]MSP[S] } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return false ; MST[rv.CRCR5Mutator]MSP[N] } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
int radix = 10 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } } sz -- ; int i = start ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[NonVoidMethodCallMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.ROR3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR6Mutator]MSP[N] return createBigInteger ( str ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; MST[rv.CRCR6Mutator]MSP[N] } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[rv.ROR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI1Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.UOI1Mutator]MSP[S] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[NegateConditionalsMutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[S] float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR3Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR2Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
dec = str . substring ( decPos + 1 ) ; MST[rv.UOI2Mutator]MSP[S] } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.CRCR6Mutator]MSP[S] try {
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.ROR1Mutator]MSP[N] }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' MST[rv.CRCR1Mutator]MSP[N] || chars [ i ] == 'D'
public static int compare ( int x , int y ) { MST[ReturnValsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.CRCR6Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[S]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[rv.ABSMutator]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] double max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR2Mutator]MSP[N]
for ( int j = 1 ; j < array . length ; j ++ ) { MST[PrimitiveReturnsMutator]MSP[N] if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR1Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( ! allowSigns ) { MST[rv.UOI3Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[ArgumentPropagationMutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[InlineConstantMutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ABSMutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[S]
public static byte min ( final byte ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR5Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[rv.CRCR6Mutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[NonVoidMethodCallMutator]MSP[N] if ( dec == null
if ( c > a ) { a = c ; } return a ; } public static int max ( int a , final int b , final int c ) { MST[ReturnValsMutator]MSP[N] if ( b > a ) { a = b ; }
public static int max ( final int ... array ) { validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.ABSMutator]MSP[N]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] short min = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ROR1Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR5Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR4Mutator]MSP[S] double max = array [ 0 ] ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.CRCR6Mutator]MSP[N]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N]
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[InlineConstantMutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.ROR1Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[rv.CRCR3Mutator]MSP[N] }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; MST[rv.CRCR3Mutator]MSP[N] allowSigns = false ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR4Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR2Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
for (; i < chars . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; int i = start ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[MathMutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR3Mutator]MSP[S] if ( str == null ) { return true ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[rv.CRCR5Mutator]MSP[N] return foundDigit && ! hasExp && ! hasDecPoint ; }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; MST[rv.CRCR3Mutator]MSP[N] for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
for ( int j = 1 ; j < array . length ; j ++ ) { MST[ReturnValsMutator]MSP[N] if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.AOR3Mutator]MSP[S]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR5Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
} } if ( pfxLen > 0 ) { MST[rv.ABSMutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short max = array [ 0 ] ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI2Mutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI3Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI2Mutator]MSP[N] return createBigInteger ( str ) ; }
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR3Mutator]MSP[N] } } sz -- ; int i = start ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI4Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[S]
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.UOI1Mutator]MSP[S] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.UOI2Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
if ( hasExp ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } try {
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[InlineConstantMutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR5Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( str == null ) { return true ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOD1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[N] } else { return 1 ; } }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultValue ; } try {
public static int compare ( short x , short y ) { MST[rv.ROR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR5Mutator]MSP[N] } else { return 1 ; } }
public static byte max ( final byte ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( ! allowSigns ) { MST[rv.ROR2Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] long max = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[InlineConstantMutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR4Mutator]MSP[S] double min = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR5Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR2Mutator]MSP[S] float min = array [ 0 ] ;
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[rv.CRCR3Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR1Mutator]MSP[N]
if ( expPos > - 1 ) { MST[rv.UOI1Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR2Mutator]MSP[N] } } sz -- ; int i = start ;
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.UOI3Mutator]MSP[N] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[NegateConditionalsMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR1Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return defaultValue ; } try {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.AOR3Mutator]MSP[S] } else {
return false ; } return ! allowSigns && foundDigit ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[S] float max = array [ 0 ] ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.AOR4Mutator]MSP[N] break;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR4Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
if ( ! allowSigns ) { MST[InlineConstantMutator]MSP[S] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR4Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if( numDecimals <= 7 ) { MST[rv.ABSMutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] float max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[S]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[NegateConditionalsMutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI3Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int max ( final int ... array ) { validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI2Mutator]MSP[S]
public static int max ( final int ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR3Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[InlineConstantMutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR5Mutator]MSP[N] if ( dec == null
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[NegateConditionalsMutator]MSP[S] try {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short max = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
if ( expPos > - 1 ) { MST[rv.UOI4Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR6Mutator]MSP[S] if ( dec == null
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; short max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[rv.ROR1Mutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return true ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] long max = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR2Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.UOI2Mutator]MSP[S]
public static byte max ( final byte ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] float min = array [ 0 ] ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[NonVoidMethodCallMutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[rv.UOI2Mutator]MSP[S] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
public static int max ( final int ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; MST[ReturnValsMutator]MSP[N] }
public static int compare ( long x , long y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} return Double . valueOf ( str ) ; } public static Integer createInteger ( final String str ) { MST[ReturnValsMutator]MSP[N] if ( str == null ) { return null ; } return Integer . decode ( str ) ; } public static Long createLong ( final String str ) {
dec = str . substring ( decPos + 1 ) ; MST[ArgumentPropagationMutator]MSP[N] } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI2Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( ! allowSigns ) { MST[NegateConditionalsMutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ABSMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[NegateConditionalsMutator]MSP[S]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR2Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI2Mutator]MSP[S]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return true ; }
public static int compare ( long x , long y ) { MST[rv.ABSMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.CRCR3Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR4Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
public static byte min ( final byte ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[S]
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.UOI4Mutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ROR4Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ABSMutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
public static int compare ( int x , int y ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[rv.ROR4Mutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[InlineConstantMutator]MSP[S]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI1Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR2Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] double min = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } sz -- ; int i = start ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.UOI2Mutator]MSP[N] } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[NegateConditionalsMutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.UOI4Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.ROR1Mutator]MSP[N] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI3Mutator]MSP[N] }
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.ROR2Mutator]MSP[S] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } } sz -- ; int i = start ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; MST[rv.UOI3Mutator]MSP[N] if ( firstSigDigit == '0' ) { pfxLen ++ ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.ROR3Mutator]MSP[S] } else { return 1 ; } }
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.AOR4Mutator]MSP[N] }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N]
public static int min ( final int ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR6Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[ReturnValsMutator]MSP[N] return - 1 ; } else { return 1 ; } }
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[MathMutator]MSP[N]
if ( expPos > - 1 ) { MST[rv.ROR2Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR5Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
if ( ! allowSigns ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[InlineConstantMutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.UOI2Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; MST[rv.CRCR1Mutator]MSP[N] } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR2Mutator]MSP[N] if ( dec == null
public static int compare ( short x , short y ) { MST[rv.UOI3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI4Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI1Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( ! allowSigns ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static byte min ( final byte ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[InlineConstantMutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int max ( final int ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[NegateConditionalsMutator]MSP[N] return 1 ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ROR2Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.CRCR6Mutator]MSP[N] pfxLen ++ ;
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR1Mutator]MSP[S] if ( str == null ) { return true ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short min = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[NonVoidMethodCallMutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.ROR4Mutator]MSP[S] }
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR3Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( hasExp ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } }
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI2Mutator]MSP[S]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI1Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] float min = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; MST[rv.CRCR3Mutator]MSP[N] } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[rv.CRCR2Mutator]MSP[N] return foundDigit && ! hasExp && ! hasDecPoint ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI4Mutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public static int compare ( long x , long y ) { MST[rv.ROR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
long min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[ArgumentPropagationMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
public static int max ( final int ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( long x , long y ) { MST[NonVoidMethodCallMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[NegateConditionalsMutator]MSP[S] if ( dec == null
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return true ; }
public static int compare ( int x , int y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( long x , long y ) { MST[rv.ROR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[ConditionalsBoundaryMutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int compare ( int x , int y ) { MST[rv.ROR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[ConditionalsBoundaryMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR3Mutator]MSP[S]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.CRCR4Mutator]MSP[N] if ( decPos > - 1 ) {
public static byte max ( final byte ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( expPos > - 1 ) { MST[NegateConditionalsMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI4Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.UOI1Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
public static byte min ( final byte ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[NegateConditionalsMutator]MSP[N] } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] double max = array [ 0 ] ;
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } try {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.AOR1Mutator]MSP[S]
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI1Mutator]MSP[S]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI2Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; MST[rv.CRCR1Mutator]MSP[N] for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
public static int compare ( long x , long y ) { MST[rv.UOI3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR1Mutator]MSP[S] return createBigInteger ( str ) ; }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.UOI1Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR2Mutator]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
public static int compare ( int x , int y ) { MST[NegateConditionalsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if( numDecimals <= 7 ) { MST[rv.ROR5Mutator]MSP[S] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[NegateConditionalsMutator]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
if ( ! allowSigns ) { MST[NegateConditionalsMutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR1Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if( numDecimals <= 7 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.ROR4Mutator]MSP[S] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[NegateConditionalsMutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ROR1Mutator]MSP[S]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[ConditionalsBoundaryMutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.ROR5Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI2Mutator]MSP[N]
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] short max = array [ 0 ] ;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR3Mutator]MSP[N] if ( dec == null
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[experimental.NakedReceiverMutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ABSMutator]MSP[N] }
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[rv.CRCR1Mutator]MSP[N] }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} } if ( pfxLen > 0 ) { MST[rv.ROR5Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
} } if ( pfxLen > 0 ) { MST[rv.UOI4Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if( numDecimals <= 7 ) { MST[rv.UOI4Mutator]MSP[S] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] float min = array [ 0 ] ;
if ( expPos > - 1 ) { MST[ConstructorCallMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( ! allowSigns ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; MST[ReturnValsMutator]MSP[N] int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] float max = array [ 0 ] ;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int max ( final int ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI1Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[rv.ROR5Mutator]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
public static byte max ( final byte ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR4Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ABSMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( int x , int y ) { MST[rv.ROR3Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S] long max = array [ 0 ] ;
public static int min ( final int ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR1Mutator]MSP[S]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; MST[rv.CRCR2Mutator]MSP[N] } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI1Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
if ( ! allowSigns ) { MST[rv.ROR5Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( c > a ) { a = c ; } return a ; } public static int max ( int a , final int b , final int c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b > a ) { a = b ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR2Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.AOR2Mutator]MSP[N] }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI4Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[rv.CRCR6Mutator]MSP[N] case 'l' : case 'L' : if ( dec == null
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR3Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
public static int min ( final int ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR5Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[NegateConditionalsMutator]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short max = array [ 0 ] ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ! allowSigns ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[rv.ROR4Mutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ABSMutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] float min = array [ 0 ] ;
if ( expPos > - 1 ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; MST[rv.CRCR5Mutator]MSP[S] } int pos = 0 ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.CRCR2Mutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR1Mutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
public static byte min ( final byte ... array ) { validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[InlineConstantMutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR6Mutator]MSP[S] if ( str == null ) { return true ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR1Mutator]MSP[N] } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hasExp ) { return false ; MST[rv.CRCR4Mutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
if ( ! allowSigns ) { MST[rv.ROR1Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[NegateConditionalsMutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR4Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( expPos > - 1 ) { MST[rv.ROR5Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR5Mutator]MSP[N] } } sz -- ; int i = start ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ABSMutator]MSP[S] return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] double min = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.AOR2Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[ConstructorCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[NegateConditionalsMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[MathMutator]MSP[N]
Validate . isTrue ( Array . getLength ( array ) != 0 , lr_13 ) ; } public static long min ( long a , final long b , final long c ) { MST[rv.ABSMutator]MSP[N] if ( b < a ) { a = b ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short max = array [ 0 ] ;
if ( c < a ) { a = c ; } return a ; } public static byte min ( byte a , final byte b , final byte c ) { MST[rv.ABSMutator]MSP[N] if ( b < a ) { a = b ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] case 'l' : case 'L' : if ( dec == null
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR5Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
int radix = 10 ; MST[rv.UOI3Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR3Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( long x , long y ) { if ( x == y ) { MST[experimental.RemoveIncrementsMutator]MSP[N] return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( str == null ) { return true ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.UOI2Mutator]MSP[N] try {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[InlineConstantMutator]MSP[N] return - 1 ; } else { return 1 ; } }
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR3Mutator]MSP[N]
public static int compare ( long x , long y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ROR3Mutator]MSP[N]
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR6Mutator]MSP[N]
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.UOI4Mutator]MSP[S]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI4Mutator]MSP[N]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.AOD2Mutator]MSP[S] } else {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR3Mutator]MSP[N] float max = array [ 0 ] ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[S] short min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( dec == null
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR6Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR5Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S]
public static int max ( final int ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR2Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR5Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR3Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[InlineConstantMutator]MSP[N]
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.AOR3Mutator]MSP[S]
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[NonVoidMethodCallMutator]MSP[N] return null ; } int pos = 0 ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR3Mutator]MSP[S] }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } int pos = 0 ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[rv.ROR1Mutator]MSP[N] pfxLen += pfx . length () ; break;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[NonVoidMethodCallMutator]MSP[N] double max = array [ 0 ] ;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } try {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[ArgumentPropagationMutator]MSP[N] }
public static int max ( final int ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' MST[ReturnValsMutator]MSP[N] || chars [ i ] == 'D'
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[rv.ROR5Mutator]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N]
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.AOD1Mutator]MSP[S]
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[rv.CRCR3Mutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] String mant ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI4Mutator]MSP[S] return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} catch ( final NumberFormatException nfe ) { } MST[NullReturnValsMutator]MSP[N] try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.CRCR6Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[NullReturnValsMutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : MST[NonVoidMethodCallMutator]MSP[N] case 'D' : try {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI3Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.AOR1Mutator]MSP[N] } else { return 1 ; } }
int radix = 10 ; boolean negate = false ; MST[rv.CRCR1Mutator]MSP[N] if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] String mant ;
if ( expPos > - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR1Mutator]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[NonVoidMethodCallMutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI2Mutator]MSP[N] }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR3Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[S]
if ( c > a ) { a = c ; } return a ; } public static int max ( int a , final int b , final int c ) { MST[rv.UOI4Mutator]MSP[N] if ( b > a ) { a = b ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR6Mutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; MST[rv.CRCR3Mutator]MSP[S] } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( long x , long y ) { MST[rv.ROR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[NegateConditionalsMutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; MST[NullReturnValsMutator]MSP[N] } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ABSMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} catch ( final NumberFormatException nfe ) { MST[NonVoidMethodCallMutator]MSP[N] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
public static int min ( final int ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI3Mutator]MSP[S] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[NonVoidMethodCallMutator]MSP[N] } else { return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[rv.CRCR5Mutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[InlineConstantMutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR3Mutator]MSP[S] try {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] short max = array [ 0 ] ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[NonVoidMethodCallMutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ABSMutator]MSP[S]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ABSMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.AOR4Mutator]MSP[S] } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { MST[ReturnValsMutator]MSP[N] return f ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR3Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return false ; } return ! allowSigns && foundDigit ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR3Mutator]MSP[N] } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI3Mutator]MSP[N] return createBigInteger ( str ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.UOI3Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static byte min ( final byte ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; MST[rv.CRCR3Mutator]MSP[S] for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR4Mutator]MSP[N] return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ConditionalsBoundaryMutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] float max = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR4Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( long x , long y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[InlineConstantMutator]MSP[S] float min = array [ 0 ] ;
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[rv.ROR5Mutator]MSP[N]
public static int compare ( int x , int y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.CRCR6Mutator]MSP[S] } else {
public static int compare ( long x , long y ) { MST[rv.CRCR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[NonVoidMethodCallMutator]MSP[N] return 1 ; } }
if( numDecimals <= 7 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR5Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI1Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[InlineConstantMutator]MSP[S]
return Math . min ( Math . min ( a , b ) , c ) ; } public static long max ( long a , final long b , final long c ) { MST[rv.UOI2Mutator]MSP[S] if ( b > a ) { a = b ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[S]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.CRCR6Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static byte min ( final byte ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ABSMutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR2Mutator]MSP[N] if ( str == null ) { return true ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.ROR5Mutator]MSP[N] pfxLen ++ ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI3Mutator]MSP[S] return 1 ; } }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
if ( c > a ) { a = c ; } return a ; } public static short max ( short a , final short b , final short c ) { MST[rv.UOI4Mutator]MSP[N] if ( b > a ) { a = b ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR1Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ROR3Mutator]MSP[S]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } else { return 1 ; } }
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[experimental.NakedReceiverMutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } } sz -- ; int i = start ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ABSMutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR2Mutator]MSP[N] return createBigInteger ( str ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static int compare ( short x , short y ) { MST[rv.UOI4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[ConditionalsBoundaryMutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[NegateConditionalsMutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR1Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[experimental.NakedReceiverMutator]MSP[S]
public static int compare ( long x , long y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.ABSMutator]MSP[S] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] short min = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[NegateConditionalsMutator]MSP[N] }
public static int compare ( int x , int y ) { MST[rv.CRCR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.ROR3Mutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
int radix = 10 ; MST[rv.ROR4Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.ABSMutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.ABSMutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI1Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.UOI4Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } } sz -- ; int i = start ;
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultValue ; } try {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[S]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.ROR5Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] double min = array [ 0 ] ;
public static byte max ( final byte ... array ) { validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR1Mutator]MSP[N] }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI3Mutator]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[rv.UOI1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR4Mutator]MSP[N] return 1 ; } }
public static byte max ( final byte ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ABSMutator]MSP[S] return 1 ; } }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } int pos = 0 ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; MST[ReturnValsMutator]MSP[N] } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.ROR4Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
exp = str . substring ( expPos + 1 , str . length () ) ; } else { exp = null ; } if ( dec == null && exp == null ) { MST[NonVoidMethodCallMutator]MSP[N] try { return createInteger ( str ) ;
if ( ! allowSigns ) { MST[rv.CRCR6Mutator]MSP[S] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR4Mutator]MSP[N] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] long max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( ! allowSigns ) { MST[rv.ABSMutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI3Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ROR1Mutator]MSP[N]
if ( c < a ) { a = c ; } return a ; } public static byte min ( byte a , final byte b , final byte c ) { MST[rv.UOI2Mutator]MSP[S] if ( b < a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR2Mutator]MSP[S] try {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR4Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR2Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR4Mutator]MSP[S] try {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR2Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( expPos > - 1 ) { MST[rv.UOI1Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ABSMutator]MSP[S] } } sz -- ; int i = start ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; MST[InlineConstantMutator]MSP[S] for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR1Mutator]MSP[S] if ( dec == null
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR2Mutator]MSP[N] if ( str == null ) { return true ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.AOR2Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.UOI2Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( expPos > - 1 ) { MST[rv.ROR1Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[rv.CRCR6Mutator]MSP[N] return foundDigit && ! hasExp && ! hasDecPoint ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ;
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR1Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] long max = array [ 0 ] ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI2Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short max = array [ 0 ] ;
if ( c > a ) { a = c ; } return a ; } public static byte max ( byte a , final byte b , final byte c ) { MST[rv.UOI1Mutator]MSP[S] if ( b > a ) { a = b ; }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[ReturnValsMutator]MSP[S] return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } } return true ; } } sz -- ; int i = start ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[rv.CRCR3Mutator]MSP[N] }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] case 'l' : case 'L' : if ( dec == null
return Float . parseFloat ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
for (; i < chars . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[MathMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { MST[rv.UOI1Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
} } if ( pfxLen > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR4Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[NegateConditionalsMutator]MSP[N]
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI1Mutator]MSP[S]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[rv.ROR4Mutator]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI2Mutator]MSP[S] validateArray ( array ) ; double max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.ROR1Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR6Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[ConditionalsBoundaryMutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[NegateConditionalsMutator]MSP[N] return createBigInteger ( str ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.UOI3Mutator]MSP[N] break;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.CRCR3Mutator]MSP[S]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR5Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI3Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR2Mutator]MSP[N] if ( str == null ) { return true ; }
return createBigInteger ( numeric ) ; MST[NonVoidMethodCallMutator]MSP[N] } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[S]
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[PrimitiveReturnsMutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] short min = array [ 0 ] ;
if ( c < a ) { a = c ; } return a ; } public static int min ( int a , final int b , final int c ) { MST[rv.UOI4Mutator]MSP[N] if ( b < a ) { a = b ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } } sz -- ; int i = start ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR4Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
public static int max ( final int ... array ) { MST[IncrementsMutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR4Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
final Double d = NumberUtils . createDouble ( numeric ) ; if ( ! ( d . isInfinite () || ( d . floatValue () == 0.0D && ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { } MST[ReturnValsMutator]MSP[S] try {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short min = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { MST[InlineConstantMutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[NegateConditionalsMutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR4Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR5Mutator]MSP[N] }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N]
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR2Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[PrimitiveReturnsMutator]MSP[N] }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR2Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
|| chars [ i ] == 'f' MST[IncrementsMutator]MSP[N] || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
public static int compare ( short x , short y ) { MST[rv.ROR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.UOI1Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[NonVoidMethodCallMutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI3Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
} else if ( chars [ i ] == '.' ) { MST[rv.CRCR3Mutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR4Mutator]MSP[N] return 1 ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
public static int compare ( long x , long y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if( numDecimals <= 7 ) { MST[NegateConditionalsMutator]MSP[S] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR3Mutator]MSP[S] float min = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { MST[NonVoidMethodCallMutator]MSP[N] if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[rv.ROR5Mutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
} } if ( pfxLen > 0 ) { MST[NegateConditionalsMutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI2Mutator]MSP[N]
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[InlineConstantMutator]MSP[N] }
public static int min ( final int ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[ConditionalsBoundaryMutator]MSP[N] return createBigInteger ( str ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.UOI2Mutator]MSP[N] if ( decPos > - 1 ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
dec = str . substring ( decPos + 1 ) ; MST[rv.UOI4Mutator]MSP[N] } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[NegateConditionalsMutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( decPos > - 1 ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( dec == null
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR3Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[rv.UOI4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
int radix = 10 ; MST[rv.ROR1Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ABSMutator]MSP[N] try {
public static int max ( final int ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int min ( final int ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultValue ; } try {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] pfxLen += pfx . length () ; break;
public static int max ( final int ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { MST[InlineConstantMutator]MSP[N] return false ; } } return true ; } } sz -- ; int i = start ;
public static int compare ( short x , short y ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR5Mutator]MSP[N] return createBigInteger ( str ) ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR4Mutator]MSP[N] if ( dec == null
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { MST[rv.CRCR5Mutator]MSP[S]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[rv.UOI4Mutator]MSP[S] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.AOD2Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ;
public static byte min ( final byte ... array ) { validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[NonVoidMethodCallMutator]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; MST[ReturnValsMutator]MSP[N] } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N] short max = array [ 0 ] ;
public static int compare ( short x , short y ) { MST[rv.CRCR4Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
public static int min ( final int ... array ) { validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[ReturnValsMutator]MSP[N]
radix = 16 ; MST[rv.CRCR5Mutator]MSP[N] pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR3Mutator]MSP[N] return createBigInteger ( str ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static byte min ( final byte ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ABSMutator]MSP[S]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
int radix = 10 ; MST[rv.UOI4Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( c > a ) { a = c ; } return a ; } public static short max ( short a , final short b , final short c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b > a ) { a = b ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short min = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; MST[rv.CRCR5Mutator]MSP[N] allowSigns = false ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR3Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR4Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR6Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR1Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR1Mutator]MSP[S] }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ROR2Mutator]MSP[N]
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.UOI1Mutator]MSP[N] try {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR5Mutator]MSP[S] if ( str == null ) { return true ; }
public static int compare ( int x , int y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( chars [ i ] == '.' ) { MST[rv.CRCR2Mutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR2Mutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } try {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI4Mutator]MSP[S] return createBigInteger ( str ) ; }
if ( expPos > - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
public static int max ( final int ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[rv.ROR4Mutator]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.UOI4Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
public static int max ( final int ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR6Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR4Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
if ( c < a ) { a = c ; } return a ; } public static byte min ( byte a , final byte b , final byte c ) { MST[rv.UOI1Mutator]MSP[S] if ( b < a ) { a = b ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.CRCR4Mutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int max ( final int ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.AOR4Mutator]MSP[S]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; double max = array [ 0 ] ;
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.UOI3Mutator]MSP[S]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; short min = array [ 0 ] ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N] short min = array [ 0 ] ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI3Mutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR4Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR5Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR2Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[ConditionalsBoundaryMutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return true ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI1Mutator]MSP[S]
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR1Mutator]MSP[N] }
if ( expPos > - 1 ) { MST[NonVoidMethodCallMutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[InlineConstantMutator]MSP[N] return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[MathMutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { MST[rv.CRCR4Mutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[InlineConstantMutator]MSP[N] double max = array [ 0 ] ;
if( numDecimals <= 7 ) { MST[rv.CRCR3Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI2Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI1Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR3Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.AOR3Mutator]MSP[N] }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[NonVoidMethodCallMutator]MSP[N] pfxLen += pfx . length () ; break;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { MST[rv.CRCR6Mutator]MSP[S]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.AOR1Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI2Mutator]MSP[N] return createBigInteger ( str ) ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR3Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short max = array [ 0 ] ;
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; MST[ReturnValsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[experimental.NakedReceiverMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
&& exp == null && ( numeric . charAt ( 0 ) == '-' && isDigits ( numeric . substring ( 1 ) ) || isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( final NumberFormatException nfe ) { MST[NullReturnValsMutator]MSP[S] }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.UOI1Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] long max = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.CRCR1Mutator]MSP[S]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI1Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI2Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[ReturnValsMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[InlineConstantMutator]MSP[N] return createBigInteger ( str ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR2Mutator]MSP[N] try {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[S]
return Byte . parseByte ( str ) ; MST[PrimitiveReturnsMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[NegateConditionalsMutator]MSP[N] } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI1Mutator]MSP[N] } } sz -- ; int i = start ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR2Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR4Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[NonVoidMethodCallMutator]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[rv.UOI4Mutator]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ABSMutator]MSP[S] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR5Mutator]MSP[N] return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR4Mutator]MSP[S]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.CRCR1Mutator]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[InlineConstantMutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.ROR2Mutator]MSP[N] if ( decPos > - 1 ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
} catch ( final NumberFormatException nfe ) { MST[NegateConditionalsMutator]MSP[N] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[S] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR3Mutator]MSP[S] return - 1 ; } else { return 1 ; } }
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.ABSMutator]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short max = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.AOR3Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[NonVoidMethodCallMutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[InlineConstantMutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR2Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR4Mutator]MSP[N] } else { return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[MathMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; MST[NonVoidMethodCallMutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static int compare ( long x , long y ) { MST[rv.ROR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[NegateConditionalsMutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
int radix = 10 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.UOI2Mutator]MSP[S] if ( str == null ) { return true ; }
if ( hasExp ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ABSMutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int max ( final int ... array ) { validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI4Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) { MST[rv.UOI3Mutator]MSP[N]
radix = 16 ; MST[InlineConstantMutator]MSP[N] pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
return Math . min ( Math . min ( a , b ) , c ) ; } public static long max ( long a , final long b , final long c ) { MST[rv.UOI1Mutator]MSP[S] if ( b > a ) { a = b ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI4Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] String mant ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.CRCR5Mutator]MSP[N] if ( decPos > - 1 ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short min = array [ 0 ] ;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR3Mutator]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR1Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[BooleanFalseReturnValsMutator]MSP[N] return foundDigit && ! hasExp && ! hasDecPoint ; }
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI1Mutator]MSP[N] }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ABSMutator]MSP[N] return createBigInteger ( str ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[S]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] float min = array [ 0 ] ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.UOI4Mutator]MSP[N] } else {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.CRCR1Mutator]MSP[S] try {
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR5Mutator]MSP[N] return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR5Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ReturnValsMutator]MSP[S]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } sz -- ; int i = start ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] short max = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
public static int max ( final int ... array ) { validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[PrimitiveReturnsMutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR4Mutator]MSP[N]
public static int compare ( short x , short y ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; MST[rv.CRCR1Mutator]MSP[N] } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR1Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.ROR5Mutator]MSP[N] } else { return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[InlineConstantMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[NegateConditionalsMutator]MSP[N] pfxLen ++ ;
} catch ( final NumberFormatException nfe ) { MST[rv.ROR5Mutator]MSP[N] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
} catch ( final NumberFormatException nfe ) { MST[NonVoidMethodCallMutator]MSP[N] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[BooleanTrueReturnValsMutator]MSP[S] if ( str == null ) { return true ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI4Mutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR4Mutator]MSP[N] if ( dec == null
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.UOI4Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR5Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
final Double d = NumberUtils . createDouble ( numeric ) ; if ( ! ( d . isInfinite () || ( d . floatValue () == 0.0D && ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { } MST[NonVoidMethodCallMutator]MSP[N] try {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[InlineConstantMutator]MSP[N] }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; MST[rv.CRCR4Mutator]MSP[S] } int pos = 0 ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[NegateConditionalsMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] pfxLen += pfx . length () ; break;
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.AOR1Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
int radix = 10 ; MST[rv.UOI1Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.UOI2Mutator]MSP[S] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI4Mutator]MSP[N] return 1 ; } }
public static byte min ( final byte ... array ) { validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[ReturnValsMutator]MSP[N] }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[NegateConditionalsMutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } } sz -- ; int i = start ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR1Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( int x , int y ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.AOD1Mutator]MSP[S] } else {
public static int min ( final int ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR3Mutator]MSP[N] return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] String mant ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR4Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } try {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] double max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[experimental.BigIntegerMutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[NonVoidMethodCallMutator]MSP[N] double min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return createBigInteger ( str ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] double max = array [ 0 ] ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR4Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR1Mutator]MSP[N]
public static int max ( final int ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR5Mutator]MSP[N] return createBigInteger ( str ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[InlineConstantMutator]MSP[N] return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[ConditionalsBoundaryMutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI3Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR3Mutator]MSP[N] if ( dec == null
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] short min = array [ 0 ] ;
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] String mant ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR4Mutator]MSP[S] }
public static int min ( final int ... array ) { validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI4Mutator]MSP[N]
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[rv.CRCR1Mutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; MST[InlineConstantMutator]MSP[N] } int pos = 0 ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR2Mutator]MSP[N] return createBigInteger ( str ) ; }
public static int max ( final int ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] short max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[S]
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[MathMutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } try {
public static int compare ( long x , long y ) { MST[rv.UOI3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return true ; }
int radix = 10 ; MST[rv.ROR2Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.UOI4Mutator]MSP[N] pfxLen ++ ;
public static int compare ( long x , long y ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ; MST[IncrementsMutator]MSP[S]
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; long max = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.ROR4Mutator]MSP[S]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[NegateConditionalsMutator]MSP[N] } } sz -- ; int i = start ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { MST[IncrementsMutator]MSP[N] negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR5Mutator]MSP[S] return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int max ( final int ... array ) { validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[ReturnValsMutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ABSMutator]MSP[S]
return Math . min ( Math . min ( a , b ) , c ) ; } public static long max ( long a , final long b , final long c ) { MST[rv.ABSMutator]MSP[N] if ( b > a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR6Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.ABSMutator]MSP[N] if ( decPos > - 1 ) {
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.ROR1Mutator]MSP[N]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[InlineConstantMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( int x , int y ) { MST[rv.ROR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI2Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[S]
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[rv.CRCR1Mutator]MSP[N] }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR3Mutator]MSP[S] return 1 ; } }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[experimental.NakedReceiverMutator]MSP[S] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[BooleanFalseReturnValsMutator]MSP[S] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int min ( final int ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI2Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI1Mutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR5Mutator]MSP[N] } } sz -- ; int i = start ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR4Mutator]MSP[N] return createBigInteger ( str ) ; }
return false ; MST[rv.CRCR6Mutator]MSP[N] } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[rv.UOI3Mutator]MSP[S] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[NonVoidMethodCallMutator]MSP[N] if ( dec == null
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[NegateConditionalsMutator]MSP[S]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; MST[BooleanTrueReturnValsMutator]MSP[N] } }
if ( ! allowSigns ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR3Mutator]MSP[N]
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[InlineConstantMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[S] short max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
public static int compare ( short x , short y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
&& exp == null MST[NullReturnValsMutator]MSP[N] && ( numeric . charAt ( 0 ) == '-' && isDigits ( numeric . substring ( 1 ) ) || isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( final NumberFormatException nfe ) { }
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.CRCR6Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR1Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } try {
public static int compare ( long x , long y ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; }
return Byte . parseByte ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[InlineConstantMutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ROR2Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int min ( final int ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; MST[InlineConstantMutator]MSP[N] allowSigns = false ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[NonVoidMethodCallMutator]MSP[N] return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.CRCR3Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static byte min ( final byte ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.CRCR3Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI1Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
public static int min ( final int ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; MST[ConstructorCallMutator]MSP[N] } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ;
dec = str . substring ( decPos + 1 ) ; MST[rv.UOI3Mutator]MSP[N] } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[MathMutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
int radix = 10 ; MST[rv.ABSMutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
radix = 16 ; MST[rv.CRCR4Mutator]MSP[N] pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { MST[rv.ROR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
radix = 16 ; pos += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N] } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR3Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[S]
if( numDecimals <= 7 ) { MST[rv.UOI3Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[NonVoidMethodCallMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; MST[NonVoidMethodCallMutator]MSP[N] try {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short min = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR5Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.ROR4Mutator]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
} } if ( pfxLen > 0 ) { MST[rv.ROR4Mutator]MSP[S] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.CRCR1Mutator]MSP[N] pfxLen ++ ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR3Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
} } if ( pfxLen > 0 ) { MST[rv.UOI3Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[PrimitiveReturnsMutator]MSP[N] return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.ABSMutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[NegateConditionalsMutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; double max = array [ 0 ] ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ABSMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return false ; } return ! allowSigns && foundDigit ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[NegateConditionalsMutator]MSP[N] return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
if( numDecimals <= 7 ) { MST[rv.ROR4Mutator]MSP[S] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR3Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; MST[rv.ABSMutator]MSP[N] if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[NegateConditionalsMutator]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI1Mutator]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR5Mutator]MSP[S]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[InlineConstantMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI4Mutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return true ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.UOI4Mutator]MSP[S]
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[S] float min = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[rv.ROR3Mutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.UOI1Mutator]MSP[N] if ( decPos > - 1 ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR1Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR1Mutator]MSP[N] } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR5Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] float max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( byte x , byte y ) { return x - y ; } MST[ReturnValsMutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ABSMutator]MSP[N] if ( str == null ) { return true ; }
public static int compare ( int x , int y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hasExp ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[NonVoidMethodCallMutator]MSP[S] try {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR4Mutator]MSP[S] float min = array [ 0 ] ;
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[rv.ROR5Mutator]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
if ( ! allowSigns ) { MST[rv.ROR4Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[S]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } } sz -- ; int i = start ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR5Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR4Mutator]MSP[S] } } sz -- ; int i = start ;
if ( expPos > - 1 ) { MST[rv.ROR4Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[ReturnValsMutator]MSP[S] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
Validate . isTrue ( Array . getLength ( array ) != 0 , lr_13 ) ; } public static long min ( long a , final long b , final long c ) { MST[rv.UOI2Mutator]MSP[S] if ( b < a ) { a = b ; }
if ( expPos > - 1 ) { MST[experimental.NakedReceiverMutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR5Mutator]MSP[N] }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.AOR2Mutator]MSP[N] break;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI4Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR2Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI2Mutator]MSP[S] return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[InlineConstantMutator]MSP[N] if ( decPos > - 1 ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR3Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI4Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[S]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[rv.ROR1Mutator]MSP[N] return null ; } int pos = 0 ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.ROR3Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( decPos > - 1 ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[rv.ROR3Mutator]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI3Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR2Mutator]MSP[S] return false ; } i ++ ; } if ( i < chars . length ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[N]
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return defaultValue ; } try {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI1Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
public static int compare ( int x , int y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { MST[BooleanTrueReturnValsMutator]MSP[S]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.UOI2Mutator]MSP[S] break;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
radix = 16 ; MST[rv.CRCR3Mutator]MSP[N] pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[rv.UOI3Mutator]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[rv.ROR5Mutator]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR2Mutator]MSP[N]
if( numDecimals <= 7 ) { MST[NegateConditionalsMutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] String mant ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR3Mutator]MSP[N] return createBigInteger ( str ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR6Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR1Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI3Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ;
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR1Mutator]MSP[S] if ( str == null ) { return true ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR3Mutator]MSP[S] return false ; } i ++ ; } if ( i < chars . length ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[ConstructorCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOD1Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( chars [ i ] == '.' ) { MST[rv.CRCR6Mutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.AOD2Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR3Mutator]MSP[N] double max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR5Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI1Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] float min = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR4Mutator]MSP[N]
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR6Mutator]MSP[N] }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[InlineConstantMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[ConditionalsBoundaryMutator]MSP[N] return createBigInteger ( str ) ; }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[S]
public static int max ( final int ... array ) { validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI3Mutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[InlineConstantMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR4Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR5Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } sz -- ; int i = start ;
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
exp = str . substring ( expPos + 1 , str . length () ) ; } else { exp = null ; } if ( dec == null && exp == null ) { MST[ReturnValsMutator]MSP[N] try { return createInteger ( str ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.AOR4Mutator]MSP[S] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI1Mutator]MSP[S] validateArray ( array ) ; double max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ABSMutator]MSP[S] return false ; } i ++ ; } if ( i < chars . length ) {
if ( expPos > - 1 ) { MST[rv.UOI2Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static byte min ( final byte ... array ) { validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[PrimitiveReturnsMutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ABSMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
public static int compare ( long x , long y ) { MST[rv.ROR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return true ; }
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[ReturnValsMutator]MSP[N] }
public static int compare ( int x , int y ) { MST[rv.CRCR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR5Mutator]MSP[N] }
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return defaultValue ; } try {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.UOI3Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI4Mutator]MSP[N] }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.UOI3Mutator]MSP[N] } else {
public static int compare ( int x , int y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] case 'l' : case 'L' : if ( dec == null
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI1Mutator]MSP[N] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
long min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.ROR2Mutator]MSP[S] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR5Mutator]MSP[N] return 1 ; } }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; MST[rv.UOI4Mutator]MSP[N] if ( firstSigDigit == '0' ) { pfxLen ++ ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR5Mutator]MSP[S] return createBigInteger ( str ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR2Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; MST[rv.UOI1Mutator]MSP[N] if ( firstSigDigit == '0' ) { pfxLen ++ ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
} catch ( final NumberFormatException nfe ) { MST[rv.ROR4Mutator]MSP[N] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR6Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.ROR4Mutator]MSP[N] } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.ROR1Mutator]MSP[N] } else { return 1 ; } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] String mant ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N]
if ( expPos > - 1 ) { MST[rv.ABSMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static int min ( final int ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( long x , long y ) { MST[NegateConditionalsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[InlineConstantMutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static byte max ( final byte ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] long max = array [ 0 ] ;
public static int max ( final int ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] long max = array [ 0 ] ;
return Float . parseFloat ( str ) ; MST[ReturnValsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
int radix = 10 ; MST[NegateConditionalsMutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ROR5Mutator]MSP[N]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] short min = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.CRCR5Mutator]MSP[S]
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.UOI3Mutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[InlineConstantMutator]MSP[S] return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } int pos = 0 ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR4Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR5Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return createBigInteger ( str ) ; }
public static byte min ( final byte ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.ROR5Mutator]MSP[N] }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.CRCR2Mutator]MSP[N] pfxLen ++ ;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.UOI3Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR3Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.CRCR5Mutator]MSP[S] try {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[NonVoidMethodCallMutator]MSP[S] float min = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( short x , short y ) { MST[ReturnValsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte min ( final byte ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } } return true ; } } sz -- ; int i = start ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[PrimitiveReturnsMutator]MSP[N] double max = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { MST[InlineConstantMutator]MSP[S]
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[rv.CRCR5Mutator]MSP[N] }
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[rv.ROR4Mutator]MSP[N]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
public static int compare ( int x , int y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR2Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI4Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short min = array [ 0 ] ;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ABSMutator]MSP[N] return 1 ; } }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; MST[rv.CRCR3Mutator]MSP[S] } int pos = 0 ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[ConditionalsBoundaryMutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.ROR2Mutator]MSP[N] }
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR1Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI4Mutator]MSP[N] return 1 ; } }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.ROR4Mutator]MSP[N] pfxLen ++ ;
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR3Mutator]MSP[N] }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[NegateConditionalsMutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR1Mutator]MSP[N] return createBigInteger ( str ) ; }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
if ( c < a ) { a = c ; } return a ; } public static short min ( short a , final short b , final short c ) { MST[rv.UOI3Mutator]MSP[N] if ( b < a ) { a = b ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( ! allowSigns ) { MST[rv.UOI4Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short max = array [ 0 ] ;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI2Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.CRCR5Mutator]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
if ( c > a ) { a = c ; } return a ; } public static byte max ( byte a , final byte b , final byte c ) { MST[ReturnValsMutator]MSP[N] if ( b > a ) { a = b ; }
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI4Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR5Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI1Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.UOI2Mutator]MSP[S] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
for ( int i = 1 ; i < array . length ; i ++ ) { MST[PrimitiveReturnsMutator]MSP[N] if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; }
return false ; } return ! allowSigns && foundDigit ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[ArgumentPropagationMutator]MSP[N] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR2Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR5Mutator]MSP[N] return createBigInteger ( str ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[ArgumentPropagationMutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[BooleanTrueReturnValsMutator]MSP[N] return 1 ; } }
public static byte max ( final byte ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} else if ( chars [ i ] == '.' ) { MST[ReturnValsMutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] long max = array [ 0 ] ;
public static int compare ( int x , int y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else if ( chars [ i ] == '.' ) { MST[rv.CRCR5Mutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR3Mutator]MSP[N]
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.ROR4Mutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.UOI4Mutator]MSP[N] }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR2Mutator]MSP[N] return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR4Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.ROR2Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] float min = array [ 0 ] ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR6Mutator]MSP[N] return 1 ; } }
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.UOI1Mutator]MSP[S] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { MST[NullReturnValsMutator]MSP[N] return f ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOD2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.UOI4Mutator]MSP[N] if ( decPos > - 1 ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : MST[NonVoidMethodCallMutator]MSP[N] case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[BooleanTrueReturnValsMutator]MSP[S]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; MST[rv.CRCR3Mutator]MSP[N] } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ABSMutator]MSP[N] return createBigInteger ( str ) ; }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI2Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR2Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; MST[PrimitiveReturnsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR1Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] double max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI2Mutator]MSP[S] return false ; } i ++ ; } if ( i < chars . length ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.CRCR2Mutator]MSP[S]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return true ; }
return Integer . parseInt ( str ) ; MST[PrimitiveReturnsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR3Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } try {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static byte max ( final byte ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( c < a ) { a = c ; } return a ; } public static byte min ( byte a , final byte b , final byte c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b < a ) { a = b ; }
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( chars [ i ] == '.' ) { MST[rv.CRCR3Mutator]MSP[S] if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[MathMutator]MSP[N] } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ABSMutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return true ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR4Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int max ( final int ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( long x , long y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
for (; i < chars . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ABSMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; MST[rv.UOI2Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR4Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI4Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.ROR5Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR5Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { MST[NonVoidMethodCallMutator]MSP[N] if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[InlineConstantMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI2Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ABSMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N] double max = array [ 0 ] ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ABSMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR4Mutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[ReturnValsMutator]MSP[N] return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.UOI3Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[NegateConditionalsMutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.UOI2Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.AOR3Mutator]MSP[N] break;
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; MST[rv.CRCR3Mutator]MSP[N] int i = start ;
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI3Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI4Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI3Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR6Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
int radix = 10 ; MST[rv.ABSMutator]MSP[S] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI1Mutator]MSP[S] return 1 ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[S]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[rv.CRCR6Mutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[rv.ROR2Mutator]MSP[S] return null ; } int pos = 0 ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; MST[rv.CRCR2Mutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR1Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR3Mutator]MSP[N] } } sz -- ; int i = start ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI1Mutator]MSP[N] return createBigInteger ( str ) ; }
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.ABSMutator]MSP[S] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.CRCR4Mutator]MSP[N]
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[IncrementsMutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.ROR5Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI2Mutator]MSP[S] return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR2Mutator]MSP[N] } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[S]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI2Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int compare ( long x , long y ) { MST[rv.ABSMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.AOR1Mutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR1Mutator]MSP[N] } } sz -- ; int i = start ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.ROR5Mutator]MSP[N] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR3Mutator]MSP[N] double min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI2Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ABSMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
if( numDecimals <= 7 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[rv.ROR3Mutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR1Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[NonVoidMethodCallMutator]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return createBigInteger ( numeric ) ; MST[experimental.NakedReceiverMutator]MSP[S] } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; MST[rv.CRCR4Mutator]MSP[N] } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[InlineConstantMutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.AOD1Mutator]MSP[N] break;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[NegateConditionalsMutator]MSP[N] if ( dec == null
public static byte max ( final byte ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR5Mutator]MSP[N] } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI4Mutator]MSP[N] return createBigInteger ( str ) ; }
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return defaultValue ; } try {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[S] double min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; long max = array [ 0 ] ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[InlineConstantMutator]MSP[N] }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ABSMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR3Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
public static int max ( final int ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . min ( Math . min ( a , b ) , c ) ; } public static long max ( long a , final long b , final long c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b > a ) { a = b ; }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.UOI3Mutator]MSP[N] pfxLen ++ ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[NegateConditionalsMutator]MSP[N] case 'l' : case 'L' : if ( dec == null
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static int min ( final int ... array ) { validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI3Mutator]MSP[N]
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int max ( final int ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR4Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : try { MST[ReturnValsMutator]MSP[N]
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } try {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ABSMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR5Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR4Mutator]MSP[S] float max = array [ 0 ] ;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { MST[experimental.NakedReceiverMutator]MSP[N] if ( expPos > - 1 ) { if ( expPos > str . length () ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.UOI2Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( ! allowSigns ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
Validate . isTrue ( Array . getLength ( array ) != 0 , lr_13 ) ; } public static long min ( long a , final long b , final long c ) { MST[rv.UOI1Mutator]MSP[S] if ( b < a ) { a = b ; }
if ( ! allowSigns ) { return false ; MST[rv.CRCR4Mutator]MSP[S] } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI3Mutator]MSP[N] }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.UOI2Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[NonVoidMethodCallMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR1Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI4Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[ArgumentPropagationMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.ROR2Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.CRCR4Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( ! allowSigns ) { MST[rv.UOI3Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR5Mutator]MSP[N]
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR3Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[rv.ROR2Mutator]MSP[S] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR6Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI3Mutator]MSP[S]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR1Mutator]MSP[S] return - 1 ; } else { return 1 ; } }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
public static byte min ( final byte ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[experimental.NakedReceiverMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR1Mutator]MSP[N] float max = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI2Mutator]MSP[N]
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR1Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.CRCR5Mutator]MSP[N] pfxLen ++ ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[InlineConstantMutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.UOI1Mutator]MSP[S] break;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] float max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR2Mutator]MSP[N] } } sz -- ; int i = start ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' MST[rv.CRCR3Mutator]MSP[N] || chars [ i ] == 'D'
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ROR3Mutator]MSP[S]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[S]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.UOI3Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; double max = array [ 0 ] ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ABSMutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static byte min ( final byte ... array ) { MST[rv.CRCR5Mutator]MSP[S] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[ConstructorCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
if ( expPos > - 1 ) { MST[rv.ROR3Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR1Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[NegateConditionalsMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[NonVoidMethodCallMutator]MSP[S] if ( dec == null
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI3Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.AOR2Mutator]MSP[S] } else {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI3Mutator]MSP[N] } } sz -- ; int i = start ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR3Mutator]MSP[S] if ( dec == null
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] double min = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI2Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short max = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( ! allowSigns ) { MST[rv.ROR3Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[rv.ROR1Mutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ABSMutator]MSP[N]
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] long max = array [ 0 ] ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR1Mutator]MSP[N] if ( dec == null
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[NonVoidMethodCallMutator]MSP[N] float max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI1Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[rv.CRCR3Mutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.CRCR5Mutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.ABSMutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR3Mutator]MSP[N]
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[rv.ROR2Mutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
long min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
for ( int i = 1 ; i < array . length ; i ++ ) { MST[PrimitiveReturnsMutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOD1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.AOD1Mutator]MSP[N] }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
return createBigInteger ( numeric ) ; MST[NonVoidMethodCallMutator]MSP[N] } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR3Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; short max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR2Mutator]MSP[S] if ( dec == null
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[PrimitiveReturnsMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR3Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOD2Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.UOI4Mutator]MSP[N] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] double max = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.AOR2Mutator]MSP[S]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; MST[NullReturnValsMutator]MSP[N] }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] try {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR5Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; MST[ReturnValsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.ROR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return createBigInteger ( str ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Float . parseFloat ( str ) ; MST[PrimitiveReturnsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] String mant ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR6Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
} catch ( final NumberFormatException nfe ) { MST[NonVoidMethodCallMutator]MSP[S] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Integer . parseInt ( str ) ; MST[ReturnValsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( c < a ) { a = c ; } return a ; } public static byte min ( byte a , final byte b , final byte c ) { MST[ReturnValsMutator]MSP[N] if ( b < a ) { a = b ; }
return Math . min ( Math . min ( a , b ) , c ) ; } public static long max ( long a , final long b , final long c ) { MST[rv.UOI4Mutator]MSP[N] if ( b > a ) { a = b ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR5Mutator]MSP[S] if ( dec == null
if ( expPos > - 1 ) { MST[rv.UOI2Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ABSMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( expPos > - 1 ) { MST[rv.UOI3Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static byte min ( final byte ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( str == null ) { return true ; }
if ( c > a ) { a = c ; } return a ; } public static byte max ( byte a , final byte b , final byte c ) { MST[rv.UOI2Mutator]MSP[S] if ( b > a ) { a = b ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] short max = array [ 0 ] ;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[NegateConditionalsMutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR1Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR4Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[experimental.NakedReceiverMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int min ( final int ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR5Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ConditionalsBoundaryMutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR1Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
int radix = 10 ; MST[rv.UOI3Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[InlineConstantMutator]MSP[N] if ( dec == null
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR2Mutator]MSP[S] try {
if ( ! allowSigns ) { MST[rv.ROR2Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.CRCR5Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S] short max = array [ 0 ] ;
public static int min ( final int ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[rv.ROR5Mutator]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR6Mutator]MSP[S] return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.ROR2Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[S] float max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR5Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[PrimitiveReturnsMutator]MSP[N] double min = array [ 0 ] ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.UOI4Mutator]MSP[N] break;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[InlineConstantMutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short min = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[NegateConditionalsMutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.UOI2Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NullReturnValsMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.AOR3Mutator]MSP[N] } else { return 1 ; } }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.CRCR5Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] pfxLen ++ ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[S]
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[NegateConditionalsMutator]MSP[N] pfxLen += pfx . length () ; break;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] short max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[S]
if ( ! allowSigns ) { MST[rv.CRCR5Mutator]MSP[S] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR3Mutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; MST[rv.CRCR5Mutator]MSP[N] } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N] double min = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[ConditionalsBoundaryMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.AOR4Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] long max = array [ 0 ] ;
if ( c > a ) { a = c ; } return a ; } public static int max ( int a , final int b , final int c ) { MST[rv.UOI3Mutator]MSP[N] if ( b > a ) { a = b ; }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return true ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[InlineConstantMutator]MSP[N] return foundDigit && ! hasExp && ! hasDecPoint ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR6Mutator]MSP[S] }
for (; i < chars . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; int i = start ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR2Mutator]MSP[S] }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI2Mutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI3Mutator]MSP[N]
int radix = 10 ; boolean negate = false ; MST[rv.CRCR2Mutator]MSP[N] if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( expPos > - 1 ) { MST[rv.ABSMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { MST[rv.CRCR1Mutator]MSP[S]
public static byte min ( final byte ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short max = array [ 0 ] ;
if ( c > a ) { a = c ; } return a ; } public static byte max ( byte a , final byte b , final byte c ) { MST[rv.ABSMutator]MSP[N] if ( b > a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
public static int min ( final int ... array ) { MST[IncrementsMutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( long x , long y ) { MST[rv.ROR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR3Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[NegateConditionalsMutator]MSP[N] return 1 ; } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR2Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[NegateConditionalsMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI1Mutator]MSP[S]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[NegateConditionalsMutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.ABSMutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
public static int compare ( long x , long y ) { MST[rv.CRCR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOD1Mutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.CRCR2Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.AOR1Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR3Mutator]MSP[S] if ( str == null ) { return true ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR5Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR4Mutator]MSP[S] return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[ConditionalsBoundaryMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; MST[rv.CRCR6Mutator]MSP[S] for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ABSMutator]MSP[N]
public static int max ( final int ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { MST[NonVoidMethodCallMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.ABSMutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
} catch ( final NumberFormatException nfe ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[rv.UOI2Mutator]MSP[N] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static byte max ( final byte ... array ) { validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
int radix = 10 ; boolean negate = false ; MST[rv.CRCR5Mutator]MSP[N] if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR2Mutator]MSP[S] if ( dec == null
public static byte max ( final byte ... array ) { validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[S]
if ( ! allowSigns ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[S] long max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI3Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR4Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( str == null ) { return true ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR4Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int compare ( short x , short y ) { MST[rv.UOI1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[S] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[NonVoidMethodCallMutator]MSP[S]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[ReturnValsMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[InlineConstantMutator]MSP[N] float max = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR2Mutator]MSP[S]
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.AOR4Mutator]MSP[N]
public static byte max ( final byte ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[ReturnValsMutator]MSP[N] if ( str == null ) { return true ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI2Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] short max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI3Mutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR2Mutator]MSP[N] return 1 ; } }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return defaultValue ; } try {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[S]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static int min ( final int ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N]
if ( ! allowSigns ) { return false ; MST[InlineConstantMutator]MSP[N] } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR5Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[ReturnValsMutator]MSP[N] }
public static int compare ( long x , long y ) { MST[rv.UOI1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR1Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static byte min ( final byte ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[NegateConditionalsMutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[MathMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if( numDecimals <= 7 ) { MST[rv.ROR1Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[ConstructorCallMutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR2Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
public static int max ( final int ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] double max = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] String mant ;
} catch ( final NumberFormatException nfe ) { } MST[ReturnValsMutator]MSP[N] try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try {
public static int compare ( long x , long y ) { MST[rv.UOI4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR3Mutator]MSP[S] }
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.CRCR5Mutator]MSP[S]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return true ; }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[rv.ROR5Mutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] float min = array [ 0 ] ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[InlineConstantMutator]MSP[N] } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[MathMutator]MSP[N] String mant ;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR3Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static byte min ( final byte ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[ConditionalsBoundaryMutator]MSP[S] return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR5Mutator]MSP[S]
public static int compare ( int x , int y ) { MST[rv.CRCR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.AOD2Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.CRCR2Mutator]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return true ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR4Mutator]MSP[N] if ( dec == null
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[InlineConstantMutator]MSP[N]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.CRCR2Mutator]MSP[S] } else {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[rv.ROR2Mutator]MSP[S] throw new NumberFormatException ( lr_1 ) ; }
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } try {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.CRCR6Mutator]MSP[N] if ( decPos > - 1 ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[NegateConditionalsMutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.UOI3Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI3Mutator]MSP[N]
public static byte max ( final byte ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( short x , short y ) { MST[rv.UOI4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[ConditionalsBoundaryMutator]MSP[S]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR2Mutator]MSP[N]
public static int max ( final int ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( long x , long y ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } try {
public static int compare ( long x , long y ) { MST[rv.UOI1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return true ; }
public static int compare ( long x , long y ) { MST[rv.ROR2Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
if ( ! allowSigns ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; MST[rv.CRCR6Mutator]MSP[N] } int pos = 0 ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; MST[NullReturnValsMutator]MSP[N] } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI2Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } } sz -- ; int i = start ;
final Double d = NumberUtils . createDouble ( numeric ) ; if ( ! ( d . isInfinite () || ( d . floatValue () == 0.0D && ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { } MST[NullReturnValsMutator]MSP[S] try {
if ( c < a ) { a = c ; } return a ; } public static int min ( int a , final int b , final int c ) { MST[rv.UOI3Mutator]MSP[N] if ( b < a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR4Mutator]MSP[N] return 1 ; } }
public static int compare ( long x , long y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[PrimitiveReturnsMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[PrimitiveReturnsMutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR1Mutator]MSP[N] return - 1 ; } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ABSMutator]MSP[N] return 1 ; } }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.AOR4Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR2Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[S] double min = array [ 0 ] ;
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[ReturnValsMutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[ConditionalsBoundaryMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[PrimitiveReturnsMutator]MSP[N] }
public static byte max ( final byte ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI4Mutator]MSP[N] } } sz -- ; int i = start ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR6Mutator]MSP[N] return 1 ; } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR2Mutator]MSP[N] } } sz -- ; int i = start ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] double max = array [ 0 ] ;
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI3Mutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[rv.ROR3Mutator]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
return false ; MST[rv.CRCR1Mutator]MSP[N] } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR2Mutator]MSP[N] return createBigInteger ( str ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[BooleanTrueReturnValsMutator]MSP[N]
if ( expPos > - 1 ) { MST[rv.ROR2Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if( numDecimals <= 7 ) { MST[rv.CRCR1Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[BooleanTrueReturnValsMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[rv.CRCR6Mutator]MSP[N] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[S]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } } sz -- ; int i = start ;
int radix = 10 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR2Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( long x , long y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { MST[ReturnValsMutator]MSP[N] return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : try {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI1Mutator]MSP[N] } } sz -- ; int i = start ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] short min = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR6Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] long max = array [ 0 ] ;
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultValue ; } try {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[InlineConstantMutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static byte max ( final byte ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
Validate . isTrue ( Array . getLength ( array ) != 0 , lr_13 ) ; } public static long min ( long a , final long b , final long c ) { MST[rv.UOI4Mutator]MSP[N] if ( b < a ) { a = b ; }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[S] } try {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.CRCR2Mutator]MSP[S]
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static int compare ( long x , long y ) { MST[rv.ROR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.AOR2Mutator]MSP[S]
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[InlineConstantMutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR1Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) { MST[rv.UOI1Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) { MST[rv.UOI4Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR5Mutator]MSP[N] }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.ROR3Mutator]MSP[N] if ( decPos > - 1 ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short min = array [ 0 ] ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.AOD2Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI4Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI2Mutator]MSP[N]
if ( c > a ) { a = c ; } return a ; } public static short max ( short a , final short b , final short c ) { MST[rv.UOI3Mutator]MSP[N] if ( b > a ) { a = b ; }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[InlineConstantMutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[N]
if ( expPos > - 1 ) { MST[ConstructorCallMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[S] float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
return Math . min ( Math . min ( a , b ) , c ) ; } public static long max ( long a , final long b , final long c ) { MST[ReturnValsMutator]MSP[N] if ( b > a ) { a = b ; }
public static int compare ( int x , int y ) { MST[rv.ROR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] float max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR2Mutator]MSP[S]
public static int compare ( short x , short y ) { MST[rv.CRCR3Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR3Mutator]MSP[S] return 1 ; } }
if( numDecimals <= 7 ) { MST[rv.UOI1Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.ROR5Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static int compare ( int x , int y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[InlineConstantMutator]MSP[N] return 1 ; } }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] short min = array [ 0 ] ;
if ( expPos > - 1 ) { MST[NonVoidMethodCallMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR5Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR5Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR4Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.ABSMutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.AOR1Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[NonVoidMethodCallMutator]MSP[S] if ( dec == null
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[S]
} } if ( pfxLen > 0 ) { MST[rv.UOI1Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[ConditionalsBoundaryMutator]MSP[N] if ( decPos > - 1 ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ABSMutator]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} catch ( final NumberFormatException nfe ) { } MST[NonVoidMethodCallMutator]MSP[N] try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try {
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { MST[ReturnValsMutator]MSP[N] } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try {
radix = 16 ; MST[rv.CRCR6Mutator]MSP[N] pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.ABSMutator]MSP[N] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI2Mutator]MSP[S] return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[MathMutator]MSP[N] break;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( dec == null
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; MST[rv.CRCR5Mutator]MSP[S] } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.ABSMutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR5Mutator]MSP[S] validateArray ( array ) ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR4Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int min ( final int ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return false ; MST[InlineConstantMutator]MSP[N] } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[S]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR5Mutator]MSP[N] return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[NegateConditionalsMutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR1Mutator]MSP[N] if ( dec == null
public static byte max ( final byte ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if( numDecimals <= 7 ) { MST[InlineConstantMutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
Validate . isTrue ( Array . getLength ( array ) != 0 , lr_13 ) ; } public static long min ( long a , final long b , final long c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b < a ) { a = b ; }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[NonVoidMethodCallMutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOD1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR3Mutator]MSP[N] return 1 ; } }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
} else if ( chars [ i ] == '.' ) { MST[rv.CRCR2Mutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] double min = array [ 0 ] ;
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[BooleanTrueReturnValsMutator]MSP[S] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
int radix = 10 ; MST[rv.ROR3Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; MST[ReturnValsMutator]MSP[N] } }
public static byte max ( final byte ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[NegateConditionalsMutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[rv.ABSMutator]MSP[N] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[rv.CRCR3Mutator]MSP[N] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[S]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[InlineConstantMutator]MSP[N] return createBigInteger ( str ) ; }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
public static byte max ( final byte ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI2Mutator]MSP[N]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR1Mutator]MSP[N] return 1 ; } }
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR2Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[NonVoidMethodCallMutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR1Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] short max = array [ 0 ] ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI1Mutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; MST[NullReturnValsMutator]MSP[N] } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] long max = array [ 0 ] ;
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR4Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if( numDecimals <= 7 ) { MST[rv.ROR4Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ;
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return true ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S] short min = array [ 0 ] ;
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR3Mutator]MSP[N] try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR5Mutator]MSP[S] try {
if ( ! allowSigns ) { MST[rv.ROR5Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[rv.CRCR5Mutator]MSP[N] case 'l' : case 'L' : if ( dec == null
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.UOI1Mutator]MSP[S]
} return Double . valueOf ( str ) ; } public static Integer createInteger ( final String str ) { MST[EmptyObjectReturnValsMutator]MSP[N] if ( str == null ) { return null ; } return Integer . decode ( str ) ; } public static Long createLong ( final String str ) {
public static int compare ( long x , long y ) { MST[rv.UOI2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.ROR1Mutator]MSP[S] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR5Mutator]MSP[S]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
public static int min ( final int ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[ReturnValsMutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[NegateConditionalsMutator]MSP[N] return createBigInteger ( str ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( int x , int y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.ROR3Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR2Mutator]MSP[N] }
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[S] } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
for ( int i = 1 ; i < array . length ; i ++ ) { MST[ReturnValsMutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.ABSMutator]MSP[N] pfxLen ++ ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
public static byte min ( final byte ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int min ( final int ... array ) { validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.ABSMutator]MSP[N]
for (; i < chars . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR6Mutator]MSP[N]
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI2Mutator]MSP[S]
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR3Mutator]MSP[N]
for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[InlineConstantMutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; MST[rv.CRCR1Mutator]MSP[N] allowSigns = false ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[ReturnValsMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[MathMutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
long min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[PrimitiveReturnsMutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR1Mutator]MSP[S] if ( dec == null
if ( hasExp ) { return false ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[rv.CRCR3Mutator]MSP[S] return foundDigit && ! hasExp && ! hasDecPoint ; }
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] double max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR2Mutator]MSP[N] }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[NegateConditionalsMutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[rv.ROR4Mutator]MSP[N] pfxLen += pfx . length () ; break;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[ConditionalsBoundaryMutator]MSP[S]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( short x , short y ) { MST[rv.UOI2Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int max ( final int ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.AOD1Mutator]MSP[N]
public static int compare ( short x , short y ) { MST[rv.ABSMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.ABSMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOD2Mutator]MSP[N]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR5Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int min ( final int ... array ) { validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI2Mutator]MSP[S]
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR1Mutator]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.AOD2Mutator]MSP[N] } else { return 1 ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; MST[rv.CRCR6Mutator]MSP[S] } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
} catch ( final NumberFormatException nfe ) { } try { MST[ReturnValsMutator]MSP[S] if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[InlineConstantMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { MST[ReturnValsMutator]MSP[S]
public static int compare ( byte x , byte y ) { return x - y ; } MST[InlineConstantMutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR1Mutator]MSP[N] return 1 ; } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[ReturnValsMutator]MSP[N] double min = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI1Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR1Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[rv.ROR1Mutator]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int min ( final int ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR4Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR3Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR2Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( ! allowSigns ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI4Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 1 ; } }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR1Mutator]MSP[N] return 1 ; } }
if ( ! allowSigns ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] float max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] long max = array [ 0 ] ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.AOR3Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI4Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[S]
public static int max ( final int ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ABSMutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[NegateConditionalsMutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[ArgumentPropagationMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOD1Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( expPos > - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[NegateConditionalsMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[rv.ROR1Mutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR5Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' MST[rv.CRCR5Mutator]MSP[N] || chars [ i ] == 'D'
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[S]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOD1Mutator]MSP[N] } } sz -- ; int i = start ;
if ( c < a ) { a = c ; } return a ; } public static int min ( int a , final int b , final int c ) { MST[rv.UOI1Mutator]MSP[S] if ( b < a ) { a = b ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR1Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR1Mutator]MSP[S] try {
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.ROR2Mutator]MSP[N]
public static int max ( final int ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[ReturnValsMutator]MSP[N] }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR3Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
if ( expPos > - 1 ) { MST[rv.UOI2Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[PrimitiveReturnsMutator]MSP[N] float max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR5Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR4Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[NegateConditionalsMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR5Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( ! allowSigns ) { MST[rv.ABSMutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.ROR4Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.AOR4Mutator]MSP[S]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.CRCR6Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR3Mutator]MSP[S]
public static int compare ( int x , int y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} } if ( pfxLen > 0 ) { MST[rv.ROR2Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[InlineConstantMutator]MSP[S]
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.CRCR1Mutator]MSP[N] if ( decPos > - 1 ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR4Mutator]MSP[S] if ( str == null ) { return true ; }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.ROR2Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; MST[NegateConditionalsMutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( expPos > - 1 ) { MST[NegateConditionalsMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.CRCR6Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR5Mutator]MSP[S] return - 1 ; } else { return 1 ; } }
return false ; } return ! allowSigns && foundDigit ; MST[rv.ABSMutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( expPos > - 1 ) { MST[rv.ABSMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S] short min = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[NegateConditionalsMutator]MSP[N] if ( dec == null
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N]
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; MST[PrimitiveReturnsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.CRCR5Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
public static int compare ( int x , int y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[InlineConstantMutator]MSP[N] } else { return 1 ; } }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.AOD2Mutator]MSP[S]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.ROR1Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ConditionalsBoundaryMutator]MSP[S]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI2Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] String mant ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[rv.ROR3Mutator]MSP[N] return null ; } int pos = 0 ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[BooleanTrueReturnValsMutator]MSP[S] return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.UOI4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[rv.CRCR3Mutator]MSP[N] case 'l' : case 'L' : if ( dec == null
public static int compare ( int x , int y ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR4Mutator]MSP[S] if ( dec == null
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR5Mutator]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; MST[rv.CRCR5Mutator]MSP[N] } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR1Mutator]MSP[N]
public static int compare ( long x , long y ) { MST[rv.CRCR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
dec = str . substring ( decPos + 1 ) ; MST[rv.UOI1Mutator]MSP[S] } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[NegateConditionalsMutator]MSP[N] }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[S] float min = array [ 0 ] ;
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( ! allowSigns ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR4Mutator]MSP[N] } else { return 1 ; } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR3Mutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOD2Mutator]MSP[S] } } sz -- ; int i = start ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.ROR4Mutator]MSP[S] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[MathMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[rv.CRCR5Mutator]MSP[N] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR2Mutator]MSP[N] return createBigInteger ( str ) ; }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.ROR4Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[MathMutator]MSP[N] }
public static int min ( final int ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR4Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR5Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[experimental.RemoveIncrementsMutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
if ( ! allowSigns ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR5Mutator]MSP[N] }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( short x , short y ) { MST[rv.UOI1Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( expPos > - 1 ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR3Mutator]MSP[N] } } sz -- ; int i = start ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
int radix = 10 ; MST[rv.ROR4Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if( numDecimals <= 7 ) { MST[rv.ROR2Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
if ( expPos > - 1 ) { MST[NonVoidMethodCallMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.UOI2Mutator]MSP[N] pfxLen ++ ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] long max = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[InlineConstantMutator]MSP[N] pfxLen ++ ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ROR5Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { MST[rv.UOI1Mutator]MSP[N] if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static byte min ( final byte ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR3Mutator]MSP[S] return 1 ; } }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.SwitchMutator]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR6Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( expPos > - 1 ) { MST[rv.ROR5Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR2Mutator]MSP[N] double min = array [ 0 ] ;
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR5Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR1Mutator]MSP[N] return 1 ; } }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI4Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI4Mutator]MSP[S]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR5Mutator]MSP[N] if ( dec == null
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { MST[rv.ROR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI4Mutator]MSP[N] return createBigInteger ( str ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[InlineConstantMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[ArgumentPropagationMutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR3Mutator]MSP[N] }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[rv.UOI1Mutator]MSP[S] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } } return true ; } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[rv.CRCR6Mutator]MSP[N] }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR1Mutator]MSP[N] return createBigInteger ( str ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[MathMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR3Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[NonVoidMethodCallMutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR3Mutator]MSP[S] }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI1Mutator]MSP[N]
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } try {
if ( expPos > - 1 ) { MST[rv.UOI4Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return createBigInteger ( numeric ) ; MST[experimental.NakedReceiverMutator]MSP[S] } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static int min ( final int ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[NonVoidMethodCallMutator]MSP[N] break;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR1Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; short max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] float min = array [ 0 ] ;
if ( chars [ i ] == '.' ) { MST[rv.CRCR4Mutator]MSP[S] if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR1Mutator]MSP[N] double max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; MST[NonVoidMethodCallMutator]MSP[N] try {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] double max = array [ 0 ] ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.ABSMutator]MSP[N] } else {
if( numDecimals <= 7 ) { MST[rv.ROR3Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[InlineConstantMutator]MSP[S] return createBigInteger ( str ) ; }
public static int compare ( int x , int y ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.ROR3Mutator]MSP[S] }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return createBigInteger ( str ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[InlineConstantMutator]MSP[S] try {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } } sz -- ; int i = start ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ;
public static int compare ( short x , short y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR2Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ABSMutator]MSP[N]
int radix = 10 ; MST[NonVoidMethodCallMutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; MST[rv.CRCR2Mutator]MSP[N] } int pos = 0 ;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { MST[experimental.NakedReceiverMutator]MSP[N] if ( expPos > - 1 ) { if ( expPos > str . length () ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.ABSMutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] double min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.UOI3Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( firstSigDigit == '0' ) { pfxLen ++ ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI2Mutator]MSP[N] }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( int x , int y ) { MST[rv.CRCR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
} else if ( chars [ i ] == '.' ) { MST[rv.CRCR6Mutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
public static int compare ( int x , int y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR3Mutator]MSP[N] return createBigInteger ( str ) ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.UOI1Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
Validate . isTrue ( Array . getLength ( array ) != 0 , lr_13 ) ; } public static long min ( long a , final long b , final long c ) { MST[ReturnValsMutator]MSP[N] if ( b < a ) { a = b ; }
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI4Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR2Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[rv.CRCR1Mutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] short max = array [ 0 ] ;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) { MST[ArgumentPropagationMutator]MSP[S]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR4Mutator]MSP[S]
long min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[NegateConditionalsMutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
public static int compare ( short x , short y ) { MST[rv.ROR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR5Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int compare ( byte x , byte y ) { return x - y ; } MST[PrimitiveReturnsMutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR2Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[InlineConstantMutator]MSP[S] }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR4Mutator]MSP[N] } } sz -- ; int i = start ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[PrimitiveReturnsMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[InlineConstantMutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
public static byte max ( final byte ... array ) { validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
if ( ! allowSigns ) { MST[rv.ROR4Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR5Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[InlineConstantMutator]MSP[N] }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[ReturnValsMutator]MSP[N] double max = array [ 0 ] ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.ROR4Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; MST[PrimitiveReturnsMutator]MSP[N] } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; } try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI3Mutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[S] float max = array [ 0 ] ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.UOI3Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.AOR1Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ABSMutator]MSP[S] return createBigInteger ( str ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[rv.ROR2Mutator]MSP[N]
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR6Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR1Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( int x , int y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] String mant ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.AOD1Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.ABSMutator]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return true ; }
} } if ( pfxLen > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N] float max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] double min = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[rv.ROR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR4Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ABSMutator]MSP[S]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[N] } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.ROR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static byte max ( final byte ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[NegateConditionalsMutator]MSP[N] case 'l' : case 'L' : if ( dec == null
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
exp = str . substring ( expPos + 1 , str . length () ) ; } else { exp = null ; } if ( dec == null && exp == null ) { MST[NullReturnValsMutator]MSP[N] try { return createInteger ( str ) ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } } sz -- ; int i = start ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } } sz -- ; int i = start ;
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.RemoveSwitchMutator_0]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR4Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.RemoveSwitchMutator_1]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.RemoveSwitchMutator_2]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.RemoveSwitchMutator_3]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.RemoveSwitchMutator_4]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[NegateConditionalsMutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR1Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
public static byte min ( final byte ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOD2Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.RemoveSwitchMutator_5]MSP[N] final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI1Mutator]MSP[N]
public static byte max ( final byte ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI1Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[NonVoidMethodCallMutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.UOI4Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( ! allowSigns ) { MST[InlineConstantMutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.AOR3Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[PrimitiveReturnsMutator]MSP[S] float min = array [ 0 ] ;
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return true ; }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.UOI1Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
for ( int i = 1 ; i < array . length ; i ++ ) { MST[ReturnValsMutator]MSP[N] if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR5Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.ABSMutator]MSP[S] } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.UOI4Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } try {
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[InlineConstantMutator]MSP[S] } else {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.CRCR3Mutator]MSP[S] try {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.ABSMutator]MSP[N] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR1Mutator]MSP[N]
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.UOI1Mutator]MSP[N] } else {
public static byte max ( final byte ... array ) { MST[IncrementsMutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.ROR2Mutator]MSP[N] } else { return 1 ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.UOI2Mutator]MSP[S] }
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; MST[ReturnValsMutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } } sz -- ; int i = start ;
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[experimental.NakedReceiverMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} catch ( final NumberFormatException nfe ) { MST[rv.ROR2Mutator]MSP[N] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR3Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR4Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
public static int compare ( long x , long y ) { MST[rv.CRCR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR6Mutator]MSP[N] if ( dec == null
public static int min ( final int ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR4Mutator]MSP[N] return 1 ; } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.AOR3Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.AOD1Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[rv.ROR5Mutator]MSP[N] case 'l' : case 'L' : if ( dec == null
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.CRCR2Mutator]MSP[S]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; MST[rv.CRCR5Mutator]MSP[N] int i = start ;
int radix = 10 ; boolean negate = false ; MST[InlineConstantMutator]MSP[N] if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.ROR2Mutator]MSP[N] pfxLen ++ ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] long max = array [ 0 ] ;
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static int max ( final int ... array ) { validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI1Mutator]MSP[S]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[InlineConstantMutator]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
int radix = 10 ; MST[rv.UOI4Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.UOI4Mutator]MSP[N] if ( str == null ) { return true ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ROR4Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR6Mutator]MSP[N] }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] String mant ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.CRCR3Mutator]MSP[N] } else {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR2Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( short x , short y ) { MST[BooleanFalseReturnValsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR3Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.ABSMutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR4Mutator]MSP[N] return createBigInteger ( str ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( int x , int y ) { MST[rv.ROR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; MST[rv.CRCR1Mutator]MSP[S] for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR4Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.ROR3Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[rv.CRCR5Mutator]MSP[N] }
} } if ( pfxLen > 0 ) { MST[rv.ROR1Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; MST[ReturnValsMutator]MSP[N] allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR2Mutator]MSP[S]
public static int compare ( int x , int y ) { MST[rv.CRCR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return true ; }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.CRCR4Mutator]MSP[N] } else {
public static int compare ( long x , long y ) { MST[rv.CRCR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[NegateConditionalsMutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.UOI1Mutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR4Mutator]MSP[S]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[ReturnValsMutator]MSP[N] if ( str == null ) { return true ; }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.CRCR4Mutator]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI1Mutator]MSP[N]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI4Mutator]MSP[N] } } sz -- ; int i = start ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR2Mutator]MSP[N] return 1 ; } }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; MST[rv.CRCR5Mutator]MSP[N] for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) { MST[NonVoidMethodCallMutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[S]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
if( numDecimals <= 7 ) { MST[rv.ROR1Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ROR4Mutator]MSP[N]
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ReturnValsMutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR2Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { MST[experimental.RemoveIncrementsMutator]MSP[N] negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[NegateConditionalsMutator]MSP[S] try {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI4Mutator]MSP[S]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.ROR1Mutator]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[ReturnValsMutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( c > a ) { a = c ; } return a ; } public static short max ( short a , final short b , final short c ) { MST[rv.ABSMutator]MSP[N] if ( b > a ) { a = b ; }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.ROR3Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ABSMutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[MathMutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { MST[IncrementsMutator]MSP[N] return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[S]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
public static byte min ( final byte ... array ) { validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[ReturnValsMutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.ROR5Mutator]MSP[N] if ( decPos > - 1 ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.CRCR2Mutator]MSP[N] }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR4Mutator]MSP[N] } } sz -- ; int i = start ;
int radix = 10 ; MST[rv.ROR1Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] double max = array [ 0 ] ;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.ROR4Mutator]MSP[S] validateArray ( array ) ; short min = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { MST[BooleanFalseReturnValsMutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[NegateConditionalsMutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[N]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[InlineConstantMutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; double max = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR2Mutator]MSP[S]
public static byte max ( final byte ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { MST[rv.UOI3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR4Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( expPos > - 1 ) { MST[rv.ROR4Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI3Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR4Mutator]MSP[N] if ( dec == null
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.AOR4Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI3Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( ! allowSigns ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI4Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.UOI4Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
int radix = 10 ; MST[rv.ROR5Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static int compare ( int x , int y ) { MST[NonVoidMethodCallMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( str == null ) { return true ; }
if ( c < a ) { a = c ; } return a ; } public static short min ( short a , final short b , final short c ) { MST[rv.UOI1Mutator]MSP[S] if ( b < a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOD1Mutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] float max = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; MST[rv.CRCR6Mutator]MSP[N] int i = start ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
public static byte min ( final byte ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR2Mutator]MSP[N] return 1 ; } }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR5Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] double min = array [ 0 ] ;
public static int compare ( short x , short y ) { MST[rv.UOI2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.UOI1Mutator]MSP[N] return createBigInteger ( str ) ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR2Mutator]MSP[N] } } sz -- ; int i = start ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR1Mutator]MSP[N] return createBigInteger ( str ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } } return true ; } } sz -- ; int i = start ;
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[NonVoidMethodCallMutator]MSP[N] }
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; MST[rv.CRCR1Mutator]MSP[N] }
for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI2Mutator]MSP[S] if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR1Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } } sz -- ; int i = start ;
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI4Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static byte max ( final byte ... array ) { validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[PrimitiveReturnsMutator]MSP[N]
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR1Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultValue ; } try {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR2Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return true ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; MST[InlineConstantMutator]MSP[N] for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI4Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.AOD2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR6Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.UOI1Mutator]MSP[N] pfxLen ++ ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] long max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int min ( final int ... array ) { validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI1Mutator]MSP[S]
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( c < a ) { a = c ; } return a ; } public static byte min ( byte a , final byte b , final byte c ) { MST[rv.UOI4Mutator]MSP[N] if ( b < a ) { a = b ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[PrimitiveReturnsMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR5Mutator]MSP[S] try {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR5Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[rv.ROR1Mutator]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( long x , long y ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI4Mutator]MSP[S]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[rv.CRCR4Mutator]MSP[S] return foundDigit && ! hasExp && ! hasDecPoint ; }
if( numDecimals <= 7 ) { final Float f = createFloat ( str ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] short max = array [ 0 ] ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.UOI2Mutator]MSP[S] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultValue ; } try {
public static int min ( final int ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR4Mutator]MSP[N] }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] long max = array [ 0 ] ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.ROR1Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } try {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; short min = array [ 0 ] ;
if ( ! allowSigns ) { MST[rv.ROR1Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static int compare ( short x , short y ) { MST[rv.ROR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[ReturnValsMutator]MSP[N] return 1 ; } }
return createBigInteger ( numeric ) ; MST[ConstructorCallMutator]MSP[N] } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static int compare ( int x , int y ) { MST[rv.CRCR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI3Mutator]MSP[N] } } sz -- ; int i = start ;
if ( expPos > - 1 ) { MST[rv.ROR1Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.ROR3Mutator]MSP[N] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR1Mutator]MSP[S] float min = array [ 0 ] ;
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[rv.ROR2Mutator]MSP[S] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
int radix = 10 ; MST[NegateConditionalsMutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[S]
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI3Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.CRCR5Mutator]MSP[S] if ( dec == null
} catch ( final NumberFormatException nfe ) { } MST[NullReturnValsMutator]MSP[N] try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( expPos > - 1 ) { MST[rv.UOI3Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { MST[NonVoidMethodCallMutator]MSP[N] } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR1Mutator]MSP[N]
public static long toLong ( final String str , final long defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Long . parseLong ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] short max = array [ 0 ] ;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[S] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI2Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] long max = array [ 0 ] ;
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static byte max ( final byte ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.AOR2Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N] float min = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR3Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR2Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI1Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' MST[rv.CRCR6Mutator]MSP[N] || chars [ i ] == 'D'
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI1Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( hasExp ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return true ; }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[rv.ROR4Mutator]MSP[N] return null ; } int pos = 0 ;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( c < a ) { a = c ; } return a ; } public static int min ( int a , final int b , final int c ) { MST[rv.UOI2Mutator]MSP[S] if ( b < a ) { a = b ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR2Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] try {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR1Mutator]MSP[N] } } sz -- ; int i = start ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR2Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte max ( final byte ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR3Mutator]MSP[N] if ( dec == null
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.AOD2Mutator]MSP[S] break;
return Integer . parseInt ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ABSMutator]MSP[N] return 1 ; } }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR6Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( chars [ i ] == '.' ) { MST[InlineConstantMutator]MSP[N] if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[rv.ROR2Mutator]MSP[S] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( dec == null
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[rv.ROR1Mutator]MSP[S]
return createBigInteger ( numeric ) ; MST[NonVoidMethodCallMutator]MSP[S] } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { MST[experimental.RemoveIncrementsMutator]MSP[N] return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return 1 ; } }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR1Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR3Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[rv.CRCR5Mutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N]
public static int compare ( long x , long y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte min ( final byte ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI2Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( expPos > - 1 ) { MST[rv.UOI1Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR4Mutator]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.UOI3Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[ReturnValsMutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return createBigInteger ( str ) ; }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.AOD2Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR3Mutator]MSP[N] return createBigInteger ( str ) ; }
if ( c > a ) { a = c ; } return a ; } public static byte max ( byte a , final byte b , final byte c ) { MST[rv.UOI4Mutator]MSP[N] if ( b > a ) { a = b ; }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { MST[ConstructorCallMutator]MSP[N] if ( expPos > - 1 ) { if ( expPos > str . length () ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.UOI3Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR2Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.ABSMutator]MSP[S] }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.UOI4Mutator]MSP[N] }
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[NegateConditionalsMutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N] long max = array [ 0 ] ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR5Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.ROR1Mutator]MSP[N] pfxLen ++ ;
if ( ! allowSigns ) { MST[rv.UOI1Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { MST[NonVoidMethodCallMutator]MSP[N] if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( c < a ) { a = c ; } return a ; } public static short min ( short a , final short b , final short c ) { MST[rv.UOI2Mutator]MSP[S] if ( b < a ) { a = b ; }
int radix = 10 ; boolean negate = false ; MST[rv.CRCR4Mutator]MSP[N] if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static byte min ( final byte ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR4Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] short max = array [ 0 ] ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR6Mutator]MSP[N] return createBigInteger ( str ) ; }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[rv.CRCR2Mutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ABSMutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[rv.CRCR4Mutator]MSP[N] pfxLen ++ ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S] float min = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static int compare ( long x , long y ) { MST[rv.ROR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static byte min ( final byte ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.AOD1Mutator]MSP[S]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR1Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
if ( c < a ) { a = c ; } return a ; } public static short min ( short a , final short b , final short c ) { MST[rv.ABSMutator]MSP[N] if ( b < a ) { a = b ; }
if( numDecimals <= 7 ) { MST[rv.CRCR6Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : try { MST[NullReturnValsMutator]MSP[N]
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[NegateConditionalsMutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOD1Mutator]MSP[N] } } sz -- ; int i = start ;
public static int compare ( int x , int y ) { MST[rv.ROR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} return Double . valueOf ( str ) ; } public static Integer createInteger ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } return Integer . decode ( str ) ; } public static Long createLong ( final String str ) {
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[InlineConstantMutator]MSP[N] }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[NegateConditionalsMutator]MSP[N] short min = array [ 0 ] ;
} catch ( final NumberFormatException nfe ) { MST[rv.ROR1Mutator]MSP[S] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[ConstructorCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[NegateConditionalsMutator]MSP[N]
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[NegateConditionalsMutator]MSP[S] try {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR1Mutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[ReturnValsMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; }
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR5Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[IncrementsMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[InlineConstantMutator]MSP[S] if ( str == null ) { return true ; }
public static byte max ( final byte ... array ) { validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[ReturnValsMutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' MST[BooleanTrueReturnValsMutator]MSP[N] || chars [ i ] == 'D'
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.ROR1Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.UOI1Mutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.UOI4Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[rv.AOD2Mutator]MSP[N] }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.ROR3Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[NegateConditionalsMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ROR3Mutator]MSP[N]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.AOR4Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI4Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return true ; }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 1 ; } }
public static int compare ( long x , long y ) { if ( x == y ) { MST[IncrementsMutator]MSP[N] return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
radix = 16 ; MST[rv.CRCR1Mutator]MSP[N] pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
radix = 16 ; pos += 2 ; MST[IncrementsMutator]MSP[N] } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( c < a ) { a = c ; } return a ; } public static int min ( int a , final int b , final int c ) { MST[rv.ABSMutator]MSP[N] if ( b < a ) { a = b ; }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI3Mutator]MSP[N] return 1 ; } }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR1Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] short min = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[NegateConditionalsMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
int radix = 10 ; MST[rv.UOI1Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] try {
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI3Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR5Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[InlineConstantMutator]MSP[S] if ( dec == null
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ROR4Mutator]MSP[S]
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR6Mutator]MSP[N]
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR2Mutator]MSP[N] return createBigInteger ( str ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.UOI4Mutator]MSP[S] try {
if ( ! allowSigns ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } } sz -- ; int i = start ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] short min = array [ 0 ] ;
if ( expPos > - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; short max = array [ 0 ] ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( short x , short y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[ConditionalsBoundaryMutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOD2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] float max = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[ConditionalsBoundaryMutator]MSP[S] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR3Mutator]MSP[N]
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI2Mutator]MSP[S] } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[experimental.NakedReceiverMutator]MSP[S] if ( dec == null
if ( c > a ) { a = c ; } return a ; } public static int max ( int a , final int b , final int c ) { MST[rv.UOI1Mutator]MSP[S] if ( b > a ) { a = b ; }
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[PrimitiveReturnsMutator]MSP[N] } }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.CRCR4Mutator]MSP[S]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ABSMutator]MSP[N] }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR5Mutator]MSP[S] try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[S]
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[InlineConstantMutator]MSP[N] }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[ConstructorCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ROR5Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR4Mutator]MSP[S] }
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR4Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[S] double max = array [ 0 ] ;
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR1Mutator]MSP[N] }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( c > a ) { a = c ; } return a ; } public static short max ( short a , final short b , final short c ) { MST[rv.UOI1Mutator]MSP[S] if ( b > a ) { a = b ; }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( chars [ i ] == '.' ) { MST[rv.CRCR5Mutator]MSP[S] if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR5Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( c > a ) { a = c ; } return a ; } public static byte max ( byte a , final byte b , final byte c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b > a ) { a = b ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.CRCR2Mutator]MSP[N] double max = array [ 0 ] ;
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.CRCR3Mutator]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.UOI1Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR6Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] long max = array [ 0 ] ;
public static int compare ( short x , short y ) { MST[rv.ABSMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI1Mutator]MSP[S] return 1 ; } }
public static byte max ( final byte ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ABSMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[InlineConstantMutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI3Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[rv.ABSMutator]MSP[S] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR6Mutator]MSP[N] return - 1 ; } else { return 1 ; } }
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.UOI3Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return false ; MST[rv.CRCR3Mutator]MSP[N] } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.CRCR4Mutator]MSP[N] return createBigInteger ( str ) ; }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.AOR2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.AOR4Mutator]MSP[N] } else { return 1 ; } }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.UOI1Mutator]MSP[S] }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.CRCR3Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[ConditionalsBoundaryMutator]MSP[S]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; MST[rv.CRCR6Mutator]MSP[N] int numDecimals = 0 ; if ( decPos > - 1 ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[BooleanFalseReturnValsMutator]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[InlineConstantMutator]MSP[N]
public static byte max ( final byte ... array ) { MST[rv.CRCR1Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) { MST[rv.ROR1Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
} } if ( pfxLen > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[S] double max = array [ 0 ] ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[rv.AOR1Mutator]MSP[N] } else {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR3Mutator]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.AOR4Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR3Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[NegateConditionalsMutator]MSP[N] if ( decPos > - 1 ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR4Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.ROR4Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR5Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } } sz -- ; int i = start ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; MST[InlineConstantMutator]MSP[N] } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } try {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; MST[BooleanTrueReturnValsMutator]MSP[N] int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int min ( final int ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI2Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( ! allowSigns ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[rv.ROR3Mutator]MSP[N] pfxLen += pfx . length () ; break;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[NonVoidMethodCallMutator]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR2Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; MST[rv.CRCR6Mutator]MSP[N] } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] double min = array [ 0 ] ;
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; MST[rv.CRCR5Mutator]MSP[S] for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[NegateConditionalsMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR2Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI4Mutator]MSP[N] } }
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[NegateConditionalsMutator]MSP[N] }
public static int compare ( int x , int y ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static int compare ( long x , long y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[NegateConditionalsMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR5Mutator]MSP[S] }
public static int compare ( long x , long y ) { MST[ReturnValsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI3Mutator]MSP[N]
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.UOI1Mutator]MSP[N] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR2Mutator]MSP[S] if ( dec == null
public static byte max ( final byte ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] String mant ;
public static byte min ( final byte ... array ) { MST[rv.UOI3Mutator]MSP[S] validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR4Mutator]MSP[N] if ( str == null ) { return true ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
if ( c > a ) { a = c ; } return a ; } public static int max ( int a , final int b , final int c ) { MST[rv.UOI2Mutator]MSP[S] if ( b > a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( expPos > - 1 ) { MST[NonVoidMethodCallMutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S] long max = array [ 0 ] ;
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[S] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.UOI3Mutator]MSP[N] if ( str == null ) { return true ; }
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR4Mutator]MSP[S] try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) { MST[rv.UOI2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI2Mutator]MSP[N]
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.ROR1Mutator]MSP[N] if ( decPos > - 1 ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOD2Mutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.CRCR1Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.AOR2Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ; MST[experimental.RemoveIncrementsMutator]MSP[S]
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.CRCR4Mutator]MSP[S] if ( str == null ) { return true ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
if ( c < a ) { a = c ; } return a ; } public static int min ( int a , final int b , final int c ) { MST[ReturnValsMutator]MSP[N] if ( b < a ) { a = b ; }
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] short max = array [ 0 ] ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.AOR3Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR6Mutator]MSP[S] validateArray ( array ) ; short min = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR1Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( short x , short y ) { MST[rv.ROR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ReturnValsMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } } sz -- ; int i = start ;
int radix = 10 ; MST[rv.ROR2Mutator]MSP[S] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.UOI2Mutator]MSP[N] } } sz -- ; int i = start ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[experimental.NakedReceiverMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[rv.ROR1Mutator]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[MathMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[rv.CRCR1Mutator]MSP[N] case 'l' : case 'L' : if ( dec == null
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.AOR4Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) { MST[rv.ABSMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ABSMutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; MST[NegateConditionalsMutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR6Mutator]MSP[N] return 1 ; } }
return false ; } return ! allowSigns && foundDigit ; MST[rv.ABSMutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ABSMutator]MSP[N] } } sz -- ; int i = start ;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.ROR2Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.ABSMutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR6Mutator]MSP[N]
public static int min ( final int ... array ) { MST[rv.CRCR6Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[NegateConditionalsMutator]MSP[N] return createBigInteger ( str ) ; }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.AOD1Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
} else { break; } } final int hexDigits = str . length () - pfxLen ; MST[rv.AOR2Mutator]MSP[N] if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { return createBigInteger ( str ) ; }
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.ROR3Mutator]MSP[N] }
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.CRCR4Mutator]MSP[N]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.ROR2Mutator]MSP[S] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; MST[PrimitiveReturnsMutator]MSP[S] } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
if( numDecimals <= 7 ) { MST[NonVoidMethodCallMutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR6Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR3Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[S]
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if( numDecimals <= 7 ) { MST[rv.ROR5Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR2Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] long max = array [ 0 ] ;
if( numDecimals <= 7 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.ABSMutator]MSP[N]
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[S]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.UOI3Mutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR3Mutator]MSP[N] return 1 ; } }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short min = array [ 0 ] ;
return Math . min ( Math . min ( a , b ) , c ) ; } public static long max ( long a , final long b , final long c ) { MST[rv.UOI3Mutator]MSP[N] if ( b > a ) { a = b ; }
public static int min ( final int ... array ) { validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) { MST[PrimitiveReturnsMutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[S]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR3Mutator]MSP[S] return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; MST[rv.CRCR6Mutator]MSP[N] for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR4Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ReturnValsMutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[rv.CRCR6Mutator]MSP[N] }
public static int compare ( long x , long y ) { MST[rv.ROR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( int x , int y ) { MST[rv.CRCR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[InlineConstantMutator]MSP[N] double min = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR2Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; MST[rv.CRCR6Mutator]MSP[N] allowSigns = false ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[ReturnValsMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ; double min = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } } sz -- ; int i = start ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; MST[ReturnValsMutator]MSP[N] } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; } } sz -- ; MST[InlineConstantMutator]MSP[N] int i = start ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[rv.CRCR1Mutator]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.ROR3Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] float max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; double min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int max ( final int ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return true ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] long max = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[rv.UOI2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
int radix = 10 ; MST[rv.UOI2Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( dec == null
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if( numDecimals <= 7 ) { MST[rv.ROR2Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR1Mutator]MSP[N] try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR1Mutator]MSP[N]
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR5Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
public static int max ( final int ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( c < a ) { a = c ; } return a ; } public static short min ( short a , final short b , final short c ) { MST[PrimitiveReturnsMutator]MSP[N] if ( b < a ) { a = b ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR3Mutator]MSP[N] try {
if ( ! allowSigns ) { MST[rv.ROR3Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short max = array [ 0 ] ;
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.ABSMutator]MSP[N]
if ( expPos > - 1 ) { MST[rv.UOI3Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[ReturnValsMutator]MSP[S] float min = array [ 0 ] ;
if ( expPos > - 1 ) { MST[rv.UOI4Mutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static int min ( final int ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR3Mutator]MSP[S]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR4Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] long max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; MST[rv.ROR5Mutator]MSP[N] pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[S] double min = array [ 0 ] ;
public static int compare ( long x , long y ) { MST[NegateConditionalsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
int radix = 10 ; MST[rv.ROR5Mutator]MSP[N] boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] double max = array [ 0 ] ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR1Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( c > a ) { a = c ; } return a ; } public static int max ( int a , final int b , final int c ) { MST[rv.ABSMutator]MSP[N] if ( b > a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR4Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.UOI3Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } } sz -- ; int i = start ;
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; }
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.AOR2Mutator]MSP[N] } else { return 1 ; } }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI4Mutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
} else if ( str . startsWith ( lr_10 , pos ) && str . length () > pos + 1 ) { MST[ReturnValsMutator]MSP[N] radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ;
public static byte max ( final byte ... array ) { validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ABSMutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[InlineConstantMutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NonVoidMethodCallMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] short min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! allowSigns ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { MST[rv.ROR5Mutator]MSP[N] return false ; } i ++ ; } if ( i < chars . length ) {
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[rv.CRCR1Mutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
if ( expPos > - 1 && expPos < str . length () - 1 ) { exp = str . substring ( expPos + 1 , str . length () - 1 ) ; } else { exp = null ; MST[NonVoidMethodCallMutator]MSP[N] }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR4Mutator]MSP[S] if ( str == null ) { return true ; }
public static int max ( final int ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( long x , long y ) { MST[InlineConstantMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR3Mutator]MSP[N]
} catch ( final NumberFormatException nfe ) { } MST[ReturnValsMutator]MSP[N] try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
if ( c < a ) { a = c ; } return a ; } public static byte min ( byte a , final byte b , final byte c ) { MST[rv.UOI3Mutator]MSP[N] if ( b < a ) { a = b ; }
if ( c > a ) { a = c ; } return a ; } public static short max ( short a , final short b , final short c ) { MST[ReturnValsMutator]MSP[N] if ( b > a ) { a = b ; }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[IncrementsMutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.ABSMutator]MSP[N]
public static int compare ( int x , int y ) { MST[NegateConditionalsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
int radix = 10 ; boolean negate = false ; MST[rv.CRCR6Mutator]MSP[N] if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.CRCR1Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ABSMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Byte . parseByte ( str ) ; MST[ReturnValsMutator]MSP[N] } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR2Mutator]MSP[S] }
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } int pos = 0 ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ABSMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( long x , long y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR2Mutator]MSP[N]
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( ! allowSigns ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { MST[rv.ROR3Mutator]MSP[S] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR5Mutator]MSP[N]
public static int compare ( short x , short y ) { MST[rv.CRCR2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if( numDecimals <= 7 ) { MST[rv.UOI2Mutator]MSP[N] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; float min = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; MST[BooleanTrueReturnValsMutator]MSP[N] allowSigns = false ;
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.CRCR1Mutator]MSP[S]
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; MST[PrimitiveReturnsMutator]MSP[N] }
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR4Mutator]MSP[S]
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.CRCR5Mutator]MSP[N]
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.CRCR2Mutator]MSP[N] if ( decPos > - 1 ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] short min = array [ 0 ] ;
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int j = 1 ; j < array . length ; j ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; }
if ( ! allowSigns ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { MST[ReturnValsMutator]MSP[N] return foundDigit && ! hasExp && ! hasDecPoint ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.UOI3Mutator]MSP[S] try {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' MST[InlineConstantMutator]MSP[N] || chars [ i ] == 'D'
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; MST[rv.ABSMutator]MSP[S] break;
public static byte max ( final byte ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; MST[NegateConditionalsMutator]MSP[N] } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; }
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.UOI3Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static int compare ( byte x , byte y ) { return x - y ; } MST[NegateConditionalsMutator]MSP[N]
public static byte min ( final byte ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI3Mutator]MSP[N]
public static int max ( final int ... array ) { MST[NegateConditionalsMutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { MST[rv.ROR2Mutator]MSP[S] pfxLen += pfx . length () ; break;
public static byte max ( final byte ... array ) { MST[ConditionalsBoundaryMutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[InlineConstantMutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } sz -- ; int i = start ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] long max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
public static byte min ( final byte ... array ) { validateArray ( array ) ; byte min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[ConditionalsBoundaryMutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR4Mutator]MSP[S] try {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[rv.CRCR4Mutator]MSP[N] validateArray ( array ) ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI1Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.ROR2Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR4Mutator]MSP[S] }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR4Mutator]MSP[N] } } sz -- ; int i = start ;
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { MST[NullReturnValsMutator]MSP[N] return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : try {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { MST[rv.CRCR3Mutator]MSP[S]
if ( expPos > - 1 ) { MST[rv.ROR3Mutator]MSP[N] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR4Mutator]MSP[N]
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR4Mutator]MSP[S] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short max = array [ 0 ] ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.ROR3Mutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[S] short max = array [ 0 ] ;
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { if ( str == null ) { return null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOR1Mutator]MSP[N] } } sz -- ; int i = start ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR3Mutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { MST[rv.CRCR5Mutator]MSP[N] return - 1 ; } else { return 1 ; } }
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI1Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] case 'l' : case 'L' : if ( dec == null
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; MST[rv.ROR4Mutator]MSP[N] } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ;
public static byte max ( final byte ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
&& exp == null && ( numeric . charAt ( 0 ) == '-' && isDigits ( numeric . substring ( 1 ) ) || isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( final NumberFormatException nfe ) { MST[NonVoidMethodCallMutator]MSP[S] }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[rv.UOI4Mutator]MSP[S] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ABSMutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } }
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[ConditionalsBoundaryMutator]MSP[S] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
} catch ( final NumberFormatException nfe ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } try { if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.UOI1Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.AOD2Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static byte toByte ( final String str ) { return toByte ( str , ( byte ) 0 ) ; } public static byte toByte ( final String str , final byte defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.ABSMutator]MSP[S] } try {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR3Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
&& exp == null MST[ReturnValsMutator]MSP[N] && ( numeric . charAt ( 0 ) == '-' && isDigits ( numeric . substring ( 1 ) ) || isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( final NumberFormatException nfe ) { }
if( numDecimals <= 7 ) { MST[rv.ROR3Mutator]MSP[S] final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; MST[rv.ROR2Mutator]MSP[N] } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int toInt ( final String str ) { return toInt ( str , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static int toInt ( final String str , final int defaultValue ) { if( str == null ) { return defaultValue ; } try {
public static byte max ( final byte ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] pfxLen ++ ;
public static int min ( final int ... array ) { MST[rv.CRCR5Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ABSMutator]MSP[N] short min = array [ 0 ] ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ROR4Mutator]MSP[N]
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; MST[rv.ROR5Mutator]MSP[N] } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; float min = array [ 0 ] ;
dec = str . substring ( decPos + 1 ) ; } mant = getMantissa ( str , decPos ) ; MST[rv.ROR3Mutator]MSP[S] numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { MST[rv.UOI4Mutator]MSP[N] validateArray ( array ) ; long max = array [ 0 ] ;
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR4Mutator]MSP[N] short min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI2Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return true ; }
} } if ( pfxLen > 0 ) { MST[rv.ROR3Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
public static int compare ( long x , long y ) { MST[rv.CRCR4Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { MST[rv.ROR3Mutator]MSP[N] validateArray ( array ) ; double max = array [ 0 ] ;
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N]
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[rv.ROR2Mutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static int max ( final int ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
} catch ( final NumberFormatException nfe ) { } try { MST[NullReturnValsMutator]MSP[S] if( numDecimals <= 16 ) { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite () || ( d . doubleValue () == 0.0D && ! allZeros ) ) ) {
public static int compare ( long x , long y ) { MST[rv.ROR3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[rv.ROR2Mutator]MSP[S] if ( str == null ) { return true ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR4Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[NegateConditionalsMutator]MSP[S] try { final Float f = NumberUtils . createFloat ( numeric ) ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; double min = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR3Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[rv.ROR1Mutator]MSP[S]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] String mant ;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR5Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI1Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { MST[MathMutator]MSP[S]
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR1Mutator]MSP[N]
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; double max = array [ 0 ] ; MST[rv.ROR1Mutator]MSP[S]
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.UOI2Mutator]MSP[S]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[ConditionalsBoundaryMutator]MSP[N]
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; MST[rv.CRCR4Mutator]MSP[N] } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { validateArray ( array ) ; MST[rv.ROR1Mutator]MSP[N] short min = array [ 0 ] ;
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; MST[rv.ROR4Mutator]MSP[S] if ( decPos > - 1 ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI1Mutator]MSP[N]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[ConditionalsBoundaryMutator]MSP[S]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI1Mutator]MSP[S] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.AOR3Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.ROR2Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI1Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR2Mutator]MSP[N]
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR3Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { MST[rv.ROR5Mutator]MSP[N] case 'l' : case 'L' : if ( dec == null
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] double min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static long max ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N] long max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI1Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; float max = array [ 0 ] ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[InlineConstantMutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[MathMutator]MSP[N] } } sz -- ; int i = start ;
public static int min ( final int ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } return foundDigit ; MST[rv.CRCR1Mutator]MSP[S] } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
String dec ; String exp ; final int decPos = str . indexOf ( '.' ) ; MST[InlineConstantMutator]MSP[N] final int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; int numDecimals = 0 ; if ( decPos > - 1 ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { MST[rv.UOI3Mutator]MSP[N] if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[rv.CRCR6Mutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
public static int compare ( byte x , byte y ) { return x - y ; } MST[ConditionalsBoundaryMutator]MSP[S]
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[NonVoidMethodCallMutator]MSP[N]
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.ROR5Mutator]MSP[N] return 1 ; } }
if ( ! ( f . isInfinite () || ( f . floatValue () == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { } case 'd' : case 'D' : MST[rv.ROR1Mutator]MSP[S] try {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[S]
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] validateArray ( array ) ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR3Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.UOI4Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[rv.ROR5Mutator]MSP[N] if ( dec == null
public static int compare ( long x , long y ) { MST[rv.CRCR6Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
public static byte max ( final byte ... array ) { MST[rv.ROR5Mutator]MSP[N] validateArray ( array ) ; byte max = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.CRCR5Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; MST[rv.UOI2Mutator]MSP[S] } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D'
public static int compare ( byte x , byte y ) { return x - y ; } MST[rv.UOI2Mutator]MSP[S]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( c > a ) { a = c ; } return a ; } public static byte max ( byte a , final byte b , final byte c ) { MST[rv.UOI3Mutator]MSP[N] if ( b > a ) { a = b ; }
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { MST[rv.AOD1Mutator]MSP[S] return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; MST[rv.ABSMutator]MSP[N] } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
Validate . isTrue ( Array . getLength ( array ) != 0 , lr_13 ) ; } public static long min ( long a , final long b , final long c ) { MST[rv.UOI3Mutator]MSP[N] if ( b < a ) { a = b ; }
public static int compare ( long x , long y ) { MST[rv.UOI2Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.CRCR2Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int max ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] float max = array [ 0 ] ;
public static int compare ( int x , int y ) { MST[rv.ROR1Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static double max ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] double max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
radix = 16 ; pos += 2 ; } else if ( str . startsWith ( lr_6 , pos ) ) { radix = 16 ; pos ++ ; MST[rv.UOI2Mutator]MSP[S]
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[InlineConstantMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} else if ( chars [ i ] == '.' ) { if ( hasDecPoint || hasExp ) { return false ; } hasDecPoint = true ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) {
final String [] hex_prefixes = { lr_2 , lr_3 , lr_4 , lr_5 , lr_6 , lr_7 } ; MST[InlineConstantMutator]MSP[N] int pfxLen = 0 ; for( final String pfx : hex_prefixes ) { if ( str . startsWith ( pfx ) ) { pfxLen += pfx . length () ; break;
if ( str == null ) { return null ; } return Long . decode ( str ) ; } public static BigInteger createBigInteger ( final String str ) { MST[InlineConstantMutator]MSP[N] if ( str == null ) { return null ; } int pos = 0 ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR5Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR2Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int min ( final int ... array ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.CRCR1Mutator]MSP[N]
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.ROR4Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[ConditionalsBoundaryMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( c > a ) { a = c ; } return a ; } public static short max ( short a , final short b , final short c ) { MST[rv.UOI2Mutator]MSP[S] if ( b > a ) { a = b ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.ROR5Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return 1 ; } }
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.ROR1Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.ROR1Mutator]MSP[S] } } sz -- ; int i = start ;
public static int compare ( long x , long y ) { MST[NegateConditionalsMutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
long min = array [ 0 ] ; for ( int i = 1 ; i < array . length ; i ++ ) { MST[ReturnValsMutator]MSP[N] if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; }
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.ROR5Mutator]MSP[N] double min = array [ 0 ] ;
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[N] float min = array [ 0 ] ;
public static double toDouble ( final String str , final double defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI1Mutator]MSP[S] return 1 ; } }
if ( array [ j ] < min ) { min = array [ j ] ; } } return min ; } public static short min ( final short ... array ) { MST[rv.UOI3Mutator]MSP[N] validateArray ( array ) ; short min = array [ 0 ] ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[rv.AOD1Mutator]MSP[N] } else { return 1 ; } }
return createBigDecimal ( numeric ) ; } catch ( final NumberFormatException e ) { } default : throw new NumberFormatException ( str + lr_8 ) ; } } if ( expPos > - 1 && expPos < str . length () - 1 ) { MST[rv.AOR1Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
return negate ? value . negate () : value ; } public static BigDecimal createBigDecimal ( final String str ) { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
exp = str . substring ( expPos + 1 , str . length () ) ; } else { MST[NegateConditionalsMutator]MSP[N] exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ;
int radix = 10 ; boolean negate = false ; MST[rv.CRCR3Mutator]MSP[N] if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) {
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[rv.CRCR1Mutator]MSP[S] }
int radix = 10 ; boolean negate = false ; if ( str . startsWith ( lr_9 ) ) { negate = true ; pos = 1 ; } if ( str . startsWith ( lr_2 , pos ) || str . startsWith ( lr_3 , pos ) ) { MST[rv.UOI2Mutator]MSP[N]
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[BooleanTrueReturnValsMutator]MSP[N]
return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } } public static double toDouble ( final String str ) { return toDouble ( str , 0.0d ) ; MST[ArgumentPropagationMutator]MSP[N] }
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { MST[NullReturnValsMutator]MSP[N] } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { validateArray ( array ) ; MST[rv.UOI3Mutator]MSP[N]
return false ; } return ! allowSigns && foundDigit ; } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if( StringUtils . startsWith ( str , lr_9 ) ) {
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; MST[rv.UOI1Mutator]MSP[S] } try {
public static short toShort ( final String str , final short defaultValue ) { if( str == null ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.ROR5Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[NegateConditionalsMutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
} } if ( pfxLen > 0 ) { MST[rv.UOI2Mutator]MSP[N] char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] try { final Float f = NumberUtils . createFloat ( numeric ) ;
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI1Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
if ( ! allowSigns ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) {
if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { MST[rv.ROR3Mutator]MSP[S]
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; MST[MathMutator]MSP[N] } else {
public static Number createNumber ( final String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { MST[rv.ROR3Mutator]MSP[N] throw new NumberFormatException ( lr_1 ) ; }
return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[ReturnValsMutator]MSP[N] } } public static short toShort ( final String str ) { return toShort ( str , ( short ) 0 ) ; }
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[ReturnValsMutator]MSP[N] float max = array [ 0 ] ;
public static int compare ( short x , short y ) { MST[rv.UOI3Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
return hasSign ? str . substring ( 1 , stopPos ) : str . substring ( 0 , stopPos ) ; } private static boolean isAllZeros ( final String str ) { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return true ; }
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[InlineConstantMutator]MSP[N] return 1 ; } }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI3Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( long x , long y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.UOI4Mutator]MSP[N] return 1 ; } }
min = array [ i ] ; } } return min ; } public static float min ( final float ... array ) { MST[rv.CRCR3Mutator]MSP[S] validateArray ( array ) ; float min = array [ 0 ] ;
final String numeric = str . substring ( 0 , str . length () - 1 ) ; final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( dec == null
if ( expPos > - 1 ) { if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; MST[rv.CRCR5Mutator]MSP[S] } dec = str . substring ( decPos + 1 , expPos ) ; } else {
return createBigInteger ( numeric ) ; MST[ConstructorCallMutator]MSP[N] } throw new NumberFormatException ( str + lr_8 ) ; case 'f' : case 'F' : try { final Float f = NumberUtils . createFloat ( numeric ) ;
&& exp == null && ( numeric . charAt ( 0 ) == '-' && isDigits ( numeric . substring ( 1 ) ) || isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( final NumberFormatException nfe ) { MST[ReturnValsMutator]MSP[S] }
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.UOI4Mutator]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[NonVoidMethodCallMutator]MSP[N] } else { return 1 ; } }
&& exp == null MST[NonVoidMethodCallMutator]MSP[N] && ( numeric . charAt ( 0 ) == '-' && isDigits ( numeric . substring ( 1 ) ) || isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( final NumberFormatException nfe ) { }
} } if ( pfxLen > 0 ) { char firstSigDigit = 0 ; for( int i = pfxLen ; i < str . length () ; i ++ ) { MST[rv.ABSMutator]MSP[N] firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit == '0' ) { pfxLen ++ ;
} catch ( final NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } final boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { MST[rv.ROR3Mutator]MSP[N]
|| chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { return foundDigit && ! hasExp && ! hasDecPoint ; MST[InlineConstantMutator]MSP[N] }
public static int max ( final int ... array ) { MST[rv.CRCR3Mutator]MSP[N] validateArray ( array ) ; int max = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
&& ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { return false ; } } return true ; } else if ( Character . isDigit ( chars [ start + 1 ] ) ) { int i = start + 1 ; MST[rv.CRCR5Mutator]MSP[N]
if ( expPos > - 1 ) { MST[experimental.NakedReceiverMutator]MSP[S] if ( expPos < decPos || expPos > str . length () ) { throw new NumberFormatException ( str + lr_8 ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else {
public static int min ( final int ... array ) { MST[rv.ABSMutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
return false ; } return ! allowSigns && foundDigit ; MST[rv.UOI3Mutator]MSP[S] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[rv.ROR1Mutator]MSP[S] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; MST[rv.UOI3Mutator]MSP[N] } } public static long toLong ( final String str ) { return toLong ( str , 0L ) ; }
return false ; } return ! allowSigns && foundDigit ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isParsable ( final String str ) { if( StringUtils . endsWith ( str , lr_14 ) ) { return false ; } if( StringUtils . startsWith ( str , lr_9 ) ) {
if ( str . trim () . startsWith ( lr_11 ) ) { throw new NumberFormatException ( str + lr_8 ) ; } return new BigDecimal ( str ) ; } public static long min ( final long ... array ) { MST[InlineConstantMutator]MSP[S] validateArray ( array ) ;
if ( array [ j ] > max ) { max = array [ j ] ; } } return max ; } public static short max ( final short ... array ) { MST[rv.ROR2Mutator]MSP[N] validateArray ( array ) ; short max = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.ROR3Mutator]MSP[S] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; MST[NegateConditionalsMutator]MSP[N] } if ( x < y ) { return - 1 ; } else { return 1 ; } }
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR4Mutator]MSP[N] return createBigInteger ( str ) ; }
public static int min ( final int ... array ) { validateArray ( array ) ; MST[rv.UOI2Mutator]MSP[N] int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static float toFloat ( final String str ) { return toFloat ( str , 0.0f ) ; MST[rv.CRCR3Mutator]MSP[N] } public static float toFloat ( final String str , final float defaultValue ) { if ( str == null ) { return defaultValue ; } try {
} else { break; } } final int hexDigits = str . length () - pfxLen ; if ( hexDigits > 16 || ( hexDigits == 16 && firstSigDigit > '7' ) ) { MST[rv.ROR5Mutator]MSP[N] return createBigInteger ( str ) ; }
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.UOI4Mutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[InlineConstantMutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { MST[rv.CRCR2Mutator]MSP[S] validateArray ( array ) ; float max = array [ 0 ] ;
for (; i < chars . length ; i ++ ) { if ( chars [ i ] < '0' || chars [ i ] > '7' ) { return false ; } } return true ; MST[rv.AOD2Mutator]MSP[N] } } sz -- ; int i = start ;
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; float max = array [ 0 ] ; MST[rv.ROR5Mutator]MSP[N]
public static Number createNumber ( final String str ) throws NumberFormatException { MST[NegateConditionalsMutator]MSP[N] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI4Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
throw new NumberFormatException ( str + lr_8 ) ; } mant = getMantissa ( str , expPos ) ; } else { mant = getMantissa ( str ) ; } dec = null ; MST[rv.CRCR3Mutator]MSP[N] } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) {
max = array [ j ] ; } } return max ; } public static float max ( final float ... array ) { validateArray ( array ) ; MST[rv.CRCR2Mutator]MSP[N] float max = array [ 0 ] ;
return Math . max ( Math . max ( a , b ) , c ) ; } public static boolean isDigits ( final String str ) { return StringUtils . isNumeric ( str ) ; } public static boolean isNumber ( final String str ) { MST[rv.UOI4Mutator]MSP[N]
public static int compare ( short x , short y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { MST[rv.CRCR5Mutator]MSP[N] return 1 ; } }
public static int min ( final int ... array ) { MST[rv.UOI2Mutator]MSP[N] validateArray ( array ) ; int min = array [ 0 ] ; for ( int j = 1 ; j < array . length ; j ++ ) {
public static int compare ( int x , int y ) { if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } else { return 1 ; } }
if ( hexDigits > 8 || ( hexDigits == 8 && firstSigDigit > '7' ) ) { MST[rv.UOI3Mutator]MSP[N] return createLong ( str ) ; } return createInteger ( str ) ; } final char lastChar = str . charAt ( str . length () - 1 ) ; String mant ;
while ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ;
if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static double min ( final double ... array ) { validateArray ( array ) ; MST[rv.UOI4Mutator]MSP[N] double min = array [ 0 ] ;
public static Number createNumber ( final String str ) throws NumberFormatException { MST[rv.CRCR6Mutator]MSP[S] if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( lr_1 ) ; }
public static int compare ( int x , int y ) { MST[rv.CRCR5Mutator]MSP[N] if ( x == y ) { return 0 ; } if ( x < y ) { return - 1 ; } else { return 1 ; } }
dec = str . substring ( decPos + 1 ) ; MST[rv.ABSMutator]MSP[N] } mant = getMantissa ( str , decPos ) ; numDecimals = dec . length () ; } else { if ( expPos > - 1 ) { if ( expPos > str . length () ) {
