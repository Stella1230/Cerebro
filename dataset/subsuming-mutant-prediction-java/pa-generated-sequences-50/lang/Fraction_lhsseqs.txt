public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR2Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.ROR1Mutator]MSP[] }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOD1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.AOD2Mutator]MSP[] }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; MST[rv.UOI1Mutator]MSP[] x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; MST[rv.UOI4Mutator]MSP[] } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[rv.UOI4Mutator]MSP[]
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[ReturnValsMutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( fraction == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final long s = ( long ) x + ( long ) y ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[NullReturnValsMutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI3Mutator]MSP[] a1 = a2 ; x1 = x2 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[InlineConstantMutator]MSP[] if ( i == 25 ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.CRCR2Mutator]MSP[] k ++ ; } if ( k == 31 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[ArgumentPropagationMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ABSMutator]MSP[] if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI4Mutator]MSP[] if ( u == 0 || v == 0 ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return this . invert () . pow ( - power ) ; } else { MST[InlineConstantMutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.UOI3Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI2Mutator]MSP[] if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[InlineConstantMutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR6Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.AOD1Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.AOR1Mutator]MSP[] return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR3Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI3Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.AOR2Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI3Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.AOR1Mutator]MSP[] a1 = a2 ; x1 = x2 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI3Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR1Mutator]MSP[] if ( u == 0 || v == 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR5Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.UOI3Mutator]MSP[] public boolean equals ( final Object obj ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[MathMutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.AOD2Mutator]MSP[]
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; MST[ConstructorCallMutator]MSP[] final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.UOI1Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
return this . invert () . pow ( - power ) ; } else { MST[rv.ABSMutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; MST[rv.ABSMutator]MSP[] denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI3Mutator]MSP[] } if ( denominator < 0 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.AOR4Mutator]MSP[] if ( pos > 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI2Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.AOR4Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI3Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; MST[rv.CRCR5Mutator]MSP[] int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR2Mutator]MSP[]
if ( this == other ) { MST[rv.UOI4Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.AOR4Mutator]MSP[] y2 = x1 - a2 * y1 ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI4Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI2Mutator]MSP[]
return this . invert () . pow ( - power ) ; MST[rv.UOI1Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[ConditionalsBoundaryMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI3Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR3Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; MST[rv.CRCR4Mutator]MSP[] do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( numerator == 0 ) { MST[rv.CRCR6Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR4Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR6Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[ArgumentPropagationMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI2Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.CRCR4Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI4Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } MST[rv.UOI1Mutator]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[experimental.NakedReceiverMutator]MSP[]
if ( numerator == 0 ) { MST[rv.ROR5Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.ABSMutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR6Mutator]MSP[] }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR5Mutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOD1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[NonVoidMethodCallMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[rv.UOI4Mutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI1Mutator]MSP[] int denom0 = 1 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( this == other ) { MST[rv.AOR3Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.ROR4Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI3Mutator]MSP[]
} int k = 0 ; MST[rv.UOI2Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI2Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ROR3Mutator]MSP[] if ( pos > 0 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ROR4Mutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.AOD2Mutator]MSP[] if ( pos > 0 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ABSMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI2Mutator]MSP[] if ( pos > 0 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[PrimitiveReturnsMutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR6Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ROR3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; MST[rv.UOI2Mutator]MSP[] denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI2Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOD2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[experimental.MemberVariableMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR3Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.UOI4Mutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[ConstructorCallMutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR4Mutator]MSP[] public boolean equals ( final Object obj ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.UOI2Mutator]MSP[] return f . pow ( power / 2 ) ; }
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.OBBN3Mutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.AOR4Mutator]MSP[] }
} int k = 0 ; MST[rv.CRCR2Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
return this . invert () . pow ( - power ) ; } else { MST[experimental.NakedReceiverMutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[ReturnValsMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI2Mutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI3Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI3Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR5Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR4Mutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR2Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
} @Override public int hashCode () { MST[rv.AOD1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR3Mutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { MST[NullReturnValsMutator]MSP[] return this ; } else if ( power == 0 ) { return ONE ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR2Mutator]MSP[] }
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.UOI1Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[InlineConstantMutator]MSP[] return - u * ( 1 << k ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI4Mutator]MSP[] if ( pos > 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI4Mutator]MSP[]
if ( fraction == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI4Mutator]MSP[] y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; MST[ConditionalsBoundaryMutator]MSP[] }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR6Mutator]MSP[] if ( pos > 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI3Mutator]MSP[] x1 = x2 ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI1Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ABSMutator]MSP[] if ( i == 25 ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.UOI3Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] k ++ ; } if ( k == 31 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOD1Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.UOI2Mutator]MSP[] }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR1Mutator]MSP[]
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; MST[rv.CRCR3Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR3Mutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR5Mutator]MSP[] }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[ArgumentPropagationMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ABSMutator]MSP[]
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI2Mutator]MSP[] return - u * ( 1 << k ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[InlineConstantMutator]MSP[] }
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.AOR4Mutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR3Mutator]MSP[] }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[InlineConstantMutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR5Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[rv.CRCR4Mutator]MSP[]
if ( this == other ) { return 0 ; MST[NegateConditionalsMutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI1Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.ABSMutator]MSP[] public double doubleValue () {
} @Override public int hashCode () { MST[rv.AOR3Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI1Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.CRCR3Mutator]MSP[] return f . pow ( power / 2 ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[NegateConditionalsMutator]MSP[] }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[MathMutator]MSP[] int denom0 = 1 ;
throw new NumberFormatException ( lr_9 ) ; MST[rv.CRCR6Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.UOI3Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[MathMutator]MSP[] return - u * ( 1 << k ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[NonVoidMethodCallMutator]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI1Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[InlineConstantMutator]MSP[] return f . pow ( power / 2 ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.UOI1Mutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ; MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR1Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI1Mutator]MSP[] a1 = a2 ; x1 = x2 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.ROR4Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[NullReturnValsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.ABSMutator]MSP[] a1 = a2 ; x1 = x2 ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.AOD1Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( t > 0 ) { MST[rv.UOI2Mutator]MSP[] u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; MST[InlineConstantMutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ; MST[rv.CRCR5Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[NonVoidMethodCallMutator]MSP[] public boolean equals ( final Object obj ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI2Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ROR2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR3Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR3Mutator]MSP[] } if ( denominator < 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[rv.CRCR2Mutator]MSP[] }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI4Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ; MST[rv.ABSMutator]MSP[]
} @Override public int hashCode () { MST[rv.AOR1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; MST[rv.CRCR5Mutator]MSP[] int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.AOR4Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI4Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.ROR3Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI2Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI3Mutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR2Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
} @Override public int hashCode () { MST[rv.AOD2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[rv.ROR4Mutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.AOD2Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR1Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.ROR4Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[NonVoidMethodCallMutator]MSP[] }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI4Mutator]MSP[] }
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI3Mutator]MSP[] }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI1Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.ROR3Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
} int k = 0 ; MST[rv.AOR1Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR1Mutator]MSP[] if ( pos > 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI1Mutator]MSP[] }
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.ROR2Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[ArgumentPropagationMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.UOI4Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; MST[rv.UOI3Mutator]MSP[] double x2 = 0 ; double y1 = value - a1 ;
numer2 = a1 * numer1 + numer0 ; MST[rv.ABSMutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR5Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.CRCR1Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR2Mutator]MSP[] public boolean equals ( final Object obj ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[PrimitiveReturnsMutator]MSP[] public double doubleValue () {
} @Override public int hashCode () { MST[rv.CRCR1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI3Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
return this . invert () . pow ( - power ) ; MST[rv.CRCR2Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.ABSMutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR6Mutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.CRCR6Mutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR3Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR2Mutator]MSP[] if ( i == 25 ) {
} @Override public int hashCode () { MST[rv.AOR2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI1Mutator]MSP[] public double doubleValue () {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR2Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI2Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI3Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[ConditionalsBoundaryMutator]MSP[] } else if ( power == 0 ) { return ONE ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.ABSMutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { return ZERO ; MST[NonVoidMethodCallMutator]MSP[] } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; MST[rv.UOI2Mutator]MSP[] denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( this == other ) { MST[rv.AOD2Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR2Mutator]MSP[] } if ( denominator < 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[]
if ( this == other ) { return 0 ; MST[rv.ROR5Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.ABSMutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR5Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[InlineConstantMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return this . invert () . pow ( - power ) ; } else { MST[rv.CRCR3Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ROR5Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR4Mutator]MSP[] if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.ROR4Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ROR4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[experimental.NakedReceiverMutator]MSP[]
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.ABSMutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR3Mutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.ABSMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI2Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.CRCR5Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[NegateConditionalsMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI3Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.UOI2Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.CRCR3Mutator]MSP[] return - u * ( 1 << k ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI4Mutator]MSP[] }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[]
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.ROR3Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
return this . invert () . pow ( - power ) ; } else { MST[rv.AOR2Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR2Mutator]MSP[] public boolean equals ( final Object obj ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.UOI4Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.CRCR1Mutator]MSP[] return ONE ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[InlineConstantMutator]MSP[]
if ( numerator == 0 ) { MST[rv.ROR4Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI4Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR4Mutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.ABSMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[MathMutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.ROR3Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI1Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[NegateConditionalsMutator]MSP[] final long s = ( long ) x + ( long ) y ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.ROR2Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.AOR3Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[experimental.NakedReceiverMutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI3Mutator]MSP[] }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; MST[rv.CRCR6Mutator]MSP[] int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR4Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.AOR1Mutator]MSP[] }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR1Mutator]MSP[] }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.CRCR6Mutator]MSP[] }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI2Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI1Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOD1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR1Mutator]MSP[]
int numer1 = 1 ; MST[InlineConstantMutator]MSP[] int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR4Mutator]MSP[] } if ( denominator < 0 ) {
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.ROR4Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( numerator >= 0 ) { MST[NullReturnValsMutator]MSP[] return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[InlineConstantMutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[] final long s = ( long ) x + ( long ) y ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI4Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( this == other ) { MST[rv.UOI3Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; MST[rv.CRCR3Mutator]MSP[] double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR6Mutator]MSP[] if ( pos > 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI1Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.UOI2Mutator]MSP[] public boolean equals ( final Object obj ) {
throw new NumberFormatException ( lr_9 ) ; MST[rv.UOI4Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.UOI4Mutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[]
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ; MST[rv.CRCR6Mutator]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[MathMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[rv.CRCR2Mutator]MSP[]
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } MST[rv.UOI2Mutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[InvertNegsMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOD2Mutator]MSP[]
if ( this == other ) { return 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR1Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[InlineConstantMutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR4Mutator]MSP[]
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI4Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI4Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI1Mutator]MSP[] return - u * ( 1 << k ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ROR2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; MST[rv.UOI1Mutator]MSP[] denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( numerator >= 0 ) { MST[ReturnValsMutator]MSP[] return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI3Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.AOD1Mutator]MSP[] y2 = x1 - a2 * y1 ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.ABSMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[NonVoidMethodCallMutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI1Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOD1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR3Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[InvertNegsMutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; MST[rv.ABSMutator]MSP[] } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[ArgumentPropagationMutator]MSP[] x1 = x2 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI3Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[ConditionalsBoundaryMutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOD2Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final long s = ( long ) x + ( long ) y ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ROR2Mutator]MSP[] if ( pos > 0 ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR3Mutator]MSP[] public boolean equals ( final Object obj ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.ABSMutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.UOI2Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[NonVoidMethodCallMutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI4Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR5Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI4Mutator]MSP[] if ( pos > 0 ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.CRCR6Mutator]MSP[]
if ( fraction == null ) { MST[experimental.NakedReceiverMutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR6Mutator]MSP[] }
} int k = 0 ; MST[rv.CRCR1Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( this == other ) { MST[rv.AOR4Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.AOR2Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.UOI1Mutator]MSP[] return ONE ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.CRCR1Mutator]MSP[] k ++ ; } if ( k == 31 ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.CRCR5Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.ABSMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI3Mutator]MSP[] if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.OBBN1Mutator]MSP[] if ( u == 0 || v == 0 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.AOD1Mutator]MSP[] }
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[PrimitiveReturnsMutator]MSP[]
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI4Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
if ( this == other ) { return 0 ; MST[rv.UOI4Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI4Mutator]MSP[] int denom0 = 1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI4Mutator]MSP[] if ( u == 0 || v == 0 ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.CRCR4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI2Mutator]MSP[] x1 = x2 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR2Mutator]MSP[] if ( i == 25 ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.ABSMutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR1Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return f . pow ( power / 2 ) ; }
} @Override public int hashCode () { MST[rv.AOR4Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.ABSMutator]MSP[] a1 = a2 ; x1 = x2 ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.CRCR4Mutator]MSP[] return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI1Mutator]MSP[] if ( i == 25 ) {
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.CRCR1Mutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI3Mutator]MSP[] if ( pos > 0 ) {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.CRCR3Mutator]MSP[] }
throw new ArithmeticException ( lr_2 ) ; MST[ConditionalsBoundaryMutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR3Mutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI2Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
int pos = str . indexOf ( '.' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI4Mutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR5Mutator]MSP[] public boolean equals ( final Object obj ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR4Mutator]MSP[] } if ( denominator < 0 ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI3Mutator]MSP[] return - u * ( 1 << k ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR1Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[ReturnValsMutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.UOI3Mutator]MSP[]
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI3Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI2Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR1Mutator]MSP[] } if ( denominator < 0 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.CRCR3Mutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR3Mutator]MSP[] public boolean equals ( final Object obj ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR2Mutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.OBBN2Mutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR1Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[InlineConstantMutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( t > 0 ) { MST[rv.UOI3Mutator]MSP[] u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
if ( numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; MST[ConstructorCallMutator]MSP[] } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI1Mutator]MSP[] if ( pos > 0 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
return this . invert () . pow ( - power ) ; MST[rv.UOI2Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.UOI4Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
numer2 = a1 * numer1 + numer0 ; MST[MathMutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI4Mutator]MSP[] }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI2Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.ROR3Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI3Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI4Mutator]MSP[] x1 = x2 ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI3Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
private static int mulAndCheck ( final int x , final int y ) { MST[ConditionalsBoundaryMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
} int k = 0 ; MST[rv.UOI1Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR5Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR6Mutator]MSP[] if ( i == 25 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
final int properNumerator = getProperNumerator () ; MST[experimental.NakedReceiverMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI1Mutator]MSP[]
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; MST[rv.CRCR3Mutator]MSP[] double y1 = value - a1 ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI4Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[InlineConstantMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.ROR3Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
private static int mulAndCheck ( final int x , final int y ) { MST[InlineConstantMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR4Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI3Mutator]MSP[] y2 = x1 - a2 * y1 ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.AOR3Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI4Mutator]MSP[] }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } if ( denominator < 0 ) {
denominator /= gcd ; MST[rv.ABSMutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.UOI2Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
return numerator / denominator ; } @Override public long longValue () { MST[rv.AOR2Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; MST[rv.UOI2Mutator]MSP[] } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.UOI1Mutator]MSP[] k ++ ; } if ( k == 31 ) {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; MST[InvertNegsMutator]MSP[] numerator /= gcd ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[ReturnValsMutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[InvertNegsMutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.CRCR1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[InlineConstantMutator]MSP[] } if ( denominator < 0 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI4Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI2Mutator]MSP[] }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI3Mutator]MSP[] }
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.ROR5Mutator]MSP[]
if ( numerator == 0 ) { MST[rv.CRCR1Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return numerator / denominator ; } @Override public long longValue () { MST[rv.AOD1Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ABSMutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.UOI1Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI2Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.ROR2Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
if ( numerator >= 0 ) { MST[experimental.NakedReceiverMutator]MSP[] return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI4Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI1Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[NegateConditionalsMutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[ConstructorCallMutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR4Mutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI4Mutator]MSP[]
} @Override public int hashCode () { MST[rv.CRCR2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[rv.UOI3Mutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.AOD2Mutator]MSP[] public double doubleValue () {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; MST[rv.CRCR6Mutator]MSP[] int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
return this . invert () . pow ( - power ) ; MST[rv.CRCR3Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( this == other ) { return 0 ; MST[rv.ROR4Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[NegateConditionalsMutator]MSP[]
} @Override public int hashCode () { MST[MathMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.ABSMutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; MST[rv.UOI2Mutator]MSP[] double x2 = 0 ; double y1 = value - a1 ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI2Mutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI4Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR2Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR5Mutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; MST[rv.UOI1Mutator]MSP[] denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR1Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return this . invert () . pow ( - power ) ; MST[MathMutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR6Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[ConditionalsBoundaryMutator]MSP[]
throw new NumberFormatException ( lr_9 ) ; MST[rv.AOD2Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[NullReturnValsMutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.CRCR2Mutator]MSP[] return - u * ( 1 << k ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR1Mutator]MSP[] if ( i == 25 ) {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return this ; }
} @Override public int hashCode () { MST[rv.AOR3Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI2Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
} @Override public int hashCode () { MST[rv.AOD2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
return this . invert () . pow ( - power ) ; } else { MST[rv.AOR1Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.CRCR2Mutator]MSP[] return ONE ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR4Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; MST[rv.ABSMutator]MSP[] denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR2Mutator]MSP[] }
int numer1 = 1 ; MST[rv.CRCR5Mutator]MSP[] int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI1Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR2Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.AOR3Mutator]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI1Mutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.ABSMutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR3Mutator]MSP[] if ( i == 25 ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.ABSMutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.ROR1Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.UOI3Mutator]MSP[] }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.ROR5Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR1Mutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI1Mutator]MSP[] } if ( denominator < 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.AOR1Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[ConstructorCallMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[] }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI3Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.AOR3Mutator]MSP[] x1 = x2 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[rv.CRCR2Mutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ONE ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[NegateConditionalsMutator]MSP[] if ( u == 0 || v == 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.ABSMutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOD2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.ABSMutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI1Mutator]MSP[] if ( i == 25 ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ABSMutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.ROR2Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
final int properNumerator = getProperNumerator () ; MST[NonVoidMethodCallMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NonVoidMethodCallMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[ArgumentPropagationMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[NullReturnValsMutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
return this . invert () . pow ( - power ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[NonVoidMethodCallMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.ABSMutator]MSP[] x1 = x2 ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR4Mutator]MSP[]
int numer1 = 1 ; int denom1 = 0 ; MST[rv.CRCR2Mutator]MSP[] int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[]
return this . invert () . pow ( - power ) ; } else { MST[NonVoidMethodCallMutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI2Mutator]MSP[] a1 = a2 ; x1 = x2 ;
return this . invert () . pow ( - power ) ; } else { MST[rv.CRCR4Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[ConditionalsBoundaryMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[] if ( pos > 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ROR3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
} @Override public int hashCode () { MST[rv.CRCR1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI1Mutator]MSP[]
if ( numerator == 0 ) { MST[NegateConditionalsMutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; MST[InlineConstantMutator]MSP[] do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ROR3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[MathMutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[experimental.NakedReceiverMutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ABSMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new NumberFormatException ( lr_9 ) ; MST[rv.CRCR5Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
y1 = y2 ; MST[rv.UOI4Mutator]MSP[] numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.ABSMutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
denominator /= gcd ; MST[rv.UOI1Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR2Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[NegateConditionalsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.CRCR5Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ABSMutator]MSP[] public boolean equals ( final Object obj ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.ROR2Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR1Mutator]MSP[]
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI4Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
double y2 = 0 ; MST[rv.CRCR3Mutator]MSP[] double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ABSMutator]MSP[] if ( pos > 0 ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] public boolean equals ( final Object obj ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR4Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI2Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI3Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[rv.CRCR3Mutator]MSP[] }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[rv.CRCR5Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.ROR3Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.AOD2Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.ABSMutator]MSP[] } else if ( power == 0 ) { return ONE ;
numer2 = a1 * numer1 + numer0 ; MST[rv.ABSMutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.ROR1Mutator]MSP[] k ++ ; } if ( k == 31 ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; MST[rv.CRCR1Mutator]MSP[] int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[NonVoidMethodCallMutator]MSP[]
} @Override public int hashCode () { MST[experimental.MemberVariableMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR3Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[ReturnValsMutator]MSP[] public double doubleValue () {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI3Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.AOD2Mutator]MSP[]
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.UOI3Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI1Mutator]MSP[] x1 = x2 ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI3Mutator]MSP[] int denom0 = 1 ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.CRCR3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[InlineConstantMutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR1Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.ROR4Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR5Mutator]MSP[] }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI1Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[ReturnValsMutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR2Mutator]MSP[]
final int properNumerator = getProperNumerator () ; MST[NonVoidMethodCallMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI2Mutator]MSP[] if ( i == 25 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.CRCR2Mutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.UOI3Mutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ABSMutator]MSP[] if ( pos > 0 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR5Mutator]MSP[] } if ( denominator < 0 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
int numer1 = 1 ; MST[rv.CRCR6Mutator]MSP[] int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR4Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.UOI2Mutator]MSP[]
if ( this == other ) { return 0 ; MST[rv.UOI1Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI4Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.AOD2Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[ConditionalsBoundaryMutator]MSP[]
if ( fraction == null ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.UOI1Mutator]MSP[] }
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
if ( fraction == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
return this . invert () . pow ( - power ) ; MST[rv.ROR2Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.ROR4Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ABSMutator]MSP[] if ( i == 25 ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.UOI3Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; MST[rv.UOI4Mutator]MSP[] denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.ABSMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.AOR1Mutator]MSP[] return - u * ( 1 << k ) ; }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI3Mutator]MSP[] }
final int properNumerator = getProperNumerator () ; if ( properNumerator == 0 ) { MST[ReturnValsMutator]MSP[] toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
return this . invert () . pow ( - power ) ; } else { MST[rv.CRCR2Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOD1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI4Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.AOR1Mutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[ArgumentPropagationMutator]MSP[] }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.ABSMutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; MST[rv.UOI1Mutator]MSP[] } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[NegateConditionalsMutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[InlineConstantMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; MST[rv.ABSMutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[MathMutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[ArgumentPropagationMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI2Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR5Mutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[InlineConstantMutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return this ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR1Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[MathMutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[MathMutator]MSP[] if ( pos > 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.ABSMutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.CRCR5Mutator]MSP[] return f . pow ( power / 2 ) ; }
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.AOD1Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[NegateConditionalsMutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI2Mutator]MSP[] if ( pos > 0 ) {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { MST[ReturnValsMutator]MSP[] return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR6Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[NullReturnValsMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI1Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI3Mutator]MSP[] y2 = x1 - a2 * y1 ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; MST[InlineConstantMutator]MSP[] double y1 = value - a1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI3Mutator]MSP[] if ( u == 0 || v == 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI1Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ABSMutator]MSP[]
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.ROR1Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
denominator /= gcd ; MST[rv.ABSMutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[ConstructorCallMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[] if ( pos > 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI2Mutator]MSP[]
private static int mulAndCheck ( final int x , final int y ) { MST[ConstructorCallMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR5Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[rv.CRCR3Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR3Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return this . invert () . pow ( - power ) ; MST[rv.ROR5Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; MST[InlineConstantMutator]MSP[] int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR5Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ABSMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.CRCR5Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[NegateConditionalsMutator]MSP[]
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.AOR2Mutator]MSP[] }
int numer1 = 1 ; MST[rv.CRCR3Mutator]MSP[] int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[InlineConstantMutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
if ( this == other ) { return 0 ; MST[rv.UOI4Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( this == other ) { MST[rv.UOI2Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new NumberFormatException ( lr_9 ) ; MST[MathMutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { MST[rv.UOI2Mutator]MSP[] t /= 2 ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI2Mutator]MSP[] }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.AOR2Mutator]MSP[] y2 = x1 - a2 * y1 ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI2Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } else if ( power == 0 ) { return ONE ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.UOI3Mutator]MSP[] return f . pow ( power / 2 ) ; }
return this . invert () . pow ( - power ) ; } else { MST[rv.AOD1Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[NegateConditionalsMutator]MSP[] if ( i == 25 ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR4Mutator]MSP[] public boolean equals ( final Object obj ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[NegateConditionalsMutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.UOI3Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ROR4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR1Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI1Mutator]MSP[]
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[NullReturnValsMutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.ABSMutator]MSP[]
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI1Mutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.ABSMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( this == other ) { MST[rv.UOI1Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI1Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI3Mutator]MSP[] x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[MathMutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; MST[rv.UOI4Mutator]MSP[] } if ( v > 0 ) { v = - v ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI1Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.UOI2Mutator]MSP[] return ONE ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.AOR1Mutator]MSP[] int denom0 = 1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI3Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.ABSMutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.UOI1Mutator]MSP[] public boolean equals ( final Object obj ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI2Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR3Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
return this . invert () . pow ( - power ) ; MST[rv.AOR2Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ABSMutator]MSP[]
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI3Mutator]MSP[]
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[NonVoidMethodCallMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ROR4Mutator]MSP[] if ( pos > 0 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[experimental.BigIntegerMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR4Mutator]MSP[] public boolean equals ( final Object obj ) {
numer2 = a1 * numer1 + numer0 ; MST[MathMutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.ROR5Mutator]MSP[] return ONE ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR2Mutator]MSP[] }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[ArgumentPropagationMutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
private static int mulAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR5Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI2Mutator]MSP[] }
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI3Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOD1Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI4Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI1Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI2Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( u == 0 || v == 0 ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ROR1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.ROR5Mutator]MSP[] k ++ ; } if ( k == 31 ) {
} @Override public int hashCode () { MST[NonVoidMethodCallMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI2Mutator]MSP[] } if ( denominator < 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI4Mutator]MSP[] if ( u == 0 || v == 0 ) {
} @Override public int hashCode () { MST[rv.CRCR2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI2Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { MST[rv.CRCR2Mutator]MSP[] delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; MST[rv.UOI2Mutator]MSP[] } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.AOD2Mutator]MSP[] int denom0 = 1 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI4Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI4Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () { MST[ReturnValsMutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI1Mutator]MSP[] a1 = a2 ; x1 = x2 ;
throw new NumberFormatException ( lr_9 ) ; MST[rv.AOR3Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI2Mutator]MSP[] if ( u == 0 || v == 0 ) {
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.ABSMutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[NonVoidMethodCallMutator]MSP[] public boolean equals ( final Object obj ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.AOD1Mutator]MSP[] if ( pos > 0 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ROR3Mutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI2Mutator]MSP[]
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[MathMutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOD2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI1Mutator]MSP[] } if ( denominator < 0 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ABSMutator]MSP[] } if ( denominator < 0 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.CRCR1Mutator]MSP[]
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ABSMutator]MSP[]
if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { throw new ArithmeticException ( lr_3 ) ; } if ( numerator < 0 ) { MST[ConstructorCallMutator]MSP[] throw new ArithmeticException ( lr_4 ) ; } long numeratorValue ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.AOR4Mutator]MSP[] int denom0 = 1 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( i == 25 ) {
} int k = 0 ; MST[rv.AOR4Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[ConditionalsBoundaryMutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
final long second = ( long ) other . numerator * ( long ) denominator ; if ( first == second ) { return 0 ; } else if ( first < second ) { return - 1 ; } else { return 1 ; } } @Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.OBBN3Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.CRCR3Mutator]MSP[] return ONE ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
denominator /= gcd ; MST[rv.UOI2Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[InlineConstantMutator]MSP[] if ( i == 25 ) {
private static int mulAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_14 ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.AOR4Mutator]MSP[] return - u * ( 1 << k ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.UOI4Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( this == other ) { MST[rv.ABSMutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR6Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
return this . invert () . pow ( - power ) ; } else { MST[rv.CRCR5Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.ROR1Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[NegateConditionalsMutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
} @Override public int hashCode () { MST[InlineConstantMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.UOI4Mutator]MSP[] }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.ABSMutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( fraction == null ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR2Mutator]MSP[] public boolean equals ( final Object obj ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[InlineConstantMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR1Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return numerator / denominator ; } @Override public long longValue () { MST[rv.ABSMutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[BooleanTrueReturnValsMutator]MSP[] public boolean equals ( final Object obj ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR3Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR4Mutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { MST[experimental.MemberVariableMutator]MSP[] toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[ReturnValsMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI2Mutator]MSP[] int denom0 = 1 ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { MST[ReturnValsMutator]MSP[] numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.CRCR6Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[] public boolean equals ( final Object obj ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[NegateConditionalsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI3Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR5Mutator]MSP[] public boolean equals ( final Object obj ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.ROR1Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.ABSMutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ABSMutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[NegateConditionalsMutator]MSP[] } if ( denominator < 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[NegateConditionalsMutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR3Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR1Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; MST[rv.CRCR5Mutator]MSP[] int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.ROR2Mutator]MSP[] k ++ ; } if ( k == 31 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[RemoveConditionalMutator_ORDER_IF]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.CRCR2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.AOD2Mutator]MSP[]
if ( numerator == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
return numerator / denominator ; } @Override public long longValue () { MST[rv.AOD2Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.ROR1Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[ReturnValsMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ABSMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI4Mutator]MSP[] x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; MST[rv.AOD2Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( fraction == null ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[InlineConstantMutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[NegateConditionalsMutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.CRCR6Mutator]MSP[] return ONE ;
return this . invert () . pow ( - power ) ; } else { MST[rv.UOI3Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.UOI2Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.AOD1Mutator]MSP[] return f . pow ( power / 2 ) ; }
return this . invert () . pow ( - power ) ; } else { MST[rv.UOI1Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[MathMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.AOD1Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
int numer1 = 1 ; int denom1 = 0 ; MST[InlineConstantMutator]MSP[] int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[PrimitiveReturnsMutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI4Mutator]MSP[] } if ( denominator < 0 ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; MST[rv.CRCR3Mutator]MSP[] int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[InlineConstantMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.AOR4Mutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[NegateConditionalsMutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; MST[rv.UOI4Mutator]MSP[] } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[NegateConditionalsMutator]MSP[] if ( i == 25 ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI2Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR4Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR4Mutator]MSP[]
y1 = y2 ; MST[rv.UOI3Mutator]MSP[] numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[MathMutator]MSP[] a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR5Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.AOR3Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI2Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR3Mutator]MSP[]
if ( this == other ) { MST[rv.UOI4Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new NumberFormatException ( lr_9 ) ; MST[rv.AOD1Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.UOI2Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ABSMutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR1Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.ROR1Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ROR4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI4Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.ABSMutator]MSP[] int denom0 = 1 ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.AOR3Mutator]MSP[] if ( pos > 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[ConditionalsBoundaryMutator]MSP[]
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.CRCR5Mutator]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI4Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI4Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR5Mutator]MSP[] }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.UOI4Mutator]MSP[] public boolean equals ( final Object obj ) {
final long s = ( long ) x - ( long ) y ; if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[PrimitiveReturnsMutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI4Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[ReturnValsMutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
} else if ( numerator == denominator ) { MST[NonVoidMethodCallMutator]MSP[] toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOD1Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[MathMutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; MST[rv.CRCR3Mutator]MSP[] do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[InlineConstantMutator]MSP[] final long s = ( long ) x + ( long ) y ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR4Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.ROR1Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI4Mutator]MSP[] }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.AOR2Mutator]MSP[] x1 = x2 ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.ROR3Mutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.ROR5Mutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return this . invert () . pow ( - power ) ; MST[rv.CRCR5Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; MST[rv.CRCR1Mutator]MSP[] int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
denominator /= gcd ; MST[ArgumentPropagationMutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI3Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ABSMutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI4Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR1Mutator]MSP[] if ( i == 25 ) {
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; MST[rv.CRCR1Mutator]MSP[]
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR4Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR2Mutator]MSP[] public boolean equals ( final Object obj ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[NonVoidMethodCallMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; MST[rv.CRCR1Mutator]MSP[] double y1 = value - a1 ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[NonVoidMethodCallMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return this ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR4Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[NegateConditionalsMutator]MSP[] } else if ( power == 0 ) { return ONE ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[MathMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] k ++ ; } if ( k == 31 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR3Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOD1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR4Mutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR6Mutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR5Mutator]MSP[] if ( i == 25 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[NegateConditionalsMutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( u == 0 || v == 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( i == 25 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.AOR1Mutator]MSP[] public double doubleValue () {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[NullReturnValsMutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return this ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR3Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.AOD1Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[ArgumentPropagationMutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.UOI4Mutator]MSP[] return ONE ;
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI4Mutator]MSP[] }
if ( this == other ) { return 0 ; MST[rv.ROR3Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.CRCR4Mutator]MSP[] return - u * ( 1 << k ) ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI4Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR3Mutator]MSP[] if ( i == 25 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ABSMutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[experimental.NakedReceiverMutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.ROR4Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR1Mutator]MSP[] }
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.CRCR3Mutator]MSP[]
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.ABSMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.AOR3Mutator]MSP[] }
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.AOR1Mutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR6Mutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR6Mutator]MSP[]
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.CRCR6Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
int numer1 = 1 ; int denom1 = 0 ; MST[rv.CRCR4Mutator]MSP[] int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR3Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( this == other ) { MST[rv.AOR1Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.UOI1Mutator]MSP[] }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[MathMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.CRCR4Mutator]MSP[]
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.UOI1Mutator]MSP[] return f . pow ( power / 2 ) ; }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI1Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR3Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.UOI4Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; MST[rv.UOI4Mutator]MSP[] double x2 = 0 ; double y1 = value - a1 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR6Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[ReturnValsMutator]MSP[] return - u * ( 1 << k ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[NegateConditionalsMutator]MSP[] if ( pos > 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR1Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( fraction == null ) { MST[ReturnValsMutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[NegateConditionalsMutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; MST[rv.UOI2Mutator]MSP[] x2 = y1 ; y2 = x1 - a2 * y1 ;
final long s = ( long ) x - ( long ) y ; if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI2Mutator]MSP[] if ( u == 0 || v == 0 ) {
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI1Mutator]MSP[] }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[NegateConditionalsMutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR1Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.ROR4Mutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR3Mutator]MSP[] if ( pos > 0 ) {
final int properNumerator = getProperNumerator () ; MST[experimental.NakedReceiverMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_2 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; MST[InvertNegsMutator]MSP[] } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[MathMutator]MSP[] if ( u == 0 || v == 0 ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; MST[rv.UOI1Mutator]MSP[] double x2 = 0 ; double y1 = value - a1 ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[rv.CRCR5Mutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOD2Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR2Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
final int properNumerator = getProperNumerator () ; MST[experimental.MemberVariableMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI1Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.AOR2Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NegateConditionalsMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI3Mutator]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI1Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[ConditionalsBoundaryMutator]MSP[] final long s = ( long ) x + ( long ) y ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[NegateConditionalsMutator]MSP[] public boolean equals ( final Object obj ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI1Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR5Mutator]MSP[] if ( i == 25 ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { MST[IncrementsMutator]MSP[] u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR3Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.ABSMutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[ReturnValsMutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.ROR1Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[rv.ABSMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.AOR2Mutator]MSP[] return f . pow ( power / 2 ) ; }
final long second = ( long ) other . numerator * ( long ) denominator ; if ( first == second ) { return 0 ; } else if ( first < second ) { return - 1 ; } else { return 1 ; } } @Override MST[NegateConditionalsMutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; MST[rv.UOI3Mutator]MSP[] numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[ArgumentPropagationMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR2Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI2Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR4Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR5Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.ABSMutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR2Mutator]MSP[] if ( i == 25 ) {
} @Override public int hashCode () { MST[rv.AOD1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.AOR1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { MST[ReturnValsMutator]MSP[] return this ; } else if ( power == 0 ) { return ONE ;
} @Override public int hashCode () { MST[rv.CRCR4Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) { MST[PrimitiveReturnsMutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI1Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[experimental.BigIntegerMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR1Mutator]MSP[]
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
private static int mulAndCheck ( final int x , final int y ) { MST[NegateConditionalsMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI1Mutator]MSP[] x1 = x2 ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[ArgumentPropagationMutator]MSP[] return f . pow ( power / 2 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.ABSMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI3Mutator]MSP[] if ( u == 0 || v == 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI4Mutator]MSP[] a1 = a2 ; x1 = x2 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ROR1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.UOI2Mutator]MSP[]
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[NullReturnValsMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.ABSMutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR2Mutator]MSP[]
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.CRCR6Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.AOD1Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.ABSMutator]MSP[] return - u * ( 1 << k ) ; }
final long s = ( long ) x - ( long ) y ; if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; MST[rv.CRCR1Mutator]MSP[] double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[MathMutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.ROR4Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR6Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.AOD2Mutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return this ; }
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.CRCR4Mutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR3Mutator]MSP[] }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI4Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( pos > 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.OBBN2Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( numerator >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR5Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[rv.CRCR5Mutator]MSP[] }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ABSMutator]MSP[] }
double y2 = 0 ; MST[rv.CRCR1Mutator]MSP[] double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( i == 25 ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[NonVoidMethodCallMutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR6Mutator]MSP[] public boolean equals ( final Object obj ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI4Mutator]MSP[] y2 = x1 - a2 * y1 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI4Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[NullReturnValsMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[NegateConditionalsMutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.UOI3Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
} int k = 0 ; MST[rv.CRCR1Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[NegateConditionalsMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[ConditionalsBoundaryMutator]MSP[] if ( u == 0 || v == 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR4Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR3Mutator]MSP[] if ( i == 25 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[NullReturnValsMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR4Mutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI2Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR6Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI1Mutator]MSP[] if ( i == 25 ) {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR4Mutator]MSP[] }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) { MST[ReturnValsMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI3Mutator]MSP[] if ( pos > 0 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.AOR4Mutator]MSP[] public double doubleValue () {
throw new NumberFormatException ( lr_9 ) ; MST[rv.CRCR3Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR5Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( this == other ) { return 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR6Mutator]MSP[] } if ( denominator < 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.AOR3Mutator]MSP[] a1 = a2 ; x1 = x2 ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR3Mutator]MSP[] } if ( denominator < 0 ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI4Mutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.ABSMutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[MathMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[MathMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR1Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[MathMutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
return numerator / denominator ; } @Override public long longValue () { MST[rv.AOR3Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.ROR4Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.AOR4Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[NegateConditionalsMutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR1Mutator]MSP[] public boolean equals ( final Object obj ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( u == 0 || v == 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.AOR3Mutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR2Mutator]MSP[] } if ( denominator < 0 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI3Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[ReturnValsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR3Mutator]MSP[] if ( pos > 0 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) { MST[rv.UOI4Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
return this . invert () . pow ( - power ) ; } else { MST[ReturnValsMutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.CRCR2Mutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[MathMutator]MSP[] } if ( denominator < 0 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.CRCR5Mutator]MSP[] }
final long s = ( long ) x - ( long ) y ; if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[ReturnValsMutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[experimental.NakedReceiverMutator]MSP[]
if ( numerator == 0 ) { MST[rv.ROR3Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.ROR2Mutator]MSP[] }
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI1Mutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR2Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( this == other ) { return 0 ; MST[rv.UOI2Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI1Mutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) { MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } MST[rv.UOI3Mutator]MSP[]
double y2 = 0 ; MST[InlineConstantMutator]MSP[] double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
return this . invert () . pow ( - power ) ; MST[rv.AOD1Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.ABSMutator]MSP[] }
} @Override public int hashCode () { MST[rv.AOR2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR1Mutator]MSP[] if ( i == 25 ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.CRCR2Mutator]MSP[] return f . pow ( power / 2 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOD2Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.ROR4Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[ConditionalsBoundaryMutator]MSP[] if ( i == 25 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI2Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.CRCR5Mutator]MSP[] }
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.CRCR3Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR2Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; MST[rv.ABSMutator]MSP[] x2 = y1 ; y2 = x1 - a2 * y1 ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ; MST[rv.UOI3Mutator]MSP[]
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI3Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI1Mutator]MSP[] y2 = x1 - a2 * y1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI2Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR4Mutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR5Mutator]MSP[] } if ( denominator < 0 ) {
denominator /= gcd ; MST[rv.UOI2Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; MST[InlineConstantMutator]MSP[] double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR1Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; MST[ConstructorCallMutator]MSP[] } public static Fraction getReducedFraction ( int numerator , int denominator ) { if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; MST[rv.AOD2Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR5Mutator]MSP[] public boolean equals ( final Object obj ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[ConditionalsBoundaryMutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; MST[IncrementsMutator]MSP[] } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR1Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR4Mutator]MSP[] if ( i == 25 ) {
if ( fraction == null ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI1Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.AOR2Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI1Mutator]MSP[] }
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR6Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; MST[rv.UOI3Mutator]MSP[] i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ROR1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR5Mutator]MSP[]
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[NonVoidMethodCallMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI2Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[ConstructorCallMutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.ROR1Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[NegateConditionalsMutator]MSP[] if ( u == 0 || v == 0 ) {
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; MST[rv.UOI1Mutator]MSP[] } if ( v > 0 ) { v = - v ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ; MST[rv.UOI2Mutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.ABSMutator]MSP[] int denom0 = 1 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR3Mutator]MSP[] if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR1Mutator]MSP[] if ( u == 0 || v == 0 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI3Mutator]MSP[] public double doubleValue () {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI2Mutator]MSP[] public double doubleValue () {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[NegateConditionalsMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; MST[ConstructorCallMutator]MSP[] denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI3Mutator]MSP[]
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.ABSMutator]MSP[] }
final int properNumerator = getProperNumerator () ; MST[NonVoidMethodCallMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[rv.ROR3Mutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR3Mutator]MSP[] public boolean equals ( final Object obj ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[experimental.BigIntegerMutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR2Mutator]MSP[] } if ( denominator < 0 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[NegateConditionalsMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI2Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.AOD1Mutator]MSP[] x1 = x2 ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[MathMutator]MSP[] }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( i == 25 ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } if ( denominator < 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI4Mutator]MSP[] x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI2Mutator]MSP[] a1 = a2 ; x1 = x2 ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.ROR5Mutator]MSP[] }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI2Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[PrimitiveReturnsMutator]MSP[] return - u * ( 1 << k ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[ArgumentPropagationMutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.OBBN2Mutator]MSP[] } if ( denominator < 0 ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ROR1Mutator]MSP[] if ( pos > 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI4Mutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.AOR4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.AOR4Mutator]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR3Mutator]MSP[] }
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI4Mutator]MSP[]
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[rv.CRCR5Mutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( pos > 0 ) {
} @Override public int hashCode () { MST[rv.CRCR4Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { MST[rv.CRCR4Mutator]MSP[] delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI4Mutator]MSP[] } if ( denominator < 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[MathMutator]MSP[] if ( u == 0 || v == 0 ) {
final long s = ( long ) x - ( long ) y ; if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; }
if ( numerator == 0 ) { MST[rv.CRCR3Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[InlineConstantMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( pos > 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR5Mutator]MSP[] if ( i == 25 ) {
throw new NumberFormatException ( lr_9 ) ; MST[rv.AOR1Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR4Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.ROR1Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ROR1Mutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR3Mutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR5Mutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.AOR1Mutator]MSP[] if ( pos > 0 ) {
} int k = 0 ; MST[rv.AOD1Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOD1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI4Mutator]MSP[] int denom0 = 1 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ABSMutator]MSP[]
final int properNumerator = getProperNumerator () ; MST[experimental.NakedReceiverMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR1Mutator]MSP[] if ( i == 25 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[InlineConstantMutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; MST[rv.AOD1Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.AOR1Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.ABSMutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ; MST[rv.CRCR2Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; MST[InlineConstantMutator]MSP[] int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.AOR2Mutator]MSP[] public double doubleValue () {
return this . invert () . pow ( - power ) ; MST[rv.UOI4Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[InlineConstantMutator]MSP[] if ( pos > 0 ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[NonVoidMethodCallMutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; MST[rv.UOI2Mutator]MSP[] numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR1Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR3Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR4Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOD2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( this == other ) { MST[rv.UOI3Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI1Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[experimental.NakedReceiverMutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) { MST[rv.ABSMutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR5Mutator]MSP[]
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[experimental.NakedReceiverMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
private static int mulAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_14 ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR4Mutator]MSP[]
final int properNumerator = getProperNumerator () ; MST[NonVoidMethodCallMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { MST[NullReturnValsMutator]MSP[] return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[ReturnValsMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR3Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR2Mutator]MSP[]
final long s = ( long ) x - ( long ) y ; if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } if ( denominator < 0 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.ABSMutator]MSP[] }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI4Mutator]MSP[] }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[MathMutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR2Mutator]MSP[] }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.CRCR5Mutator]MSP[] return ONE ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final long s = ( long ) x + ( long ) y ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( u == 0 || v == 0 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.ROR4Mutator]MSP[] k ++ ; } if ( k == 31 ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; MST[rv.ABSMutator]MSP[] } while ( t != 0 ); return - u * ( 1 << k ) ; }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[ArgumentPropagationMutator]MSP[]
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI3Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; MST[rv.UOI1Mutator]MSP[] } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.ABSMutator]MSP[]
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.ROR2Mutator]MSP[] }
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.ROR2Mutator]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[NonVoidMethodCallMutator]MSP[] }
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[ReturnValsMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.ROR4Mutator]MSP[] }
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; MST[rv.UOI2Mutator]MSP[] numerator /= gcd ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[PrimitiveReturnsMutator]MSP[] if ( u == 0 || v == 0 ) {
if ( this == other ) { return 0 ; MST[rv.ABSMutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.AOD1Mutator]MSP[] return - u * ( 1 << k ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI4Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_2 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.CRCR4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.AOR1Mutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
} @Override public int hashCode () { MST[rv.CRCR5Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[ReturnValsMutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI2Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.AOR2Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.AOD2Mutator]MSP[] a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ABSMutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return this ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR5Mutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[InlineConstantMutator]MSP[] }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[ConstructorCallMutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.UOI3Mutator]MSP[] return ONE ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI2Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[experimental.NakedReceiverMutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.ROR1Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
return numerator / denominator ; } @Override public long longValue () { MST[MathMutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[ConstructorCallMutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR6Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.AOR4Mutator]MSP[] a1 = a2 ; x1 = x2 ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[InlineConstantMutator]MSP[] }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
denominator /= gcd ; MST[rv.UOI4Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[ArgumentPropagationMutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.CRCR3Mutator]MSP[]
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI2Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[MathMutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI3Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ABSMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[ConditionalsBoundaryMutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOD2Mutator]MSP[]
throw new NumberFormatException ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[MathMutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; MST[rv.ABSMutator]MSP[] numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.ROR5Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
int numer1 = 1 ; int denom1 = 0 ; MST[rv.CRCR5Mutator]MSP[] int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR2Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[NegateConditionalsMutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[ReturnValsMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( this == other ) { return 0 ; MST[rv.ROR2Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[] } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.ROR1Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI3Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.CRCR2Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI3Mutator]MSP[] }
} @Override public int hashCode () { MST[rv.AOD2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( fraction == null ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[rv.CRCR4Mutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.ROR5Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR3Mutator]MSP[] public boolean equals ( final Object obj ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR2Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[NonVoidMethodCallMutator]MSP[] }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI3Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI1Mutator]MSP[] int denom0 = 1 ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
throw new NumberFormatException ( lr_9 ) ; MST[rv.UOI2Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.CRCR1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.ROR1Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[InlineConstantMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( pos > 0 ) {
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI1Mutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[MathMutator]MSP[] x1 = x2 ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.ABSMutator]MSP[]
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[experimental.NakedReceiverMutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { MST[NonVoidMethodCallMutator]MSP[] toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[experimental.BigIntegerMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.CRCR4Mutator]MSP[] }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[NegateConditionalsMutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.UOI1Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ; MST[rv.UOI2Mutator]MSP[]
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.AOR3Mutator]MSP[] }
denominator /= gcd ; MST[rv.UOI3Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.ABSMutator]MSP[] }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR5Mutator]MSP[] public boolean equals ( final Object obj ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[ArgumentPropagationMutator]MSP[] return this ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[NonVoidMethodCallMutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.ABSMutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; MST[ConstructorCallMutator]MSP[] if ( m > Integer . MAX_VALUE ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[InvertNegsMutator]MSP[] if ( u == 0 || v == 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOD1Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI2Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI2Mutator]MSP[] public double doubleValue () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR1Mutator]MSP[] if ( u == 0 || v == 0 ) {
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.CRCR4Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; MST[rv.UOI2Mutator]MSP[] i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI3Mutator]MSP[] return - u * ( 1 << k ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.AOD1Mutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR3Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; MST[rv.UOI2Mutator]MSP[] } if ( v > 0 ) { v = - v ;
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI1Mutator]MSP[] }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI3Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI3Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI4Mutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR5Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.ABSMutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR3Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR2Mutator]MSP[] if ( i == 25 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI2Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
final int properNumerator = getProperNumerator () ; MST[ConstructorCallMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR5Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI2Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
return this . invert () . pow ( - power ) ; MST[rv.AOR4Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI2Mutator]MSP[] if ( pos > 0 ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI3Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
private static int mulAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[PrimitiveReturnsMutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) {
final long second = ( long ) other . numerator * ( long ) denominator ; if ( first == second ) { return 0 ; } else if ( first < second ) { return - 1 ; } else { return 1 ; } } @Override MST[rv.ROR5Mutator]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR2Mutator]MSP[]
int pos = str . indexOf ( '.' ) ; MST[NullReturnValsMutator]MSP[] if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.ABSMutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[ReturnValsMutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[]
if ( numerator == 0 ) { MST[rv.ROR2Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI1Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR4Mutator]MSP[]
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; MST[rv.ROR3Mutator]MSP[] } while ( t != 0 ); return - u * ( 1 << k ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NullReturnValsMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI1Mutator]MSP[] y2 = x1 - a2 * y1 ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; MST[rv.UOI4Mutator]MSP[] x2 = y1 ; y2 = x1 - a2 * y1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR6Mutator]MSP[] if ( u == 0 || v == 0 ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[rv.UOI1Mutator]MSP[]
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.CRCR5Mutator]MSP[] k ++ ; } if ( k == 31 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[NonVoidMethodCallMutator]MSP[] }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI2Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR3Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.CRCR6Mutator]MSP[] return f . pow ( power / 2 ) ; }
int numer1 = 1 ; MST[rv.CRCR1Mutator]MSP[] int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.ABSMutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return this . invert () . pow ( - power ) ; MST[rv.ROR3Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR3Mutator]MSP[] if ( i == 25 ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI1Mutator]MSP[] if ( pos > 0 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[NegateConditionalsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.UOI2Mutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR5Mutator]MSP[] }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[rv.CRCR4Mutator]MSP[] }
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { MST[rv.CRCR2Mutator]MSP[] t /= 2 ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.ROR3Mutator]MSP[] return ONE ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[ReturnValsMutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[InlineConstantMutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.AOR1Mutator]MSP[] }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.AOR3Mutator]MSP[]
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; MST[rv.ABSMutator]MSP[] numerator /= gcd ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.ROR5Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
} @Override public int hashCode () { MST[rv.AOR3Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return this ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[NonVoidMethodCallMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI4Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI1Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[NegateConditionalsMutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI3Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.UOI3Mutator]MSP[] k ++ ; } if ( k == 31 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOD2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.UOI1Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI3Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[NonVoidMethodCallMutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI3Mutator]MSP[] int denom0 = 1 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[NonVoidMethodCallMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI1Mutator]MSP[] x1 = x2 ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.AOR2Mutator]MSP[] return - u * ( 1 << k ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.UOI4Mutator]MSP[] }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI3Mutator]MSP[]
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI3Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.UOI2Mutator]MSP[] }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI4Mutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR1Mutator]MSP[] } if ( denominator < 0 ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI2Mutator]MSP[] }
} @Override public int hashCode () { MST[MathMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; MST[rv.CRCR5Mutator]MSP[] double y1 = value - a1 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.ABSMutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
numer2 = a1 * numer1 + numer0 ; MST[rv.AOD1Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[NegateConditionalsMutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI3Mutator]MSP[] if ( i == 25 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI2Mutator]MSP[]
y1 = y2 ; MST[rv.ABSMutator]MSP[] numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI4Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR2Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( this == other ) { return 0 ; MST[rv.UOI2Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[rv.UOI1Mutator]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.ABSMutator]MSP[]
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; MST[rv.CRCR5Mutator]MSP[] int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } MST[rv.UOI4Mutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[NegateConditionalsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.AOD1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
} @Override public int hashCode () { MST[rv.AOR1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
return this . invert () . pow ( - power ) ; MST[rv.AOD2Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.OBBN1Mutator]MSP[] if ( u == 0 || v == 0 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[InvertNegsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR3Mutator]MSP[] } if ( denominator < 0 ) {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.CRCR1Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.CRCR6Mutator]MSP[] }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.ROR3Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI2Mutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return this ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI3Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.ROR3Mutator]MSP[] }
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; MST[rv.UOI3Mutator]MSP[] numerator /= gcd ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[]
if ( this == other ) { return 0 ; MST[rv.UOI1Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return this ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.UOI1Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
throw new ArithmeticException ( lr_2 ) ; MST[rv.ABSMutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR5Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[NonVoidMethodCallMutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI4Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI3Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[ReturnValsMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ABSMutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR1Mutator]MSP[] } if ( denominator < 0 ) {
throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR3Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI2Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR6Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI1Mutator]MSP[]
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI1Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOD1Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI4Mutator]MSP[] return - u * ( 1 << k ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] public boolean equals ( final Object obj ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[ConditionalsBoundaryMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI4Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.UOI3Mutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR5Mutator]MSP[] } if ( denominator < 0 ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI2Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ; MST[rv.UOI4Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[ConstructorCallMutator]MSP[]
if ( numerator == 0 ) { MST[InlineConstantMutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[NegateConditionalsMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[InlineConstantMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.ROR2Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.CRCR1Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
private static int mulAndCheck ( final int x , final int y ) { MST[ConditionalsBoundaryMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.UOI4Mutator]MSP[] return f . pow ( power / 2 ) ; }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI4Mutator]MSP[]
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI1Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[NegateConditionalsMutator]MSP[] if ( i == 25 ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ; MST[rv.CRCR3Mutator]MSP[]
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[NonVoidMethodCallMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.AOR3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[rv.ROR1Mutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOD2Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[InlineConstantMutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
final long second = ( long ) other . numerator * ( long ) denominator ; if ( first == second ) { return 0 ; } else if ( first < second ) { return - 1 ; } else { return 1 ; } } @Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOD1Mutator]MSP[]
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[rv.UOI2Mutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[InvertNegsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( this == other ) { MST[MathMutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI3Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[experimental.MemberVariableMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.ABSMutator]MSP[]
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI3Mutator]MSP[]
throw new NumberFormatException ( lr_9 ) ; MST[rv.AOR2Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
} int k = 0 ; MST[MathMutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI4Mutator]MSP[] if ( i == 25 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI2Mutator]MSP[] if ( i == 25 ) {
} int k = 0 ; MST[rv.AOR4Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
final int properNumerator = getProperNumerator () ; MST[NonVoidMethodCallMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
} @Override public int hashCode () { MST[rv.CRCR5Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { MST[rv.CRCR5Mutator]MSP[] delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI3Mutator]MSP[]
throw new NumberFormatException ( lr_9 ) ; MST[rv.UOI1Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.AOD1Mutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( numerator == 0 ) { MST[rv.CRCR4Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[rv.UOI4Mutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
int pos = str . indexOf ( '.' ) ; MST[ReturnValsMutator]MSP[] if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[rv.CRCR6Mutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[InlineConstantMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[ArgumentPropagationMutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[NegateConditionalsMutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.ABSMutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; MST[rv.CRCR6Mutator]MSP[] double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI4Mutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR4Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[ReturnValsMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR3Mutator]MSP[] if ( i == 25 ) {
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI3Mutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI4Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( numerator == 0 ) { MST[rv.ROR1Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR4Mutator]MSP[]
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.ROR4Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR1Mutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOD2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR3Mutator]MSP[] }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[experimental.NakedReceiverMutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI4Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( this == other ) { return 0 ; MST[rv.ABSMutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; MST[rv.CRCR3Mutator]MSP[] int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.ABSMutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.CRCR2Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI4Mutator]MSP[] a1 = a2 ; x1 = x2 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[MathMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[NegateConditionalsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI3Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
double y2 = 0 ; MST[rv.CRCR6Mutator]MSP[] double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI1Mutator]MSP[] if ( pos > 0 ) {
return this . invert () . pow ( - power ) ; MST[rv.AOR3Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR4Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; MST[rv.CRCR6Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR1Mutator]MSP[]
return this . invert () . pow ( - power ) ; } else { MST[rv.AOR4Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.UOI2Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ABSMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return this . invert () . pow ( - power ) ; MST[rv.UOI3Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; MST[rv.UOI1Mutator]MSP[] numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; MST[rv.UOI3Mutator]MSP[] } if ( v > 0 ) { v = - v ;
if ( this == other ) { MST[rv.UOI2Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
return this . invert () . pow ( - power ) ; } else { MST[rv.CRCR1Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR5Mutator]MSP[] if ( i == 25 ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[] public boolean equals ( final Object obj ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[NonVoidMethodCallMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI4Mutator]MSP[] public double doubleValue () {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.CRCR6Mutator]MSP[] return - u * ( 1 << k ) ; }
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final long s = ( long ) x + ( long ) y ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ABSMutator]MSP[] if ( i == 25 ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[NegateConditionalsMutator]MSP[] k ++ ; } if ( k == 31 ) {
if ( numerator == 0 ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR3Mutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[ConstructorCallMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NullReturnValsMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
denominator /= gcd ; MST[rv.UOI4Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR6Mutator]MSP[] }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[rv.CRCR2Mutator]MSP[]
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.ROR5Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.UOI1Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
private static int mulAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_14 ) ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR2Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR4Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[NonVoidMethodCallMutator]MSP[] public boolean equals ( final Object obj ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.CRCR5Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI3Mutator]MSP[] if ( i == 25 ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR5Mutator]MSP[]
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[NullReturnValsMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ; MST[rv.ABSMutator]MSP[]
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[rv.UOI2Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; MST[rv.UOI3Mutator]MSP[] x2 = y1 ; y2 = x1 - a2 * y1 ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.CRCR4Mutator]MSP[] k ++ ; } if ( k == 31 ) {
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI1Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { MST[rv.UOI1Mutator]MSP[] t /= 2 ; }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[NonVoidMethodCallMutator]MSP[] }
} @Override public int hashCode () { MST[rv.AOR4Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( fraction == null ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.AOR1Mutator]MSP[] y2 = x1 - a2 * y1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[InlineConstantMutator]MSP[] if ( u == 0 || v == 0 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.AOD2Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.AOD1Mutator]MSP[] a1 = a2 ; x1 = x2 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; MST[rv.ABSMutator]MSP[] } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.AOR2Mutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR4Mutator]MSP[] } if ( denominator < 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( u == 0 || v == 0 ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( pos > 0 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR1Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.AOR2Mutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR4Mutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; MST[rv.CRCR2Mutator]MSP[] int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR4Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI1Mutator]MSP[] }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[rv.ABSMutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[ReturnValsMutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new NumberFormatException ( lr_9 ) ; MST[InlineConstantMutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[NullReturnValsMutator]MSP[] return f . pow ( power / 2 ) ; }
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { MST[NonVoidMethodCallMutator]MSP[] toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI3Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ABSMutator]MSP[] if ( pos > 0 ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { MST[InlineConstantMutator]MSP[] delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
return this . invert () . pow ( - power ) ; } else { MST[rv.UOI4Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[experimental.NakedReceiverMutator]MSP[]
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.AOR2Mutator]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.UOI4Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.AOR4Mutator]MSP[] return f . pow ( power / 2 ) ; }
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[NegateConditionalsMutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
return numerator / denominator ; } @Override public long longValue () { MST[rv.UOI1Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI4Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
y1 = y2 ; numer0 = numer1 ; MST[rv.UOI4Mutator]MSP[] denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.ABSMutator]MSP[] return ONE ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI2Mutator]MSP[] int denom0 = 1 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[rv.UOI2Mutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI4Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[ConstructorCallMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.ABSMutator]MSP[] public double doubleValue () {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.AOD2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.UOI1Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOD2Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
private static int mulAndCheck ( final int x , final int y ) { MST[InlineConstantMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.ROR2Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ; MST[rv.UOI1Mutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[InlineConstantMutator]MSP[] if ( pos > 0 ) {
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.AOR4Mutator]MSP[] }
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.CRCR1Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[NonVoidMethodCallMutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR5Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( this == other ) { return 0 ; MST[rv.ROR1Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } if ( denominator < 0 ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { return ZERO ; MST[ArgumentPropagationMutator]MSP[] } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[NegateConditionalsMutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR6Mutator]MSP[] if ( i == 25 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI4Mutator]MSP[] if ( i == 25 ) {
throw new NumberFormatException ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
} @Override public int hashCode () { MST[InlineConstantMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI2Mutator]MSP[] if ( i == 25 ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; MST[rv.CRCR1Mutator]MSP[] do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR2Mutator]MSP[] if ( i == 25 ) {
if ( fraction == null ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI4Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI4Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR3Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] }
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI4Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI2Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[NegateConditionalsMutator]MSP[] if ( u == 0 || v == 0 ) {
return this . invert () . pow ( - power ) ; MST[rv.CRCR6Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[experimental.NakedReceiverMutator]MSP[] }
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI4Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.ABSMutator]MSP[]
if ( numerator == 0 ) { MST[ConstructorCallMutator]MSP[] return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; MST[ConstructorCallMutator]MSP[] value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.CRCR2Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[ReturnValsMutator]MSP[]
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.AOR1Mutator]MSP[]
if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { throw new ArithmeticException ( lr_3 ) ; } if ( numerator < 0 ) { throw new ArithmeticException ( lr_4 ) ; } long numeratorValue ; MST[ConstructorCallMutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.AOR2Mutator]MSP[] if ( pos > 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOR3Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[NonVoidMethodCallMutator]MSP[] }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR3Mutator]MSP[]
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; MST[rv.CRCR6Mutator]MSP[] int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( this == other ) { MST[rv.ABSMutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ABSMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
} int k = 0 ; MST[rv.CRCR6Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.UOI3Mutator]MSP[] }
} @Override public int hashCode () { MST[MathMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[InlineConstantMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; MST[rv.CRCR6Mutator]MSP[] double y1 = value - a1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI1Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.CRCR3Mutator]MSP[] }
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.UOI2Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; MST[rv.UOI1Mutator]MSP[] numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[MathMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR3Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR4Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[ConditionalsBoundaryMutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[InlineConstantMutator]MSP[] public boolean equals ( final Object obj ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOD1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.AOR3Mutator]MSP[] int denom0 = 1 ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[InlineConstantMutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[ArgumentPropagationMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; MST[rv.ABSMutator]MSP[] i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.UOI4Mutator]MSP[] k ++ ; } if ( k == 31 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI2Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR1Mutator]MSP[] if ( i == 25 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI3Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR4Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI1Mutator]MSP[]
throw new NumberFormatException ( lr_9 ) ; MST[rv.ABSMutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.ROR2Mutator]MSP[] return ONE ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI3Mutator]MSP[] int denom0 = 1 ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[InvertNegsMutator]MSP[] return - u * ( 1 << k ) ; }
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR6Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR5Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR3Mutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR5Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR2Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( u == 0 || v == 0 ) {
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[InlineConstantMutator]MSP[] }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.UOI3Mutator]MSP[] }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[NegateConditionalsMutator]MSP[] } if ( denominator < 0 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[MathMutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ABSMutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[ConditionalsBoundaryMutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[NegateConditionalsMutator]MSP[]
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR6Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.AOR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI3Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( i == 25 ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
} @Override public int hashCode () { MST[rv.AOR2Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.CRCR6Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.UOI2Mutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI2Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[InlineConstantMutator]MSP[]
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ; MST[InlineConstantMutator]MSP[]
if ( fraction == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[MathMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; MST[rv.CRCR5Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOR1Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[ConditionalsBoundaryMutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { MST[rv.ROR3Mutator]MSP[] throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
int numer1 = 1 ; int denom1 = 0 ; MST[rv.CRCR3Mutator]MSP[] int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; MST[InlineConstantMutator]MSP[] int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.UOI3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return this ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI4Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[NegateConditionalsMutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.ROR3Mutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.ROR5Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.ROR3Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR2Mutator]MSP[] if ( i == 25 ) {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[PrimitiveReturnsMutator]MSP[]
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.AOR2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[rv.CRCR6Mutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.CRCR4Mutator]MSP[] }
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[InvertNegsMutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR4Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.UOI2Mutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[experimental.NakedReceiverMutator]MSP[] return f . pow ( power / 2 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ; MST[rv.UOI3Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[InlineConstantMutator]MSP[] public boolean equals ( final Object obj ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.ABSMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR3Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR1Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.UOI3Mutator]MSP[] a1 = a2 ; x1 = x2 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ROR2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR4Mutator]MSP[] if ( i == 25 ) {
return numerator / denominator ; } @Override public long longValue () { MST[rv.AOR1Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.UOI3Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR2Mutator]MSP[] } if ( denominator < 0 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI1Mutator]MSP[] public double doubleValue () {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.UOI2Mutator]MSP[] k ++ ; } if ( k == 31 ) {
return this . invert () . pow ( - power ) ; } else { MST[rv.AOR3Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[rv.CRCR6Mutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI1Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; MST[ArgumentPropagationMutator]MSP[] } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ; MST[rv.UOI4Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI2Mutator]MSP[] y2 = x1 - a2 * y1 ;
} @Override public int hashCode () { MST[rv.CRCR3Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[ReturnValsMutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[ConditionalsBoundaryMutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.OBBN3Mutator]MSP[] if ( u == 0 || v == 0 ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI3Mutator]MSP[] }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.AOR4Mutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR5Mutator]MSP[] }
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.UOI1Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR2Mutator]MSP[] if ( i == 25 ) {
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[rv.ABSMutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR4Mutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR1Mutator]MSP[] if ( i == 25 ) {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR2Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR5Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.UOI2Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
} int k = 0 ; MST[rv.UOI2Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR6Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.AOR4Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[MathMutator]MSP[] y2 = x1 - a2 * y1 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI3Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI3Mutator]MSP[] public double doubleValue () {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.UOI4Mutator]MSP[] public double doubleValue () {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI1Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.CRCR2Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[NullReturnValsMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI3Mutator]MSP[]
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.CRCR5Mutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.ROR2Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.AOR1Mutator]MSP[] x1 = x2 ;
return this . invert () . pow ( - power ) ; MST[rv.CRCR4Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOD2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[ConditionalsBoundaryMutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI2Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR4Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[NegateConditionalsMutator]MSP[] return ONE ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR5Mutator]MSP[] if ( i == 25 ) {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR5Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[ReturnValsMutator]MSP[] return f . pow ( power / 2 ) ; }
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR4Mutator]MSP[] }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR1Mutator]MSP[] public boolean equals ( final Object obj ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ROR5Mutator]MSP[] } if ( denominator < 0 ) {
int numer1 = 1 ; int denom1 = 0 ; MST[rv.CRCR6Mutator]MSP[] int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ; MST[rv.CRCR3Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI2Mutator]MSP[] x1 = x2 ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.AOD1Mutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR4Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR1Mutator]MSP[] if ( i == 25 ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[MathMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.ABSMutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.CRCR5Mutator]MSP[] return - u * ( 1 << k ) ; }
int pos = str . indexOf ( '.' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.OBBN3Mutator]MSP[] if ( u == 0 || v == 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ABSMutator]MSP[] if ( i == 25 ) {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.ROR5Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR1Mutator]MSP[] if ( u == 0 || v == 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; MST[rv.UOI4Mutator]MSP[] numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
throw new NumberFormatException ( lr_9 ) ; MST[rv.CRCR2Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.ABSMutator]MSP[] y2 = x1 - a2 * y1 ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR2Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.UOI2Mutator]MSP[] }
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[InlineConstantMutator]MSP[] k ++ ; } if ( k == 31 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR4Mutator]MSP[] } if ( denominator < 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.AOD2Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI4Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR6Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI2Mutator]MSP[]
return numerator / denominator ; } @Override public long longValue () { MST[PrimitiveReturnsMutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI3Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[MathMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; MST[rv.AOR1Mutator]MSP[] } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[InlineConstantMutator]MSP[] }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[rv.ABSMutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI4Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR2Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; MST[rv.UOI1Mutator]MSP[] i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( t > 0 ) { MST[rv.UOI4Mutator]MSP[] u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI3Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR2Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[rv.ROR5Mutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
if ( numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[rv.CRCR6Mutator]MSP[] }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[MathMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI4Mutator]MSP[] return - u * ( 1 << k ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NonVoidMethodCallMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR3Mutator]MSP[] } if ( denominator < 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI2Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.AOD2Mutator]MSP[] return - u * ( 1 << k ) ; }
} @Override public int hashCode () { MST[rv.AOR4Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { MST[rv.UOI3Mutator]MSP[] return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ; MST[rv.CRCR4Mutator]MSP[]
final int properNumerator = getProperNumerator () ; if ( properNumerator == 0 ) { MST[EmptyObjectReturnValsMutator]MSP[] toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI3Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[ReturnValsMutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { MST[rv.CRCR6Mutator]MSP[] delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI2Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI1Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI1Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
private static int mulAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { MST[PrimitiveReturnsMutator]MSP[] throw new ArithmeticException ( lr_14 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR1Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.ROR1Mutator]MSP[] }
if ( this == other ) { return 0 ; MST[rv.UOI3Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator == 0 ) { MST[rv.CRCR5Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.ROR1Mutator]MSP[]
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.AOR4Mutator]MSP[] x1 = x2 ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.ROR3Mutator]MSP[] }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[ReturnValsMutator]MSP[] if ( u == 0 || v == 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR4Mutator]MSP[] public boolean equals ( final Object obj ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR2Mutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( u == 0 || v == 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.AOR1Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR2Mutator]MSP[] if ( pos > 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR3Mutator]MSP[] if ( i == 25 ) {
if ( fraction == null ) { MST[NullReturnValsMutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR5Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NonVoidMethodCallMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; MST[rv.ABSMutator]MSP[] double x2 = 0 ; double y1 = value - a1 ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR6Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.CRCR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR1Mutator]MSP[]
} @Override public int hashCode () { MST[rv.CRCR6Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; MST[InlineConstantMutator]MSP[] int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.AOR3Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOD1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI2Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( pos > 0 ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; MST[rv.CRCR3Mutator]MSP[] int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[InlineConstantMutator]MSP[] return ONE ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOD1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.ABSMutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.CRCR3Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[ConditionalsBoundaryMutator]MSP[] if ( i == 25 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[MathMutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI4Mutator]MSP[] if ( i == 25 ) {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; MST[ConstructorCallMutator]MSP[] denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.AOR3Mutator]MSP[] return f . pow ( power / 2 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return this . invert () . pow ( - power ) ; MST[NegateConditionalsMutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
y1 = y2 ; numer0 = numer1 ; MST[rv.UOI3Mutator]MSP[] denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR1Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[ConditionalsBoundaryMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.AOD1Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.ROR2Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { MST[experimental.RemoveIncrementsMutator]MSP[] u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR4Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[MathMutator]MSP[] return f . pow ( power / 2 ) ; }
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.UOI2Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[NullReturnValsMutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI2Mutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.AOR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.CRCR5Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[ArgumentPropagationMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI3Mutator]MSP[]
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { MST[rv.OBBN1Mutator]MSP[] while ( ( t & 1 ) == 0 ) { t /= 2 ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.AOD2Mutator]MSP[] x1 = x2 ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[ConditionalsBoundaryMutator]MSP[] if ( pos > 0 ) {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.UOI3Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.ABSMutator]MSP[] return - u * ( 1 << k ) ; }
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.AOD1Mutator]MSP[] public double doubleValue () {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[VoidMethodCallMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[MathMutator]MSP[] }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.AOR1Mutator]MSP[]
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( i == 25 ) {
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.ABSMutator]MSP[] }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[ArgumentPropagationMutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR1Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI3Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return this . invert () . pow ( - power ) ; MST[rv.ABSMutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI1Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI4Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[NonVoidMethodCallMutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( i == 25 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOD2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; MST[rv.CRCR2Mutator]MSP[] do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI3Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI1Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; MST[rv.ROR1Mutator]MSP[] } while ( t != 0 ); return - u * ( 1 << k ) ; }
final long s = ( long ) x - ( long ) y ; if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; }
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.ABSMutator]MSP[] x1 = x2 ;
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[rv.ROR4Mutator]MSP[]
if ( numerator == 0 ) { MST[rv.CRCR2Mutator]MSP[] throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
} @Override public int hashCode () { MST[NonVoidMethodCallMutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
return numerator / denominator ; } @Override public long longValue () { MST[ReturnValsMutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[rv.ROR4Mutator]MSP[] }
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ROR4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR4Mutator]MSP[] if ( i == 25 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.ROR5Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.OBBN1Mutator]MSP[] } if ( denominator < 0 ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[ArgumentPropagationMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI3Mutator]MSP[] if ( i == 25 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.OBBN3Mutator]MSP[] } if ( denominator < 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI2Mutator]MSP[] if ( i == 25 ) {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.CRCR6Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.AOR3Mutator]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR2Mutator]MSP[] }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.CRCR4Mutator]MSP[] }
return this . invert () . pow ( - power ) ; } else { MST[MathMutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[ArgumentPropagationMutator]MSP[] }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ABSMutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[rv.UOI4Mutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[experimental.BigIntegerMutator]MSP[] }
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ABSMutator]MSP[] final long s = ( long ) x + ( long ) y ;
} int k = 0 ; MST[rv.CRCR2Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ROR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return numerator / denominator ; } @Override public long longValue () { MST[rv.AOR4Mutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI1Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] public boolean equals ( final Object obj ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR5Mutator]MSP[]
final int properNumerator = getProperNumerator () ; MST[NonVoidMethodCallMutator]MSP[] if ( properNumerator == 0 ) { toProperString = Integer . toString ( getProperWhole () ) ; } else { toProperString = getProperWhole () + lr_24 + properNumerator + lr_20 + getDenominator () ; } } else {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI4Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR1Mutator]MSP[] public boolean equals ( final Object obj ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[rv.ROR2Mutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR4Mutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; MST[rv.UOI4Mutator]MSP[] i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[rv.AOR3Mutator]MSP[] public double doubleValue () {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; MST[rv.AOR2Mutator]MSP[] a1 = a2 ; x1 = x2 ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.AOR1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI1Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.UOI4Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[InlineConstantMutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI4Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[rv.UOI1Mutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.UOI1Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI1Mutator]MSP[] if ( i == 25 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR1Mutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR3Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI3Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.CRCR1Mutator]MSP[] return f . pow ( power / 2 ) ; }
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.AOR2Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return this ; }
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.CRCR6Mutator]MSP[] } if ( denominator < 0 ) {
denominator /= gcd ; MST[rv.UOI1Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR3Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR3Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR5Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[InlineConstantMutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) { MST[rv.AOD1Mutator]MSP[]
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[experimental.NakedReceiverMutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR5Mutator]MSP[]
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI4Mutator]MSP[] if ( pos > 0 ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.ABSMutator]MSP[] k ++ ; } if ( k == 31 ) {
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.ROR3Mutator]MSP[] k ++ ; } if ( k == 31 ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; MST[rv.CRCR6Mutator]MSP[] int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.UOI2Mutator]MSP[] y2 = x1 - a2 * y1 ;
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI4Mutator]MSP[]
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.CRCR6Mutator]MSP[] k ++ ; } if ( k == 31 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.UOI2Mutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI4Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI2Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.ABSMutator]MSP[]
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[rv.CRCR1Mutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[NullReturnValsMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[NegateConditionalsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[rv.UOI1Mutator]MSP[] }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.AOR3Mutator]MSP[] y2 = x1 - a2 * y1 ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.CRCR4Mutator]MSP[] if ( pos > 0 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[ArgumentPropagationMutator]MSP[]
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[experimental.MemberVariableMutator]MSP[]
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[NegateConditionalsMutator]MSP[] if ( i == 25 ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ROR5Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI3Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; MST[ConditionalsBoundaryMutator]MSP[] str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI4Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[MathMutator]MSP[] if ( u == 0 || v == 0 ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; MST[rv.ABSMutator]MSP[] } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.ABSMutator]MSP[] y2 = x1 - a2 * y1 ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.CRCR6Mutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[ConditionalsBoundaryMutator]MSP[] final long s = ( long ) x + ( long ) y ;
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { MST[NonVoidMethodCallMutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[InlineConstantMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ABSMutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR2Mutator]MSP[]
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[NegateConditionalsMutator]MSP[] }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ABSMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( fraction == null ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { MST[ConstructorCallMutator]MSP[] if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NegateConditionalsMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI4Mutator]MSP[] if ( i == 25 ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.ROR3Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.CRCR3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[NonVoidMethodCallMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR1Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; MST[rv.UOI3Mutator]MSP[] denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR2Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.ROR5Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new NumberFormatException ( lr_9 ) ; MST[rv.CRCR4Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.ABSMutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI2Mutator]MSP[] x1 = x2 ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR5Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI4Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[rv.ROR5Mutator]MSP[] } else if ( power == 0 ) { return ONE ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.ROR2Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[InlineConstantMutator]MSP[]
} @Override public int hashCode () { MST[rv.AOD1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( fraction == null ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.UOI4Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI1Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI1Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} int k = 0 ; MST[rv.CRCR6Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR3Mutator]MSP[] public boolean equals ( final Object obj ) {
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOR4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.CRCR6Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.ROR1Mutator]MSP[] return ONE ;
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return f . pow ( power / 2 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR5Mutator]MSP[] if ( u == 0 || v == 0 ) {
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.ABSMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
private static int mulAndCheck ( final int x , final int y ) { MST[NegateConditionalsMutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.AOR2Mutator]MSP[] int denom0 = 1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI4Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( pos > 0 ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } else if ( power == 0 ) { return ONE ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI1Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.ABSMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
return this . invert () . pow ( - power ) ; MST[rv.AOR1Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.ROR5Mutator]MSP[] if ( pos > 0 ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.ROR5Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI2Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; MST[rv.CRCR3Mutator]MSP[] int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[InlineConstantMutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI3Mutator]MSP[] } if ( denominator < 0 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR1Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
} int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; MST[rv.CRCR3Mutator]MSP[] k ++ ; } if ( k == 31 ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[rv.UOI3Mutator]MSP[]
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[ArgumentPropagationMutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI3Mutator]MSP[] if ( i == 25 ) {
return this . invert () . pow ( - power ) ; } else { MST[NullReturnValsMutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[rv.UOI1Mutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.CRCR6Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { MST[ArgumentPropagationMutator]MSP[] if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; }
return this . invert () . pow ( - power ) ; MST[rv.ROR1Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( fraction == null ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[NegateConditionalsMutator]MSP[] public boolean equals ( final Object obj ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.CRCR4Mutator]MSP[] return ONE ;
return numerator ; } public int getDenominator () { return denominator ; } public int getProperNumerator () { return Math . abs ( numerator % denominator ) ; } public int getProperWhole () { return numerator / denominator ; } @Override public int intValue () { MST[MathMutator]MSP[]
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.UOI1Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[ReturnValsMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI3Mutator]MSP[]
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.CRCR3Mutator]MSP[]
if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { MST[ConstructorCallMutator]MSP[] throw new ArithmeticException ( lr_3 ) ; } if ( numerator < 0 ) { throw new ArithmeticException ( lr_4 ) ; } long numeratorValue ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.ROR3Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.ABSMutator]MSP[] int denom0 = 1 ;
public static Fraction getFraction ( int numerator , int denominator ) { if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { MST[ConstructorCallMutator]MSP[] if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.ROR5Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( numerator == 0 || fraction . numerator == 0 ) { MST[MathMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[] throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) {
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR4Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { MST[rv.UOI4Mutator]MSP[] if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ;
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ONE ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[NonVoidMethodCallMutator]MSP[] public boolean equals ( final Object obj ) {
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[ReturnValsMutator]MSP[] public boolean equals ( final Object obj ) {
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[rv.UOI2Mutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( i == 25 ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new NumberFormatException ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.AOR1Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.ABSMutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI4Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
denominator /= gcd ; MST[rv.UOI3Mutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI1Mutator]MSP[] int denom0 = 1 ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR1Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
private static int mulAndCheck ( final int x , final int y ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
return this . invert () . pow ( - power ) ; } else { MST[rv.AOD2Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI1Mutator]MSP[] if ( i == 25 ) {
double y2 = 0 ; MST[rv.CRCR5Mutator]MSP[] double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR5Mutator]MSP[] public boolean equals ( final Object obj ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR6Mutator]MSP[]
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; MST[ConditionalsBoundaryMutator]MSP[] if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; }
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.CRCR6Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[NonVoidMethodCallMutator]MSP[] x1 = x2 ;
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[InlineConstantMutator]MSP[] } if ( denominator < 0 ) {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.UOI2Mutator]MSP[] } if ( denominator < 0 ) {
} @Override public int hashCode () { if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) { MST[rv.ABSMutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return this . invert () . pow ( - power ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[] public boolean equals ( final Object obj ) {
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR5Mutator]MSP[]
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.ABSMutator]MSP[] x1 = x2 ;
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.AOR2Mutator]MSP[]
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.UOI4Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
return this . invert () . pow ( - power ) ; } else { MST[rv.CRCR6Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
return getFraction ( whole , numer , denom ) ; } pos = str . indexOf ( '/' ) ; if ( pos < 0 ) { return getFraction ( Integer . parseInt ( str ) , 1 ) ; MST[NonVoidMethodCallMutator]MSP[] }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; MST[rv.CRCR5Mutator]MSP[] double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR4Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
numer2 = a1 * numer1 + numer0 ; MST[rv.AOR2Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.ROR5Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
} @Override public int hashCode () { MST[rv.CRCR6Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR2Mutator]MSP[]
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.UOI4Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[experimental.NakedReceiverMutator]MSP[]
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI4Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.AOR4Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.AOD1Mutator]MSP[]
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { MST[NullReturnValsMutator]MSP[] numerator /= 2 ; denominator /= 2 ; } if ( denominator < 0 ) {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.CRCR2Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; MST[rv.UOI1Mutator]MSP[] numerator /= gcd ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; MST[rv.UOI3Mutator]MSP[] x1 = x2 ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () { MST[ConstructorCallMutator]MSP[]
throw new ArithmeticException ( lr_2 ) ; MST[NegateConditionalsMutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.CRCR5Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { MST[NullReturnValsMutator]MSP[] if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; }
} int k = 0 ; MST[rv.UOI1Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI3Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI1Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[ArgumentPropagationMutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI4Mutator]MSP[] if ( i == 25 ) {
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[ConstructorCallMutator]MSP[]
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI3Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; } if ( numerator == 0 ) { return isAdd ? fraction : fraction . negate () ; } if ( fraction . numerator == 0 ) { return this ; MST[rv.ABSMutator]MSP[] }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[rv.CRCR1Mutator]MSP[] }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.CRCR4Mutator]MSP[] }
final BigInteger t = isAdd ? uvp . add ( upv ) : uvp . subtract ( upv ) ; final int tmodd1 = t . mod ( BigInteger . valueOf ( d1 ) ) . intValue () ; MST[experimental.BigIntegerMutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { MST[rv.ROR4Mutator]MSP[] return ONE ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; MST[rv.UOI4Mutator]MSP[] final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ;
private static int mulAndCheck ( final int x , final int y ) { MST[rv.ROR2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
if ( this == other ) { MST[rv.AOR2Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.ABSMutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.UOI2Mutator]MSP[] }
private static int mulAndCheck ( final int x , final int y ) { MST[rv.CRCR6Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_14 ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ABSMutator]MSP[]
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[NegateConditionalsMutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR2Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI4Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
return this . invert () . pow ( - power ) ; MST[InlineConstantMutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI4Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
return numerator / denominator ; } @Override public long longValue () { return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override MST[MathMutator]MSP[] public double doubleValue () {
if ( numerator == 0 ) { return ZERO ; } if ( denominator == Integer . MIN_VALUE && ( numerator & 1 ) == 0 ) { numerator /= 2 ; denominator /= 2 ; MST[rv.ABSMutator]MSP[] } if ( denominator < 0 ) {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.ROR5Mutator]MSP[]
y1 = y2 ; MST[rv.UOI2Mutator]MSP[] numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.AOR3Mutator]MSP[] return - u * ( 1 << k ) ; }
if ( this == other ) { MST[rv.AOD1Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI1Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
public static Fraction getFraction ( int numerator , int denominator ) { MST[rv.ABSMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.AOR4Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; } if ( numerator < 0 ) { MST[rv.UOI1Mutator]MSP[] return new Fraction ( - denominator , - numerator ) ;
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI1Mutator]MSP[]
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.ROR3Mutator]MSP[] if ( u == 0 || v == 0 ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; MST[experimental.RemoveIncrementsMutator]MSP[] } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); if ( i == 25 ) {
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.ROR3Mutator]MSP[]
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[NegateConditionalsMutator]MSP[] public boolean equals ( final Object obj ) {
private static int mulAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_14 ) ;
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; MST[rv.UOI4Mutator]MSP[] delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { return equals ( ZERO ) ? this : ZERO ; MST[NegateConditionalsMutator]MSP[] }
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { MST[rv.UOI1Mutator]MSP[] return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.ABSMutator]MSP[] }
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; MST[rv.UOI3Mutator]MSP[] } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[NegateConditionalsMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { MST[ConditionalsBoundaryMutator]MSP[] numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[ArgumentPropagationMutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.AOR4Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.UOI1Mutator]MSP[]
} int k = 0 ; MST[rv.AOD1Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
throw new ArithmeticException ( lr_2 ) ; MST[rv.ROR1Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
return ( double ) numerator / ( double ) denominator ; } public Fraction reduce () { if ( numerator == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return equals ( ZERO ) ? this : ZERO ; }
if ( this == other ) { return 0 ; MST[rv.UOI3Mutator]MSP[] } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
if ( this == other ) { MST[rv.UOI1Mutator]MSP[] return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; } final long first = ( long ) numerator * ( long ) other . denominator ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () { MST[NullReturnValsMutator]MSP[]
} else if ( numerator == denominator ) { toProperString = lr_22 ; } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) { MST[NonVoidMethodCallMutator]MSP[]
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.UOI3Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.UOI3Mutator]MSP[] if ( u == 0 || v == 0 ) {
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.ABSMutator]MSP[] return f . pow ( power / 2 ) ; }
return this . invert () . pow ( - power ) ; MST[rv.ROR4Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.ROR5Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI3Mutator]MSP[]
} int k = 0 ; MST[rv.UOI4Mutator]MSP[] while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) {
final int whole = Integer . parseInt ( str . substring ( 0 , pos ) ) ; str = str . substring ( pos + 1 ) ; MST[ConstructorCallMutator]MSP[] pos = str . indexOf ( '/' ) ; if ( pos < 0 ) {
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.ROR2Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.UOI1Mutator]MSP[]
if ( this == other ) { return 0 ; } if ( numerator == other . numerator && denominator == other . denominator ) { return 0 ; MST[rv.CRCR4Mutator]MSP[] } final long first = ( long ) numerator * ( long ) other . denominator ;
return numerator / denominator ; } @Override public long longValue () { MST[rv.ABSMutator]MSP[] return ( long ) numerator / denominator ; } @Override public float floatValue () { return ( float ) numerator / ( float ) denominator ; } @Override public double doubleValue () {
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; MST[rv.UOI3Mutator]MSP[] } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) {
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { MST[rv.CRCR3Mutator]MSP[] delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
} @Override public int hashCode () { MST[rv.CRCR3Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_13 ) ; } int t = ( u & 1 ) == 1 ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; MST[rv.ROR1Mutator]MSP[] }
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.UOI4Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[experimental.NakedReceiverMutator]MSP[] return f . pow ( power / 2 ) ; }
if ( Math . abs ( u ) == 1 || Math . abs ( v ) == 1 ) { return 1 ; } if ( u > 0 ) { MST[rv.UOI2Mutator]MSP[] u = - u ; } if ( v > 0 ) { v = - v ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.AOD1Mutator]MSP[] int denom0 = 1 ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[InlineConstantMutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; int denom2 = 0 ; int a1 = ( int ) value ; MST[rv.CRCR1Mutator]MSP[] int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
} return ( int ) m ; } private static int mulPosAndCheck ( final int x , final int y ) { MST[rv.CRCR2Mutator]MSP[] final long m = ( long ) x * ( long ) y ; if ( m > Integer . MAX_VALUE ) {
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; MST[rv.UOI4Mutator]MSP[] numerator /= gcd ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI2Mutator]MSP[] int denom0 = 1 ;
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; MST[InlineConstantMutator]MSP[] }
throw new NumberFormatException ( lr_9 ) ; MST[rv.UOI3Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.OBBN2Mutator]MSP[] if ( u == 0 || v == 0 ) {
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } while ( t != 0 ); return - u * ( 1 << k ) ; }
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; if ( pos > 0 ) { MST[rv.CRCR1Mutator]MSP[]
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { MST[rv.UOI1Mutator]MSP[] throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; int denom0 = 1 ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.ROR5Mutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ABSMutator]MSP[] }
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.ROR5Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
denominator /= gcd ; MST[NonVoidMethodCallMutator]MSP[] return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.ROR3Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.AOD2Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[NegateConditionalsMutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[ReturnValsMutator]MSP[]
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[MathMutator]MSP[] return - u * ( 1 << k ) ; }
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.CRCR6Mutator]MSP[] public boolean equals ( final Object obj ) {
private static int mulAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { MST[ReturnValsMutator]MSP[] throw new ArithmeticException ( lr_14 ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[InvertNegsMutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
} return new Fraction ( denominator , numerator ) ; } public Fraction negate () { if ( numerator == Integer . MIN_VALUE ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_12 ) ; } return new Fraction ( - numerator , denominator ) ; } public Fraction abs () {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI4Mutator]MSP[]
denominator /= gcd ; return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( double value ) { MST[rv.UOI3Mutator]MSP[] final int sign = value < 0 ? - 1 : 1 ; value = Math . abs ( value ) ;
if ( numerator == 0 ) { throw new ArithmeticException ( lr_10 ) ; } if ( numerator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_11 ) ; MST[NullReturnValsMutator]MSP[] } if ( numerator < 0 ) { return new Fraction ( - denominator , - numerator ) ;
throw new NumberFormatException ( lr_9 ) ; MST[rv.AOR4Mutator]MSP[] } final int numer = Integer . parseInt ( str . substring ( 0 , pos ) ) ; final int denom = Integer . parseInt ( str . substring ( pos + 1 ) ) ;
private static int mulAndCheck ( final int x , final int y ) { final long m = ( long ) x * ( long ) y ; if ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { MST[rv.UOI4Mutator]MSP[] throw new ArithmeticException ( lr_14 ) ;
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.AOR3Mutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOD2Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; MST[rv.AOD1Mutator]MSP[] } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) {
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[rv.UOI1Mutator]MSP[] if ( i == 25 ) {
public static Fraction getFraction ( int numerator , int denominator ) { MST[InlineConstantMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; } if ( denominator < 0 ) { if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) {
throw new ArithmeticException ( lr_7 ) ; } return getReducedFraction ( ( numer0 + wholeNumber * denom0 ) * sign , denom0 ) ; } public static Fraction getFraction ( String str ) { MST[rv.CRCR6Mutator]MSP[] if ( str == null ) { throw new IllegalArgumentException ( lr_8 ) ; }
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.UOI1Mutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; MST[rv.UOI4Mutator]MSP[] denom2 = a1 * denom1 + denom0 ; fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.AOD1Mutator]MSP[]
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[InlineConstantMutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return new Fraction ( isAdd ? addAndCheck ( uvp , upv ) : subAndCheck ( uvp , upv ) , mulPosAndCheck ( denominator , fraction . denominator ) ) ; MST[rv.AOD2Mutator]MSP[] }
numer2 = a1 * numer1 + numer0 ; denom2 = a1 * denom1 + denom0 ; MST[rv.AOR2Mutator]MSP[] fraction = ( double ) numer2 / ( double ) denom2 ; delta2 = Math . abs ( value - fraction ) ; a1 = a2 ; x1 = x2 ;
throw new IllegalArgumentException ( lr_17 ) ; } if ( fraction . numerator == 0 ) { throw new ArithmeticException ( lr_19 ) ; } return multiplyBy ( fraction . invert () ) ; } @Override MST[rv.ROR1Mutator]MSP[] public boolean equals ( final Object obj ) {
final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ; final BigInteger w = t . divide ( BigInteger . valueOf ( d2 ) ) ; MST[rv.ABSMutator]MSP[] if ( w . bitLength () > 31 ) { throw new ArithmeticException ( lr_18 ) ;
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI2Mutator]MSP[] return - u * ( 1 << k ) ; }
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[rv.UOI2Mutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
} return new Fraction ( w . intValue () , mulPosAndCheck ( denominator / d1 , fraction . denominator / d2 ) ) ; } public Fraction multiplyBy ( final Fraction fraction ) { if ( fraction == null ) { throw new IllegalArgumentException ( lr_17 ) ; MST[rv.UOI2Mutator]MSP[] }
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; MST[rv.AOD2Mutator]MSP[] y2 = x1 - a2 * y1 ;
if ( value > Integer . MAX_VALUE || Double . isNaN ( value ) ) { throw new ArithmeticException ( lr_6 ) ; } final int wholeNumber = ( int ) value ; value -= wholeNumber ; int numer0 = 0 ; MST[rv.UOI4Mutator]MSP[] int denom0 = 1 ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
if ( whole < 0 ) { numeratorValue = whole * ( long ) denominator - numerator ; } else { numeratorValue = whole * ( long ) denominator + numerator ; } if ( numeratorValue < Integer . MIN_VALUE || numeratorValue > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[]
if ( numerator >= 0 ) { return this ; } return negate () ; } public Fraction pow ( final int power ) { if ( power == 1 ) { return this ; } else if ( power == 0 ) { return ONE ; MST[rv.UOI3Mutator]MSP[]
public Fraction add ( final Fraction fraction ) { return addSub ( fraction , true ) ; } public Fraction subtract ( final Fraction fraction ) { return addSub ( fraction , false ) ; } private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { MST[rv.UOI4Mutator]MSP[]
double y2 = 0 ; double delta1 , delta2 = Double . MAX_VALUE ; MST[rv.UOI3Mutator]MSP[] double fraction ; int i = 1 ; do { delta1 = delta2 ; a2 = (int) ( x1 / y1 ) ; x2 = y1 ; y2 = x1 - a2 * y1 ;
final int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd == 1 ) { MST[MathMutator]MSP[] return this ; } return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ; } public Fraction invert () {
} @Override public int hashCode () { MST[rv.AOR1Mutator]MSP[] if ( hashCode == 0 ) { hashCode = 37 * ( 37 * 17 + getNumerator () ) + getDenominator () ; } return hashCode ; } @Override public int compareTo ( final Fraction other ) {
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[ArgumentPropagationMutator]MSP[] }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[MathMutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_15 ) ; } return ( int ) m ; } private static int addAndCheck ( final int x , final int y ) { MST[rv.CRCR1Mutator]MSP[] final long s = ( long ) x + ( long ) y ;
if ( s < Integer . MIN_VALUE || s > Integer . MAX_VALUE ) { throw new ArithmeticException ( lr_16 ) ; } return ( int ) s ; } private static int subAndCheck ( final int x , final int y ) { MST[rv.UOI2Mutator]MSP[]
if ( u == Integer . MIN_VALUE || v == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_13 ) ; } return Math . abs ( u ) + Math . abs ( v ) ; MST[rv.ROR1Mutator]MSP[] }
return f . pow ( power / 2 ) . multiplyBy ( this ) ; } } private static int greatestCommonDivisor ( int u , int v ) { MST[rv.CRCR2Mutator]MSP[] if ( u == 0 || v == 0 ) {
} else if ( numerator == denominator ) { toProperString = lr_22 ; MST[rv.UOI4Mutator]MSP[] } else if ( numerator == - 1 * denominator ) { toProperString = lr_23 ; } else if ( ( numerator > 0 ? - numerator : numerator ) < - denominator ) {
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI2Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
int pos = str . indexOf ( '.' ) ; if ( pos >= 0 ) { return getFraction ( Double . parseDouble ( str ) ) ; } pos = str . indexOf ( ' ' ) ; MST[rv.UOI3Mutator]MSP[] if ( pos > 0 ) {
} else if ( power < 0 ) { if ( power == Integer . MIN_VALUE ) { MST[rv.UOI1Mutator]MSP[] return this . invert () . pow ( 2 ) . pow ( - ( power / 2 ) ) ; }
throw new ArithmeticException ( lr_2 ) ; } numerator = - numerator ; denominator = - denominator ; } return new Fraction ( numerator , denominator ) ; } public static Fraction getFraction ( final int whole , final int numerator , final int denominator ) { MST[rv.CRCR2Mutator]MSP[]
if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); MST[rv.UOI1Mutator]MSP[] return - u * ( 1 << k ) ; }
y1 = y2 ; numer0 = numer1 ; denom0 = denom1 ; numer1 = numer2 ; denom1 = denom2 ; i ++ ; } while ( delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25 ); MST[InlineConstantMutator]MSP[] if ( i == 25 ) {
int numer1 = 1 ; int denom1 = 0 ; int numer2 = 0 ; MST[rv.CRCR4Mutator]MSP[] int denom2 = 0 ; int a1 = ( int ) value ; int a2 = 0 ; double x1 = 1 ; double x2 = 0 ; double y1 = value - a1 ;
return this . invert () . pow ( - power ) ; MST[rv.CRCR1Mutator]MSP[] } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[rv.ROR2Mutator]MSP[]
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI2Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
final BigInteger uvp = BigInteger . valueOf ( numerator ) . multiply ( BigInteger . valueOf ( fraction . denominator / d1 ) ) ; final BigInteger upv = BigInteger . valueOf ( fraction . numerator ) . multiply ( BigInteger . valueOf ( denominator / d1 ) ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( numerator == Integer . MIN_VALUE || denominator == Integer . MIN_VALUE ) { throw new ArithmeticException ( lr_2 ) ; MST[rv.UOI1Mutator]MSP[] } numerator = - numerator ; denominator = - denominator ; } final int gcd = greatestCommonDivisor ( numerator , denominator ) ; numerator /= gcd ;
final int d1 = greatestCommonDivisor ( denominator , fraction . denominator ) ; MST[rv.UOI4Mutator]MSP[] if ( d1 == 1 ) { final int uvp = mulAndCheck ( numerator , fraction . denominator ) ; final int upv = mulAndCheck ( fraction . numerator , denominator ) ;
throw new ArithmeticException ( lr_5 ) ; } return new Fraction ( ( int ) numeratorValue , denominator ) ; } public static Fraction getReducedFraction ( int numerator , int denominator ) { MST[rv.UOI2Mutator]MSP[] if ( denominator == 0 ) { throw new ArithmeticException ( lr_1 ) ; }
return this . invert () . pow ( - power ) ; } else { MST[rv.UOI2Mutator]MSP[] final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { return f . pow ( power / 2 ) ; }
if ( t > 0 ) { MST[rv.UOI1Mutator]MSP[] u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ); return - u * ( 1 << k ) ; }
return this . invert () . pow ( - power ) ; } else { final Fraction f = this . multiplyBy ( this ) ; if ( power % 2 == 0 ) { MST[rv.AOD2Mutator]MSP[] return f . pow ( power / 2 ) ; }
if ( numerator == 0 || fraction . numerator == 0 ) { MST[rv.UOI3Mutator]MSP[] return ZERO ; } final int d1 = greatestCommonDivisor ( numerator , fraction . denominator ) ; final int d2 = greatestCommonDivisor ( fraction . numerator , denominator ) ;
