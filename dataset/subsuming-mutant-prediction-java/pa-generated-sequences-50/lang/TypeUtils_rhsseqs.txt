if ( type instanceof GenericArrayType ) { MST[rv.ROR5Mutator]MSP[N] return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR2Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR5Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR5Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } private static String typeVariableToString ( final TypeVariable < ? > v ) { final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final Type bound : upperBounds ) {
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[rv.CRCR5Mutator]MSP[N] return null ; }
if ( type instanceof ParameterizedType ) { MST[rv.ROR3Mutator]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( t1 instanceof WildcardType ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( t1 instanceof ParameterizedType ) { MST[rv.ROR4Mutator]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( midType instanceof Class < ? > ) {
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR5Mutator]MSP[S]
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; MST[ReturnValsMutator]MSP[N] } if ( toType instanceof GenericArrayType ) {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } return false ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[InlineConstantMutator]MSP[N] }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR5Mutator]MSP[N] final Type ... typeArguments ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } } return null ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( type instanceof Class < ? > ) { final Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray () ? clazz . getComponentType () : null ; } if ( type instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; MST[rv.CRCR3Mutator]MSP[N] } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[NonVoidMethodCallMutator]MSP[S]
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { MST[NonVoidMethodCallMutator]MSP[N] return null ; }
Validate . notNull ( var , lr_21 ) ; final StringBuilder buf = new StringBuilder () ; final GenericDeclaration d = ( ( TypeVariable < ? > ) var ) . getGenericDeclaration () ; if ( d instanceof Class < ? > ) { MST[InlineConstantMutator]MSP[N]
if ( type instanceof TypeVariable < ? > ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final Type bound : ( ( TypeVariable < ? > ) type ) . getBounds () ) { if ( isAssignable ( bound , toClass ) ) { return true ; } } return false ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[NegateConditionalsMutator]MSP[S]
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[NegateConditionalsMutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR4Mutator]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[rv.ROR1Mutator]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[rv.ROR5Mutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
parameterizedTypeArguments = new HashMap < TypeVariable < ? > , Type > ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } final Type [] args = p . getActualTypeArguments () ;
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; MST[ReturnValsMutator]MSP[N] } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[rv.ROR2Mutator]MSP[S]
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI2Mutator]MSP[N]
if ( toParameterizedType . equals ( type ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.ROR1Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[ReturnValsMutator]MSP[N] }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NegateConditionalsMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.ROR4Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[rv.ROR4Mutator]MSP[S] + type ) ; } return replacementType ; }
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR5Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static String toString ( final Type type ) { MST[rv.CRCR5Mutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; MST[rv.ROR1Mutator]MSP[S] } } return true ; } return false ; }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[rv.CRCR1Mutator]MSP[S]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NegateConditionalsMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; break; } } if ( ! subtypeFound ) { MST[rv.CRCR6Mutator]MSP[N] types . add ( type1 ) ; } }
private static boolean equals ( final WildcardType w , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[rv.ROR2Mutator]MSP[N] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.ROR1Mutator]MSP[S]
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[rv.ROR4Mutator]MSP[N]
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ABSMutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ABSMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[rv.ROR5Mutator]MSP[S] } } return false ; }
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } MST[ArgumentPropagationMutator]MSP[N] break; } while ( true ); return result ; }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
final TypeVariable < ? > typeVar = entry . getKey () ; final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) , MST[NonVoidMethodCallMutator]MSP[S]
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[rv.ROR5Mutator]MSP[S] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
useOwner = raw . getEnclosingClass () ; } else { MST[InlineConstantMutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[NullReturnValsMutator]MSP[N] if ( typeArguments == null ) {
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.UOI4Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR5Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return false ; } } for ( final Type toBound : toLowerBounds ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { return false ; } } return true ; }
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI1Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR6Mutator]MSP[S]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; } if ( toParameterizedType == null ) { return false ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; } MST[NonVoidMethodCallMutator]MSP[N]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR6Mutator]MSP[N] }
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; } } return false ; MST[ReturnValsMutator]MSP[N] }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; MST[rv.ROR1Mutator]MSP[N] } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) { MST[rv.ROR2Mutator]MSP[N]
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.UOI1Mutator]MSP[N] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
Validate . notNull ( raw , lr_13 ) ; final Type useOwner ; if ( raw . getEnclosingClass () == null ) { Validate . isTrue ( owner == null , lr_15 , raw ) ; useOwner = null ; MST[InlineConstantMutator]MSP[N] } else if ( owner == null ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR6Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return buf . toString () ; MST[rv.CRCR5Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.ROR2Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[ArgumentPropagationMutator]MSP[S] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[NegateConditionalsMutator]MSP[S] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.ROR5Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI2Mutator]MSP[N] return false ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR3Mutator]MSP[S]
midClass = ( Class < ? > ) midType ; } else { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
if ( containsTypeVariables ( arg ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
Validate . notNull ( raw , lr_13 ) ; final Type useOwner ; if ( raw . getEnclosingClass () == null ) { Validate . isTrue ( owner == null , lr_15 , raw ) ; useOwner = null ; MST[ArgumentPropagationMutator]MSP[S] } else if ( owner == null ) {
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[rv.ROR3Mutator]MSP[N] } while ( true ); return result ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR1Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.ROR2Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( type instanceof GenericArrayType ) { MST[NegateConditionalsMutator]MSP[N] return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI4Mutator]MSP[N]
throw new IllegalStateException ( lr_12 + rawType ) ; } return ( Class < ? > ) rawType ; MST[rv.ROR3Mutator]MSP[N] } public static Class < ? > getRawType ( final Type type , final Type assigningType ) { if ( type instanceof Class < ? > ) {
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[rv.CRCR6Mutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[rv.ROR2Mutator]MSP[N]
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[NegateConditionalsMutator]MSP[S] } } return false ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[NegateConditionalsMutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
useOwner = raw . getEnclosingClass () ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { MST[ReturnValsMutator]MSP[N] if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI3Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[ArgumentPropagationMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] ) MST[rv.CRCR1Mutator]MSP[N]
} if ( genericInterface != null ) { return genericInterface ; } } return cls . getGenericSuperclass () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR1Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR1Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR4Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ROR5Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , MST[rv.CRCR5Mutator]MSP[S] typeVarAssigns ) ) {
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; MST[rv.ROR2Mutator]MSP[N] } public static String toLongString ( final TypeVariable < ? > var ) {
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ; MST[NonVoidMethodCallMutator]MSP[N]
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
return cls . isArray () MST[rv.ROR2Mutator]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI1Mutator]MSP[S]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR1Mutator]MSP[N] }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; for ( final Type type1 : bounds ) { MST[ReturnValsMutator]MSP[N] boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR4Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[experimental.NakedReceiverMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof TypeVariable < ? > ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final Type bound : ( ( TypeVariable < ? > ) type ) . getBounds () ) { if ( isAssignable ( bound , toClass ) ) { return true ; } } return false ; }
for ( int i = 0 ; i < typeParams . length ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N] final Type typeArg = typeArgs [ i ] ; typeVarAssigns . put ( typeParams [ i ] , typeVarAssigns . containsKey ( typeArg ) ? typeVarAssigns
return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitUpperBounds ( final WildcardType wildcardType ) { MST[rv.CRCR1Mutator]MSP[N] Validate . notNull ( wildcardType , lr_10 ) ;
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; MST[rv.CRCR5Mutator]MSP[N] break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 + type ) ; } return replacementType ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return new GenericArrayTypeImpl ( Validate . notNull ( componentType , lr_20 ) ) ; } @SuppressWarnings ( lr_1 ) MST[BooleanTrueReturnValsMutator]MSP[N] public static boolean equals ( final Type t1 , final Type t2 ) { if ( ObjectUtils . equals ( t1 , t2 ) ) { return true ; }
return null ; } if ( cls . isPrimitive () ) { MST[NegateConditionalsMutator]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[NonVoidMethodCallMutator]MSP[N]
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[rv.ROR2Mutator]MSP[N] buf . insert ( 0 , c . getName () ) ; break; }
if ( type instanceof Class < ? > ) { final Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray () ? clazz . getComponentType () : null ; } if ( type instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[InlineConstantMutator]MSP[N] }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR5Mutator]MSP[N] final Type ... typeArguments ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR5Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
Validate . notNull ( var , lr_21 ) ; final StringBuilder buf = new StringBuilder () ; final GenericDeclaration d = ( ( TypeVariable < ? > ) var ) . getGenericDeclaration () ; if ( d instanceof Class < ? > ) { MST[ArgumentPropagationMutator]MSP[N]
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass MST[NonVoidMethodCallMutator]MSP[N] . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR3Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[rv.ROR4Mutator]MSP[N] }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR4Mutator]MSP[N] if ( assigningType == null ) { return null ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI4Mutator]MSP[S] } return null ; }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR3Mutator]MSP[S]
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR5Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR3Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( toParameterizedType . equals ( type ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.ABSMutator]MSP[N] return false ; }
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI4Mutator]MSP[N]
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[rv.ROR3Mutator]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI2Mutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI1Mutator]MSP[N]
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[NegateConditionalsMutator]MSP[S] if ( typeArguments == null ) {
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.ABSMutator]MSP[N]
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[rv.ROR3Mutator]MSP[N]
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[rv.ROR4Mutator]MSP[S] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[InlineConstantMutator]MSP[S] if ( typeArguments == null ) {
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[NonVoidMethodCallMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; MST[NonVoidMethodCallMutator]MSP[N] if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI4Mutator]MSP[S] if ( typeArguments == null ) {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[rv.ROR3Mutator]MSP[N] } else {
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; MST[rv.ROR1Mutator]MSP[S] } } return false ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR5Mutator]MSP[N] if ( t1 . length == t2 . length ) {
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI1Mutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR5Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.ABSMutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR1Mutator]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR3Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.UOI1Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
return equals ( ( WildcardType ) t1 , t2 ) ; MST[ReturnValsMutator]MSP[N] } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[ArgumentPropagationMutator]MSP[N] final Type ... typeArguments ) {
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR1Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
typeVarAssigns ) ) { return false ; } } } return true ; } private static Class < ? > getRawType ( final ParameterizedType parameterizedType ) { final Type rawType = parameterizedType . getRawType () ; if ( ! ( rawType instanceof Class < ? > ) ) { MST[NonVoidMethodCallMutator]MSP[N]
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; MST[ConstructorCallMutator]MSP[N] }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[rv.ROR5Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; }
buf . append ( c . getName () ) ; } if ( c . getTypeParameters () . length > 0 ) { MST[ConstructorCallMutator]MSP[N] buf . append ( '<' ) ; appendAllTo ( buf , lr_22 , c . getTypeParameters () ) ; buf . append ( '>' ) ; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI2Mutator]MSP[S]
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR3Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[rv.ROR3Mutator]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[NegateConditionalsMutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[NonVoidMethodCallMutator]MSP[S] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI1Mutator]MSP[N]
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR6Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( typeArguments == null ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI3Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[rv.ROR4Mutator]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[rv.ROR2Mutator]MSP[N] && ! toTypeArg . equals ( fromTypeArg )
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR3Mutator]MSP[N] }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NegateConditionalsMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[rv.ROR1Mutator]MSP[N] } else {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; MST[ReturnValsMutator]MSP[N] } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[InlineConstantMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; MST[InlineConstantMutator]MSP[N] } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) {
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI2Mutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
Validate . notNull ( var , lr_21 ) ; final StringBuilder buf = new StringBuilder () ; final GenericDeclaration d = ( ( TypeVariable < ? > ) var ) . getGenericDeclaration () ; if ( d instanceof Class < ? > ) { MST[rv.CRCR3Mutator]MSP[N]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR2Mutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; MST[InlineConstantMutator]MSP[S] } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[rv.ROR5Mutator]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
private static StringBuilder appendAllTo ( final StringBuilder buf , final String sep , final Type ... types ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notEmpty ( Validate . noNullElements ( types ) ) ; if ( types . length > 0 ) {
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR1Mutator]MSP[S] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR2Mutator]MSP[N] } }
if ( cls . equals ( superClass ) ) { MST[rv.ROR1Mutator]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.ABSMutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
&& typeVarAssigns . containsKey ( typeVar ) ) { MST[rv.UOI4Mutator]MSP[S] typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; } } }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI3Mutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NegateConditionalsMutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR3Mutator]MSP[S]
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI4Mutator]MSP[N] return false ; }
} if ( genericInterface != null ) { return genericInterface ; } } return cls . getGenericSuperclass () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return wildcardType () . withUpperBounds ( unrollBounds ( typeArguments , wild . getUpperBounds () ) ) MST[NonVoidMethodCallMutator]MSP[S] . withLowerBounds ( unrollBounds ( typeArguments , wild . getLowerBounds () ) ) . build () ; } } return type ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR2Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.ROR3Mutator]MSP[N] }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[NegateConditionalsMutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[NegateConditionalsMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[rv.CRCR3Mutator]MSP[N] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[InlineConstantMutator]MSP[N] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[rv.ROR3Mutator]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass MST[ReturnValsMutator]MSP[N] . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) {
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.ROR2Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ROR5Mutator]MSP[S] if ( typeArguments == null ) {
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[NegateConditionalsMutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 + type ) ; } return replacementType ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR1Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
if ( containsTypeVariables ( arg ) ) { MST[rv.CRCR5Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return false ; } } for ( final Type toBound : toLowerBounds ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { return false ; } } return true ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR1Mutator]MSP[N]
private static boolean equals ( final WildcardType w , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[NonVoidMethodCallMutator]MSP[S]
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.ROR4Mutator]MSP[N] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.ABSMutator]MSP[N]
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.ROR4Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[ReturnValsMutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
return types . toArray ( new Type [ types . size () ] ) ; } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { MST[ArgumentPropagationMutator]MSP[N] Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR2Mutator]MSP[N]
return buf . toString () ; MST[ConditionalsBoundaryMutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR6Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[rv.ROR4Mutator]MSP[S]
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[rv.ROR3Mutator]MSP[N] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } } return true ; } return false ; }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR3Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.ROR3Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) { MST[rv.ROR3Mutator]MSP[N]
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[NegateConditionalsMutator]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.ABSMutator]MSP[N] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return equals ( ( WildcardType ) t1 , t2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return null ; } if ( cls . isPrimitive () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
} if ( genericInterface != null ) { MST[rv.ROR3Mutator]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR3Mutator]MSP[N] return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[InlineConstantMutator]MSP[N]
Validate . notNull ( raw , lr_13 ) ; final Type useOwner ; if ( raw . getEnclosingClass () == null ) { Validate . isTrue ( owner == null , lr_15 , raw ) ; useOwner = null ; MST[rv.CRCR3Mutator]MSP[N] } else if ( owner == null ) {
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[NonVoidMethodCallMutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[NegateConditionalsMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.ROR3Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] ) MST[ReturnValsMutator]MSP[N]
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; MST[NullReturnValsMutator]MSP[N] } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
private static boolean equals ( final GenericArrayType a , final Type t ) { MST[rv.CRCR5Mutator]MSP[N] return t instanceof GenericArrayType && equals ( a . getGenericComponentType () , ( ( GenericArrayType ) t ) . getGenericComponentType () ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[InlineConstantMutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[ReturnValsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { MST[BooleanTrueReturnValsMutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[NonVoidMethodCallMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.ROR1Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI2Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR1Mutator]MSP[S]
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () : isAssignable ( value . getClass () , type , null ) ; MST[ReturnValsMutator]MSP[N] }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
typeArguments = Collections . < TypeVariable < ? > , Type > emptyMap () ; } if ( containsTypeVariables ( type ) ) { if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR5Mutator]MSP[N] return unrollVariables ( typeArguments , typeArguments . get ( type ) ) ; }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR6Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI3Mutator]MSP[N]
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.ABSMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR5Mutator]MSP[N] }
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[rv.ROR4Mutator]MSP[N] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] }
return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } private static String typeVariableToString ( final TypeVariable < ? > v ) { final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
final TypeVariable < ? > typeVar = entry . getKey () ; MST[ArgumentPropagationMutator]MSP[N] final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
if ( fromTypeVarAssigns == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR1Mutator]MSP[N]
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[ReturnValsMutator]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.UOI3Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR5Mutator]MSP[N]
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[ArgumentPropagationMutator]MSP[N] final Type ... typeArguments ) {
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI2Mutator]MSP[N]
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () MST[rv.ROR5Mutator]MSP[N] : isAssignable ( value . getClass () , type , null ) ; }
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[NegateConditionalsMutator]MSP[N]
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR5Mutator]MSP[S] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[ReturnValsMutator]MSP[S] return false ; }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
Class < ? > c = ( Class < ? > ) d ; while ( true ) { MST[NonVoidMethodCallMutator]MSP[S] if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[IncrementsMutator]MSP[N]
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; MST[NonVoidMethodCallMutator]MSP[N] } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
if ( t1 instanceof ParameterizedType ) { MST[NegateConditionalsMutator]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.CRCR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[experimental.NakedReceiverMutator]MSP[S] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI3Mutator]MSP[S] } return null ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR1Mutator]MSP[N] }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( t1 . length == t2 . length ) {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[experimental.NakedReceiverMutator]MSP[S]
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.CRCR1Mutator]MSP[S]
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[rv.ROR1Mutator]MSP[N] buf . insert ( 0 , c . getName () ) ; break; }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[rv.ROR3Mutator]MSP[S] + type ) ; } return replacementType ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[ReturnValsMutator]MSP[N] if ( t1 . length == t2 . length ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( toType instanceof GenericArrayType ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR6Mutator]MSP[N] }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR6Mutator]MSP[S] final Type ... typeArguments ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR3Mutator]MSP[N] }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[NegateConditionalsMutator]MSP[S]
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[rv.ROR5Mutator]MSP[S]
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; for ( final Type type1 : bounds ) { MST[NullReturnValsMutator]MSP[N] boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[NegateConditionalsMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.ABSMutator]MSP[N]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[BooleanFalseReturnValsMutator]MSP[S] return false ; }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR1Mutator]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
} if ( genericInterface != null ) { return genericInterface ; } } return cls . getGenericSuperclass () ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > () MST[NonVoidMethodCallMutator]MSP[N]
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI3Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR2Mutator]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI3Mutator]MSP[S] return false ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[InlineConstantMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[rv.ROR5Mutator]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
if ( toParameterizedType . equals ( type ) ) { return true ; MST[ReturnValsMutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
public static String toString ( final Type type ) { MST[rv.CRCR6Mutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[rv.CRCR2Mutator]MSP[S]
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; MST[ArgumentPropagationMutator]MSP[N] if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[ConditionalsBoundaryMutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[rv.CRCR5Mutator]MSP[S] final Class < ? > cls = ( Class < ? > ) type ;
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[rv.ROR3Mutator]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } else {
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI1Mutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.UOI2Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[rv.CRCR6Mutator]MSP[N] return null ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NegateConditionalsMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { MST[ReturnValsMutator]MSP[N] return null ; }
typeArguments = Collections . < TypeVariable < ? > , Type > emptyMap () ; } if ( containsTypeVariables ( type ) ) { if ( type instanceof TypeVariable < ? > ) { MST[NegateConditionalsMutator]MSP[N] return unrollVariables ( typeArguments , typeArguments . get ( type ) ) ; }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[NullReturnValsMutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR3Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[NonVoidMethodCallMutator]MSP[S] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[rv.ROR1Mutator]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR2Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( toClass . equals ( type ) ) { return true ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[NegateConditionalsMutator]MSP[N]
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI4Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[NegateConditionalsMutator]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
if ( toClass . equals ( cls ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.ROR1Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR4Mutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( toClass . equals ( type ) ) { return true ; }
} if ( genericInterface != null ) { return genericInterface ; } } return cls . getGenericSuperclass () ; MST[NegateConditionalsMutator]MSP[N] } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; } } return false ; MST[NonVoidMethodCallMutator]MSP[N] }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[ConditionalsBoundaryMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.ROR5Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR6Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[rv.ROR5Mutator]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( type instanceof WildcardType ) { MST[NonVoidMethodCallMutator]MSP[N] for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[rv.ROR1Mutator]MSP[N] && ! toTypeArg . equals ( fromTypeArg )
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR2Mutator]MSP[N] }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR2Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.UOI4Mutator]MSP[S] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[rv.ROR2Mutator]MSP[N] } else {
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { MST[rv.CRCR6Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[NonVoidMethodCallMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR5Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
typeArguments = Collections . < TypeVariable < ? > , Type > emptyMap () ; } if ( containsTypeVariables ( type ) ) { if ( type instanceof TypeVariable < ? > ) { return unrollVariables ( typeArguments , typeArguments . get ( type ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
: new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; } final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final TypeVariable < ? > [] typeParams = cls . getTypeParameters () ;
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[rv.CRCR5Mutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR1Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR2Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[BooleanFalseReturnValsMutator]MSP[S] return false ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[NegateConditionalsMutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[NegateConditionalsMutator]MSP[N] }
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[NegateConditionalsMutator]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.CRCR1Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR5Mutator]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[ReturnValsMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; MST[ReturnValsMutator]MSP[N] } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
if ( containsTypeVariables ( arg ) ) { MST[InlineConstantMutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR1Mutator]MSP[S] } }
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[rv.ROR2Mutator]MSP[N] } while ( true ); return result ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NegateConditionalsMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR5Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.CRCR6Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
midClass = ( Class < ? > ) midType ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[ArgumentPropagationMutator]MSP[S] return null ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR3Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI1Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[NegateConditionalsMutator]MSP[S] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
public static String toString ( final Type type ) { MST[BooleanTrueReturnValsMutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
if ( t1 instanceof ParameterizedType ) { MST[rv.ROR5Mutator]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[rv.ROR2Mutator]MSP[N] } else {
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; MST[rv.CRCR2Mutator]MSP[N] } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[rv.ROR1Mutator]MSP[N]
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[rv.CRCR6Mutator]MSP[S]
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[rv.ROR5Mutator]MSP[N]
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.CRCR1Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
return cls . isArray () MST[rv.ROR3Mutator]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI2Mutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR2Mutator]MSP[N]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[NonVoidMethodCallMutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR3Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () : isAssignable ( value . getClass () , type , null ) ; MST[InlineConstantMutator]MSP[N] }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR3Mutator]MSP[S] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[rv.ROR1Mutator]MSP[S]
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , MST[rv.CRCR4Mutator]MSP[N] typeVarAssigns ) ) {
private static boolean equals ( final GenericArrayType a , final Type t ) { MST[InlineConstantMutator]MSP[N] return t instanceof GenericArrayType && equals ( a . getGenericComponentType () , ( ( GenericArrayType ) t ) . getGenericComponentType () ) ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR1Mutator]MSP[S]
if ( fromTypeVarAssigns == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ABSMutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR3Mutator]MSP[N] if ( assigningType == null ) { return null ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.ROR4Mutator]MSP[N] }
if ( type instanceof Class < ? > ) { MST[rv.ROR1Mutator]MSP[N] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR5Mutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR4Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR6Mutator]MSP[S] final Type ... typeArguments ) {
&& typeVarAssigns . containsKey ( typeVar ) ) { MST[rv.UOI3Mutator]MSP[S] typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; } } }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR6Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
if ( type instanceof ParameterizedType ) { MST[rv.ROR4Mutator]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR3Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( fromTypeVarAssigns == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[rv.ROR5Mutator]MSP[N] if ( midType instanceof Class < ? > ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[NullReturnValsMutator]MSP[N] }
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.ABSMutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
if ( cls . equals ( superClass ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR5Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[rv.CRCR3Mutator]MSP[N]
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR5Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR2Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[ArgumentPropagationMutator]MSP[N]
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[NegateConditionalsMutator]MSP[N] if ( midType instanceof Class < ? > ) {
if ( useOwner instanceof Class < ? > ) { buf . append ( ( ( Class < ? > ) useOwner ) . getName () ) ; } else { MST[NonVoidMethodCallMutator]MSP[N] buf . append ( useOwner . toString () ) ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[rv.ROR5Mutator]MSP[N] }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass MST[NullReturnValsMutator]MSP[N] . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) {
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR2Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.ROR2Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR6Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } }
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR4Mutator]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[ArgumentPropagationMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () MST[NegateConditionalsMutator]MSP[N] : isAssignable ( value . getClass () , type , null ) ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI2Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[InlineConstantMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return buf . toString () ; MST[InlineConstantMutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[NegateConditionalsMutator]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[rv.ROR2Mutator]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.ABSMutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR5Mutator]MSP[N]
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; }
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
public static boolean containsTypeVariables ( final Type type ) { MST[NonVoidMethodCallMutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[rv.ROR4Mutator]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR3Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI2Mutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; MST[ReturnValsMutator]MSP[N] } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , MST[rv.CRCR3Mutator]MSP[N] typeVarAssigns ) ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR5Mutator]MSP[N]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR3Mutator]MSP[N] }
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
return cls . isArray () MST[rv.ROR4Mutator]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; MST[NullReturnValsMutator]MSP[N] }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NonVoidMethodCallMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[rv.ROR2Mutator]MSP[N] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
if ( type instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR4Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.ROR3Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
private static String wildcardTypeToString ( final WildcardType w ) { MST[ConditionalsBoundaryMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; MST[rv.CRCR3Mutator]MSP[N] break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[NegateConditionalsMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.ROR5Mutator]MSP[N] }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[BooleanFalseReturnValsMutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ABSMutator]MSP[N] if ( t1 . length == t2 . length ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR2Mutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[NonVoidMethodCallMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR3Mutator]MSP[S] } }
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR5Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[rv.ROR1Mutator]MSP[N]
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI1Mutator]MSP[S]
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI4Mutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
return buf . toString () ; MST[experimental.NakedReceiverMutator]MSP[N] } private static String typeVariableToString ( final TypeVariable < ? > v ) { final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.CRCR3Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR4Mutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[NegateConditionalsMutator]MSP[S] } } }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[ReturnValsMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[rv.ROR5Mutator]MSP[N] } while ( true ); return result ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[ArgumentPropagationMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[BooleanFalseReturnValsMutator]MSP[S] final Class < ? > cls = ( Class < ? > ) type ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[rv.ROR3Mutator]MSP[N] }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[NonVoidMethodCallMutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.ABSMutator]MSP[S] } return null ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR3Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
final TypeVariable < ? > typeVar = entry . getKey () ; final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[rv.ROR2Mutator]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitUpperBounds ( final WildcardType wildcardType ) { MST[NonVoidMethodCallMutator]MSP[S] Validate . notNull ( wildcardType , lr_10 ) ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } if ( toParameterizedType == null ) { return false ; }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.ABSMutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.CRCR6Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR5Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[NonVoidMethodCallMutator]MSP[S] toComponentType , typeVarAssigns ) ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } return false ; }
if ( containsTypeVariables ( arg ) ) { MST[rv.CRCR6Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[rv.ROR3Mutator]MSP[S] } } return false ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI3Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[NegateConditionalsMutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
throw new IllegalStateException ( lr_12 + rawType ) ; } return ( Class < ? > ) rawType ; MST[NegateConditionalsMutator]MSP[N] } public static Class < ? > getRawType ( final Type type , final Type assigningType ) { if ( type instanceof Class < ? > ) {
return null ; } if ( cls . isPrimitive () ) { MST[rv.ROR4Mutator]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] buf . insert ( 0 , c . getName () ) ; break; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI4Mutator]MSP[S]
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI3Mutator]MSP[N]
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR3Mutator]MSP[S]
buf . append ( toString ( types [ 0 ] ) ) ; for ( int i = 1 ; i < types . length ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[S] buf . append ( sep ) . append ( toString ( types [ i ] ) ) ; } }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR6Mutator]MSP[N] final Type ... typeArguments ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR5Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
} if ( genericInterface != null ) { MST[rv.ROR2Mutator]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; MST[NegateConditionalsMutator]MSP[S] if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ;
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { MST[NonVoidMethodCallMutator]MSP[N] final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null && ! toTypeArg . equals ( fromTypeArg )
private static boolean equals ( final WildcardType w , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return isAssignable ( type , ( Class < ? > ) toType ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.ABSMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[ArgumentPropagationMutator]MSP[N]
if ( useOwner instanceof Class < ? > ) { buf . append ( ( ( Class < ? > ) useOwner ) . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buf . append ( useOwner . toString () ) ; }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.ABSMutator]MSP[N]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR4Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[NegateConditionalsMutator]MSP[N]
return buf . toString () ; MST[rv.UOI1Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[rv.CRCR6Mutator]MSP[N]
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { MST[NullReturnValsMutator]MSP[N] return null ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ABSMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } return true ; } return false ; }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI1Mutator]MSP[S] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.UOI2Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[NegateConditionalsMutator]MSP[N] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( toParameterizedType . equals ( type ) ) { return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR2Mutator]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI4Mutator]MSP[N]
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR2Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[InlineConstantMutator]MSP[N]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR1Mutator]MSP[N] }
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[InlineConstantMutator]MSP[N] return null ; }
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR3Mutator]MSP[S] final Type ... typeArguments ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR5Mutator]MSP[N] }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI4Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean containsTypeVariables ( final Type type ) { MST[InlineConstantMutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR1Mutator]MSP[N] for ( final Type bound : ( ( TypeVariable < ? > ) type ) . getBounds () ) { if ( isAssignable ( bound , toClass ) ) { return true ; } } return false ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI2Mutator]MSP[S] } return null ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR1Mutator]MSP[N]
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( type instanceof GenericArrayType ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR3Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
if ( type instanceof GenericArrayType ) { MST[rv.ROR3Mutator]MSP[N] return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
return types . toArray ( new Type [ types . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
return null ; } if ( cls . isPrimitive () ) { MST[rv.ROR1Mutator]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[rv.ROR4Mutator]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.CRCR6Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
useOwner = raw . getEnclosingClass () ; } else { MST[NegateConditionalsMutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
private static StringBuilder appendAllTo ( final StringBuilder buf , final String sep , final Type ... types ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notEmpty ( Validate . noNullElements ( types ) ) ; if ( types . length > 0 ) {
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR1Mutator]MSP[N]
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[rv.CRCR1Mutator]MSP[N] return null ; }
if ( type instanceof ParameterizedType ) { MST[rv.ROR5Mutator]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR2Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[rv.ROR3Mutator]MSP[N] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[InlineConstantMutator]MSP[N]
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[rv.ROR5Mutator]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.ABSMutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ABSMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; break; } } if ( ! subtypeFound ) { MST[rv.CRCR5Mutator]MSP[N] types . add ( type1 ) ; } }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[rv.ROR5Mutator]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[rv.ROR1Mutator]MSP[N]
return false ; } } for ( final Type toBound : toLowerBounds ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { return false ; } } return true ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI1Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[rv.ROR2Mutator]MSP[N]
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR6Mutator]MSP[S]
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR1Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; } } return false ; MST[NonVoidMethodCallMutator]MSP[N] }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR2Mutator]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR2Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR1Mutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[experimental.NakedReceiverMutator]MSP[S]
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR4Mutator]MSP[S] } } return null ; }
buf . append ( '.' ) . append ( raw . getSimpleName () ) ; MST[NonVoidMethodCallMutator]MSP[N] } appendAllTo ( buf . append ( '<' ) , lr_22 , typeArguments ) . append ( '>' ) ; return buf . toString () ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { MST[rv.CRCR5Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) {
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] && ! toTypeArg . equals ( fromTypeArg )
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR5Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI4Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( toParameterizedType . equals ( type ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
public static boolean containsTypeVariables ( final Type type ) { MST[NonVoidMethodCallMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI1Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR5Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[rv.ROR1Mutator]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( toClass . equals ( type ) ) { return true ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI1Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; MST[NonVoidMethodCallMutator]MSP[S] if ( typeVarList . contains ( typeArg )
if ( type instanceof WildcardType ) { MST[BooleanTrueReturnValsMutator]MSP[N] for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[ArgumentPropagationMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[InlineConstantMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[rv.ROR3Mutator]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
} if ( genericInterface != null ) { MST[rv.ROR5Mutator]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
Validate . notNull ( raw , lr_13 ) ; final Type useOwner ; if ( raw . getEnclosingClass () == null ) { Validate . isTrue ( owner == null , lr_15 , raw ) ; useOwner = null ; MST[rv.CRCR5Mutator]MSP[N] } else if ( owner == null ) {
return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitUpperBounds ( final WildcardType wildcardType ) { MST[rv.CRCR6Mutator]MSP[N] Validate . notNull ( wildcardType , lr_10 ) ;
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR1Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[rv.ROR2Mutator]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
private static String wildcardTypeToString ( final WildcardType w ) { MST[VoidMethodCallMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[BooleanTrueReturnValsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR6Mutator]MSP[N] }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
public static < T > Typed < T > wrap ( final Class < T > type ) { return TypeUtils . <T > wrap ( ( Type ) type ) ; } private static String classToString ( final Class < ? > c ) { MST[NullReturnValsMutator]MSP[N]
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[BooleanFalseReturnValsMutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[rv.ROR3Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; }
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( midType instanceof Class < ? > ) {
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , MST[ArgumentPropagationMutator]MSP[N] toClass , typeVarAssigns ) ;
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[NonVoidMethodCallMutator]MSP[N] return null ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[NonVoidMethodCallMutator]MSP[S] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI3Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[rv.ROR5Mutator]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI2Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI4Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( toType instanceof TypeVariable < ? > ) {
return wildcardType () . withUpperBounds ( unrollBounds ( typeArguments , wild . getUpperBounds () ) ) MST[NonVoidMethodCallMutator]MSP[N] . withLowerBounds ( unrollBounds ( typeArguments , wild . getLowerBounds () ) ) . build () ; } } return type ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[rv.ROR1Mutator]MSP[S]
public static String toString ( final Type type ) { MST[rv.CRCR3Mutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.CRCR5Mutator]MSP[S]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
} static boolean isArrayType ( final Type type ) { MST[ReturnValsMutator]MSP[S] return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) {
useOwner = raw . getEnclosingClass () ; MST[rv.ROR5Mutator]MSP[S] } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
public static boolean containsTypeVariables ( final Type type ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[experimental.NakedReceiverMutator]MSP[S]
if ( lowerBounds . length > 1 || lowerBounds . length == 1 && lowerBounds [ 0 ] != null ) { appendAllTo ( buf . append ( lr_25 ) , lr_24 , lowerBounds ) ; MST[EmptyObjectReturnValsMutator]MSP[N]
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI2Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR1Mutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[rv.ROR5Mutator]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR3Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[ReturnValsMutator]MSP[N]
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR5Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[rv.ROR1Mutator]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR5Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
buf . append ( c . getName () ) ; } if ( c . getTypeParameters () . length > 0 ) { buf . append ( '<' ) ; appendAllTo ( buf , lr_22 , c . getTypeParameters () ) ; MST[rv.ROR5Mutator]MSP[N] buf . append ( '>' ) ; }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } MST[NonVoidMethodCallMutator]MSP[S] return getRawType ( typeArgument , assigningType ) ;
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.UOI3Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR5Mutator]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR4Mutator]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; MST[NegateConditionalsMutator]MSP[S] useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[ReturnValsMutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ABSMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[InlineConstantMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[rv.ROR2Mutator]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
parameterizedTypeArguments = new HashMap < TypeVariable < ? > , Type > ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; MST[NegateConditionalsMutator]MSP[S] } final Type [] args = p . getActualTypeArguments () ;
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; MST[ReturnValsMutator]MSP[N] } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { MST[NegateConditionalsMutator]MSP[N] return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , MST[InlineConstantMutator]MSP[S] typeVarAssigns ) ) {
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI4Mutator]MSP[S] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR5Mutator]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[rv.ROR5Mutator]MSP[N]
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI2Mutator]MSP[N]
if ( toParameterizedType . equals ( type ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI3Mutator]MSP[N]
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[rv.ROR1Mutator]MSP[N]
midClass = ( Class < ? > ) midType ; } else { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI1Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[rv.CRCR5Mutator]MSP[S]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR5Mutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.UOI3Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[rv.ROR3Mutator]MSP[N]
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; break; } } if ( ! subtypeFound ) { MST[rv.CRCR2Mutator]MSP[N] types . add ( type1 ) ; } }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[InlineConstantMutator]MSP[N] toComponentType , typeVarAssigns ) ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[rv.ROR1Mutator]MSP[S] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[EmptyObjectReturnValsMutator]MSP[S]
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR3Mutator]MSP[S]
for ( final Type midType : interfaceTypes ) { MST[NonVoidMethodCallMutator]MSP[N] Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; } else if ( midType instanceof Class < ? > ) {
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[rv.ROR2Mutator]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR4Mutator]MSP[N]
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[NonVoidMethodCallMutator]MSP[N]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( t1 . length == t2 . length ) {
if ( type instanceof GenericArrayType ) { MST[rv.ROR1Mutator]MSP[N] return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[rv.ROR2Mutator]MSP[S]
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.CRCR3Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
: new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; } final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[rv.ROR5Mutator]MSP[N] final TypeVariable < ? > [] typeParams = cls . getTypeParameters () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[rv.CRCR2Mutator]MSP[S] return false ; }
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[rv.CRCR1Mutator]MSP[N] return null ; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[NegateConditionalsMutator]MSP[S]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR5Mutator]MSP[N] if ( t1 . length == t2 . length ) {
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[rv.ROR1Mutator]MSP[N] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
return buf . toString () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( toClass . equals ( type ) ) { return true ; }
return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitUpperBounds ( final WildcardType wildcardType ) { MST[rv.CRCR3Mutator]MSP[N] Validate . notNull ( wildcardType , lr_10 ) ;
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR2Mutator]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR2Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR1Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[rv.ROR3Mutator]MSP[S]
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR3Mutator]MSP[S]
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; } } return false ; MST[BooleanFalseReturnValsMutator]MSP[N] }
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[rv.ROR3Mutator]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
Validate . notNull ( var , lr_21 ) ; final StringBuilder buf = new StringBuilder () ; final GenericDeclaration d = ( ( TypeVariable < ? > ) var ) . getGenericDeclaration () ; if ( d instanceof Class < ? > ) { MST[NonVoidMethodCallMutator]MSP[N]
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass MST[ArgumentPropagationMutator]MSP[N] . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) {
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; MST[ArgumentPropagationMutator]MSP[N] if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
if ( containsTypeVariables ( arg ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[rv.ROR1Mutator]MSP[N] } } }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.CRCR5Mutator]MSP[S] if ( typeArguments == null ) {
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; MST[NegateConditionalsMutator]MSP[N] } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[rv.ROR2Mutator]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
if ( toWildcardType . equals ( type ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR4Mutator]MSP[S] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( typeArguments == null ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.ABSMutator]MSP[N] } return null ; }
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[NonVoidMethodCallMutator]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.ROR1Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[ArgumentPropagationMutator]MSP[N] }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR1Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.ABSMutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR4Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.ROR4Mutator]MSP[S] toComponentType , typeVarAssigns ) ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI1Mutator]MSP[N]
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[NegateConditionalsMutator]MSP[N]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR2Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
return buf . toString () ; MST[rv.ROR5Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[rv.ROR3Mutator]MSP[S] && ! toTypeArg . equals ( fromTypeArg )
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ;
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[NegateConditionalsMutator]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; MST[ArgumentPropagationMutator]MSP[N] } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
midClass = ( Class < ? > ) midType ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR4Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( toWildcardType . equals ( type ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[rv.ROR3Mutator]MSP[N] if ( midType instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( cls . equals ( superClass ) ) { MST[NonVoidMethodCallMutator]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[NegateConditionalsMutator]MSP[N] }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR6Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR2Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[ArgumentPropagationMutator]MSP[S] if ( typeArguments == null ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[rv.CRCR5Mutator]MSP[S] return false ; }
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.CRCR6Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ; MST[ReturnValsMutator]MSP[S]
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[rv.ROR1Mutator]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[NonVoidMethodCallMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[ArgumentPropagationMutator]MSP[S] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[rv.CRCR6Mutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR5Mutator]MSP[N] if ( assigningType == null ) { return null ; }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR1Mutator]MSP[N]
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[rv.CRCR5Mutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ; MST[NegateConditionalsMutator]MSP[S]
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } while ( true ); return result ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[ReturnValsMutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI3Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
buf . append ( '.' ) . append ( raw . getSimpleName () ) ; MST[NonVoidMethodCallMutator]MSP[N] } appendAllTo ( buf . append ( '<' ) , lr_22 , typeArguments ) . append ( '>' ) ; return buf . toString () ; }
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[rv.ROR2Mutator]MSP[N] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( toClass . equals ( type ) ) { return true ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[EmptyObjectReturnValsMutator]MSP[S]
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.ROR2Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; } MST[rv.ROR5Mutator]MSP[N]
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR2Mutator]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[rv.ROR1Mutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
if ( type instanceof Class < ? > ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[InlineConstantMutator]MSP[N] }
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null && ! toTypeArg . equals ( fromTypeArg )
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[rv.ROR5Mutator]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return buf . toString () ; MST[rv.CRCR6Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
return cls . isArray () MST[NegateConditionalsMutator]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
if ( type instanceof Class < ? > ) { MST[rv.ROR3Mutator]MSP[N] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI2Mutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
if ( type instanceof Class < ? > ) { final Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray () ? clazz . getComponentType () : null ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR2Mutator]MSP[N]
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.ROR5Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[experimental.NakedReceiverMutator]MSP[S]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR1Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[rv.ROR4Mutator]MSP[N]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR1Mutator]MSP[N] }
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; MST[rv.ROR2Mutator]MSP[N] } } return false ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[rv.ROR3Mutator]MSP[S] } else {
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI2Mutator]MSP[S]
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[ArgumentPropagationMutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR6Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[NonVoidMethodCallMutator]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
if ( type instanceof ParameterizedType ) { MST[rv.ROR2Mutator]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } } }
for ( int i = 0 ; i < typeParams . length ; i ++ ) { final Type typeArg = typeArgs [ i ] ; MST[NonVoidMethodCallMutator]MSP[N] typeVarAssigns . put ( typeParams [ i ] , typeVarAssigns . containsKey ( typeArg ) ? typeVarAssigns
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[InlineConstantMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; MST[rv.CRCR1Mutator]MSP[N] } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) {
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; } } return false ; MST[NonVoidMethodCallMutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR4Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR5Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR6Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI4Mutator]MSP[N]
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR5Mutator]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; MST[NonVoidMethodCallMutator]MSP[N] } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; final Class < ? > midClass = getRawType ( midParameterizedType ) ;
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR2Mutator]MSP[S] toComponentType , typeVarAssigns ) ; }
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[NegateConditionalsMutator]MSP[N] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ROR1Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ABSMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR5Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return false ; } } for ( final Type toBound : toLowerBounds ) { MST[ReturnValsMutator]MSP[N] if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { return false ; } } return true ; }
return buf . toString () ; MST[rv.ROR2Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static boolean containsTypeVariables ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.ROR2Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[InlineConstantMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return null ; } if ( cls . isPrimitive () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR4Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[rv.ROR5Mutator]MSP[S] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
if ( type instanceof TypeVariable < ? > ) { MST[NegateConditionalsMutator]MSP[N] for ( final Type bound : ( ( TypeVariable < ? > ) type ) . getBounds () ) { if ( isAssignable ( bound , toClass ) ) { return true ; } } return false ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] }
useOwner = raw . getEnclosingClass () ; } else { MST[InlineConstantMutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[NonVoidMethodCallMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[InlineConstantMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
static Map < TypeVariable < ? > , Type > getTypeArguments ( final ParameterizedType type ) { MST[NullReturnValsMutator]MSP[S] return getTypeArguments ( type , getRawType ( type ) , null ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[rv.ROR4Mutator]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 + type ) ; MST[NonVoidMethodCallMutator]MSP[S] } return replacementType ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () : isAssignable ( value . getClass () , type , null ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[NegateConditionalsMutator]MSP[S] } } return null ; }
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[rv.ROR5Mutator]MSP[N] && ! toTypeArg . equals ( fromTypeArg )
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[rv.ROR2Mutator]MSP[N] + type ) ; } return replacementType ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] toComponentType , typeVarAssigns ) ; }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI1Mutator]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[NonVoidMethodCallMutator]MSP[S]
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { MST[ReturnValsMutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR1Mutator]MSP[S] } } return null ; }
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[rv.ROR4Mutator]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[rv.CRCR1Mutator]MSP[N]
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[rv.ROR4Mutator]MSP[N] } while ( true ); return result ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ABSMutator]MSP[N] if ( typeArguments == null ) {
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[rv.CRCR6Mutator]MSP[S] final Class < ? > cls = ( Class < ? > ) type ;
if ( cls . equals ( superClass ) ) { MST[rv.ROR5Mutator]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[InlineConstantMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[ConstructorCallMutator]MSP[S]
typeArguments = Collections . < TypeVariable < ? > , Type > emptyMap () ; } if ( containsTypeVariables ( type ) ) { if ( type instanceof TypeVariable < ? > ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return unrollVariables ( typeArguments , typeArguments . get ( type ) ) ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI1Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.ABSMutator]MSP[S]
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.UOI3Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI4Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[rv.CRCR2Mutator]MSP[S] return false ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t1 . length == t2 . length ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.ROR2Mutator]MSP[N] }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR4Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
if ( fromTypeVarAssigns == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.CRCR5Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
public static String toString ( final Type type ) { MST[EmptyObjectReturnValsMutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[rv.ROR4Mutator]MSP[S] } } }
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI4Mutator]MSP[N]
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ROR1Mutator]MSP[S] if ( typeArguments == null ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[InlineConstantMutator]MSP[N] if ( t1 . length == t2 . length ) {
return parameterizeWithOwner ( p . getOwnerType () , ( Class < ? > ) p . getRawType () , args ) ; MST[rv.ROR5Mutator]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( cls . equals ( superClass ) ) { MST[rv.ROR2Mutator]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[NonVoidMethodCallMutator]MSP[S] return false ; }
if ( containsTypeVariables ( arg ) ) { MST[rv.CRCR3Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ABSMutator]MSP[S] if ( t1 . length == t2 . length ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.ROR3Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[NonVoidMethodCallMutator]MSP[N] final Type ... typeArguments ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI4Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI4Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[rv.CRCR5Mutator]MSP[S] return false ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[rv.ROR4Mutator]MSP[N] }
if ( toGenericArrayType . equals ( type ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ROR4Mutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( t1 instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NegateConditionalsMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR4Mutator]MSP[N] return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ROR4Mutator]MSP[N] if ( typeArguments == null ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR3Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR2Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.ROR2Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; } } return true ; MST[BooleanTrueReturnValsMutator]MSP[N] } return false ; }
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[NegateConditionalsMutator]MSP[N]
final TypeVariable < ? > typeVar = entry . getKey () ; MST[rv.CRCR5Mutator]MSP[N] final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
buf . append ( toString ( types [ 0 ] ) ) ; for ( int i = 1 ; i < types . length ; i ++ ) { MST[BooleanTrueReturnValsMutator]MSP[N] buf . append ( sep ) . append ( toString ( types [ i ] ) ) ; } }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[InlineConstantMutator]MSP[N] final Type ... typeArguments ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR5Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[NegateConditionalsMutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[ArgumentPropagationMutator]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[NonVoidMethodCallMutator]MSP[S]
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR2Mutator]MSP[N]
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[rv.CRCR3Mutator]MSP[N] final Class < ? > cls = ( Class < ? > ) type ;
parameterizedTypeArguments = new HashMap < TypeVariable < ? > , Type > ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } final Type [] args = p . getActualTypeArguments () ;
return cls . isArray () MST[rv.ROR1Mutator]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[NonVoidMethodCallMutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[NegateConditionalsMutator]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR5Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
midClass = ( Class < ? > ) midType ; } else { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR1Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.CRCR4Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR4Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR1Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[NegateConditionalsMutator]MSP[S] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.ROR5Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[VoidMethodCallMutator]MSP[S]
if ( type instanceof Class < ? > ) { final Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray () ? clazz . getComponentType () : null ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR5Mutator]MSP[N]
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[InlineConstantMutator]MSP[N] return null ; }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[NegateConditionalsMutator]MSP[N]
useOwner = raw . getEnclosingClass () ; MST[NonVoidMethodCallMutator]MSP[S] } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[rv.ROR5Mutator]MSP[S] + type ) ; } return replacementType ; }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 + type ) ; } return replacementType ; MST[NegateConditionalsMutator]MSP[S] }
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; MST[ReturnValsMutator]MSP[N] } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.ABSMutator]MSP[N] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
return types . toArray ( new Type [ types . size () ] ) ; } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { MST[rv.CRCR5Mutator]MSP[N] Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI3Mutator]MSP[S] if ( typeArguments == null ) {
if ( type instanceof ParameterizedType ) { MST[NonVoidMethodCallMutator]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
return buf . toString () ; MST[rv.CRCR3Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
if ( toParameterizedType . equals ( type ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
public static boolean containsTypeVariables ( final Type type ) { MST[NonVoidMethodCallMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[InlineConstantMutator]MSP[N]
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[rv.ROR2Mutator]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[rv.CRCR3Mutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[NonVoidMethodCallMutator]MSP[S] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI4Mutator]MSP[S] return false ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[BooleanFalseReturnValsMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[ReturnValsMutator]MSP[N] if ( midType instanceof Class < ? > ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[experimental.NakedReceiverMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR5Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR3Mutator]MSP[N] for ( final Type bound : ( ( TypeVariable < ? > ) type ) . getBounds () ) { if ( isAssignable ( bound , toClass ) ) { return true ; } } return false ; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[InlineConstantMutator]MSP[S]
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ABSMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR2Mutator]MSP[N] if ( t1 . length == t2 . length ) {
useOwner = raw . getEnclosingClass () ; } else { MST[InlineConstantMutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( toClass . equals ( type ) ) { return true ; }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[rv.ROR5Mutator]MSP[N] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[rv.ROR2Mutator]MSP[N] if ( midType instanceof Class < ? > ) {
if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[NegateConditionalsMutator]MSP[S] toComponentType , typeVarAssigns ) ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR6Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI2Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[ReturnValsMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[rv.CRCR4Mutator]MSP[S]
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[rv.ROR3Mutator]MSP[N]
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[rv.ROR4Mutator]MSP[S] } else {
result |= Arrays . hashCode ( lowerBounds ) ; return result ; } public static boolean isAssignable ( final Type type , final Type toType ) { return isAssignable ( type , toType , null ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.CRCR2Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
if ( containsTypeVariables ( arg ) ) { MST[rv.CRCR1Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.CRCR1Mutator]MSP[S] if ( typeArguments == null ) {
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[IncrementsMutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[InlineConstantMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI2Mutator]MSP[S] return false ; }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[NegateConditionalsMutator]MSP[N] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
if ( type instanceof Class < ? > ) { final Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray () ? clazz . getComponentType () : null ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR3Mutator]MSP[N]
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[InlineConstantMutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR3Mutator]MSP[N] return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR1Mutator]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[rv.ROR4Mutator]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR3Mutator]MSP[S] } } return null ; }
buf . append ( c . getName () ) ; } if ( c . getTypeParameters () . length > 0 ) { buf . append ( '<' ) ; appendAllTo ( buf , lr_22 , c . getTypeParameters () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buf . append ( '>' ) ; }
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[rv.ROR1Mutator]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[rv.ROR2Mutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 + type ) ; MST[ArgumentPropagationMutator]MSP[S] } return replacementType ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR2Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { MST[rv.CRCR3Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) {
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ABSMutator]MSP[S] if ( typeArguments == null ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[experimental.NakedReceiverMutator]MSP[S] toComponentType , typeVarAssigns ) ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[S] return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls ,
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NegateConditionalsMutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( toParameterizedType . equals ( type ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.ABSMutator]MSP[N]
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitUpperBounds ( final WildcardType wildcardType ) { MST[InlineConstantMutator]MSP[N] Validate . notNull ( wildcardType , lr_10 ) ;
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ; MST[NonVoidMethodCallMutator]MSP[S]
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR2Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR4Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
private static StringBuilder appendAllTo ( final StringBuilder buf , final String sep , final Type ... types ) { MST[ArgumentPropagationMutator]MSP[N] Validate . notEmpty ( Validate . noNullElements ( types ) ) ; if ( types . length > 0 ) {
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; break; } } if ( ! subtypeFound ) { MST[rv.CRCR3Mutator]MSP[N] types . add ( type1 ) ; } }
useOwner = raw . getEnclosingClass () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; MST[ArgumentPropagationMutator]MSP[N] } if ( type instanceof GenericArrayType ) {
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[NegateConditionalsMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
if ( type instanceof Class < ? > ) { MST[rv.ROR4Mutator]MSP[N] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR5Mutator]MSP[S] toComponentType , typeVarAssigns ) ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR1Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ROR2Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[InlineConstantMutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
public static boolean containsTypeVariables ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR1Mutator]MSP[S] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.CRCR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; }
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[NegateConditionalsMutator]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[rv.ROR3Mutator]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.ROR4Mutator]MSP[N]
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; MST[NullReturnValsMutator]MSP[N] if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR4Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR6Mutator]MSP[S]
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR5Mutator]MSP[N] }
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; }
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR3Mutator]MSP[N]
if ( cls . equals ( superClass ) ) { MST[rv.ROR4Mutator]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI2Mutator]MSP[N]
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.ABSMutator]MSP[N]
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[rv.ROR5Mutator]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
public static String toString ( final Type type ) { MST[ReturnValsMutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[rv.ROR4Mutator]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR3Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return buf . toString () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[rv.CRCR5Mutator]MSP[N]
private static boolean equals ( final GenericArrayType a , final Type t ) { MST[rv.CRCR1Mutator]MSP[N] return t instanceof GenericArrayType && equals ( a . getGenericComponentType () , ( ( GenericArrayType ) t ) . getGenericComponentType () ) ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[NullReturnValsMutator]MSP[N] }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; MST[rv.CRCR6Mutator]MSP[N] } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) {
buf . append ( toString ( types [ 0 ] ) ) ; for ( int i = 1 ; i < types . length ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[S] buf . append ( sep ) . append ( toString ( types [ i ] ) ) ; } }
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () : isAssignable ( value . getClass () , type , null ) ; MST[rv.CRCR6Mutator]MSP[N] }
return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitUpperBounds ( final WildcardType wildcardType ) { MST[ArgumentPropagationMutator]MSP[N] Validate . notNull ( wildcardType , lr_10 ) ;
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } while ( true ); return result ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR5Mutator]MSP[N]
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return new GenericArrayTypeImpl ( Validate . notNull ( componentType , lr_20 ) ) ; } @SuppressWarnings ( lr_1 ) MST[ReturnValsMutator]MSP[N] public static boolean equals ( final Type t1 , final Type t2 ) { if ( ObjectUtils . equals ( t1 , t2 ) ) { return true ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[rv.ROR5Mutator]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR1Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
&& typeVarAssigns . containsKey ( typeVar ) ) { MST[rv.UOI1Mutator]MSP[N] typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; } } }
public static boolean containsTypeVariables ( final Type type ) { MST[NegateConditionalsMutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR4Mutator]MSP[N]
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI2Mutator]MSP[S] if ( typeArguments == null ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
throw new IllegalStateException ( lr_12 + rawType ) ; } return ( Class < ? > ) rawType ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static Class < ? > getRawType ( final Type type , final Type assigningType ) { if ( type instanceof Class < ? > ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.ROR5Mutator]MSP[S] toComponentType , typeVarAssigns ) ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR5Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR3Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR1Mutator]MSP[N] return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR3Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI4Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[NonVoidMethodCallMutator]MSP[N]
} if ( genericInterface != null ) { MST[rv.ROR1Mutator]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[NegateConditionalsMutator]MSP[N]
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[NegateConditionalsMutator]MSP[S]
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; MST[ReturnValsMutator]MSP[S] } if ( t1 instanceof WildcardType ) {
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.ROR5Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR6Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( toClass . equals ( type ) ) { return true ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[rv.ROR3Mutator]MSP[N] }
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI1Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR3Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[ReturnValsMutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR4Mutator]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[NonVoidMethodCallMutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR5Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR3Mutator]MSP[N] }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[InlineConstantMutator]MSP[S]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR6Mutator]MSP[N] }
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[rv.ROR1Mutator]MSP[S] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[rv.CRCR1Mutator]MSP[N] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[rv.ROR1Mutator]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI4Mutator]MSP[N]
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[rv.ROR5Mutator]MSP[N]
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI3Mutator]MSP[S] } return null ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR6Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[NegateConditionalsMutator]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { MST[NonVoidMethodCallMutator]MSP[S] return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.ROR5Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR5Mutator]MSP[S]
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[NonVoidMethodCallMutator]MSP[S]
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[rv.ROR4Mutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[rv.ROR3Mutator]MSP[N] } while ( true ); return result ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[rv.ROR5Mutator]MSP[S] && ! toTypeArg . equals ( fromTypeArg )
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () : isAssignable ( value . getClass () , type , null ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[rv.ROR1Mutator]MSP[S] + type ) ; } return replacementType ; }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI3Mutator]MSP[S] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR4Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[rv.ROR1Mutator]MSP[N] }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
useOwner = raw . getEnclosingClass () ; } else { MST[VoidMethodCallMutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[InlineConstantMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.UOI4Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
return cls . isArray () MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[rv.ROR1Mutator]MSP[S] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( toType instanceof GenericArrayType ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) { MST[rv.ROR5Mutator]MSP[N]
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[InlineConstantMutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; MST[rv.ROR4Mutator]MSP[N] } } return true ; } return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR5Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return wildcardType () . withUpperBounds ( unrollBounds ( typeArguments , wild . getUpperBounds () ) ) MST[NullReturnValsMutator]MSP[S] . withLowerBounds ( unrollBounds ( typeArguments , wild . getLowerBounds () ) ) . build () ; } } return type ; }
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR3Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.ROR1Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[rv.CRCR2Mutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
Validate . notNull ( var , lr_21 ) ; final StringBuilder buf = new StringBuilder () ; final GenericDeclaration d = ( ( TypeVariable < ? > ) var ) . getGenericDeclaration () ; if ( d instanceof Class < ? > ) { MST[rv.CRCR1Mutator]MSP[N]
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.ROR4Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI4Mutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[rv.ROR4Mutator]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[ArgumentPropagationMutator]MSP[S]
return equals ( ( WildcardType ) t1 , t2 ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( type instanceof WildcardType ) { MST[NonVoidMethodCallMutator]MSP[N] for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[NegateConditionalsMutator]MSP[N] }
useOwner = raw . getEnclosingClass () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[rv.ROR1Mutator]MSP[N] } } return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NegateConditionalsMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; MST[rv.ROR5Mutator]MSP[N] } public static String toLongString ( final TypeVariable < ? > var ) {
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR4Mutator]MSP[N] final Type ... typeArguments ) {
throw new IllegalStateException ( lr_12 + rawType ) ; } return ( Class < ? > ) rawType ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static Class < ? > getRawType ( final Type type , final Type assigningType ) { if ( type instanceof Class < ? > ) {
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[rv.CRCR2Mutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( typeArguments == null ) {
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[rv.ROR2Mutator]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
final TypeVariable < ? > typeVar = entry . getKey () ; MST[rv.CRCR1Mutator]MSP[N] final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { MST[InlineConstantMutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI1Mutator]MSP[N] } return null ; }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR6Mutator]MSP[S]
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; MST[NegateConditionalsMutator]MSP[N] } public static String toLongString ( final TypeVariable < ? > var ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] }
return new GenericArrayTypeImpl ( Validate . notNull ( componentType , lr_20 ) ) ; } @SuppressWarnings ( lr_1 ) MST[NonVoidMethodCallMutator]MSP[N] public static boolean equals ( final Type t1 , final Type t2 ) { if ( ObjectUtils . equals ( t1 , t2 ) ) { return true ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR5Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[InlineConstantMutator]MSP[N] }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { MST[NonVoidMethodCallMutator]MSP[S] return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; MST[NullReturnValsMutator]MSP[N] } if ( type instanceof GenericArrayType ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[BooleanTrueReturnValsMutator]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[InlineConstantMutator]MSP[N] }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI4Mutator]MSP[S]
return types . toArray ( new Type [ types . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; final Class < ? > midClass = getRawType ( midParameterizedType ) ; MST[NullReturnValsMutator]MSP[S]
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI4Mutator]MSP[S] } return null ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR1Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[InlineConstantMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static String toLongString ( final TypeVariable < ? > var ) {
if ( toGenericArrayType . equals ( type ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR6Mutator]MSP[N]
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[NegateConditionalsMutator]MSP[S]
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI1Mutator]MSP[N]
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR5Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( containsTypeVariables ( arg ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
final HashMap < TypeVariable < ? > , Type > typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > () MST[ArgumentPropagationMutator]MSP[N] : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ;
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.CRCR5Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR3Mutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
return buf . toString () ; MST[rv.UOI3Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
return false ; } } for ( final Type toBound : toLowerBounds ) { MST[InlineConstantMutator]MSP[N] if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { return false ; } } return true ; }
if ( type instanceof WildcardType ) { MST[BooleanFalseReturnValsMutator]MSP[N] for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) { MST[NegateConditionalsMutator]MSP[N]
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.ABSMutator]MSP[S] return false ; }
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[rv.CRCR2Mutator]MSP[S] final Class < ? > cls = ( Class < ? > ) type ;
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.ROR5Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[NegateConditionalsMutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[rv.ROR5Mutator]MSP[S]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[rv.ROR4Mutator]MSP[S] buf . insert ( 0 , c . getName () ) ; break; }
if ( t1 instanceof ParameterizedType ) { MST[rv.ROR1Mutator]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[rv.ROR3Mutator]MSP[S] } } }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI2Mutator]MSP[S] if ( typeArguments == null ) {
return false ; } } for ( final Type toBound : toLowerBounds ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { return false ; } } return true ; }
public static boolean containsTypeVariables ( final Type type ) { MST[ReturnValsMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[rv.ROR3Mutator]MSP[N]
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR2Mutator]MSP[N] if ( assigningType == null ) { return null ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ABSMutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR4Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.ROR3Mutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[NonVoidMethodCallMutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR2Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR1Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return null ; } if ( cls . isPrimitive () ) { MST[rv.ROR3Mutator]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[rv.CRCR3Mutator]MSP[N] return null ; }
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[rv.ROR3Mutator]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR6Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[InlineConstantMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[InlineConstantMutator]MSP[S] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR4Mutator]MSP[N] }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( toClass . equals ( type ) ) { return true ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR6Mutator]MSP[N] }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ABSMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[NegateConditionalsMutator]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI3Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[rv.ROR4Mutator]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeArgMappings ) { Validate . notNull ( raw , lr_13 ) ; Validate . notNull ( typeArgMappings , lr_14 ) ;
if ( toClass . equals ( cls ) ) { MST[ConstructorCallMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; MST[ReturnValsMutator]MSP[N] } if ( type instanceof GenericArrayType ) {
private static boolean equals ( final GenericArrayType a , final Type t ) { MST[ReturnValsMutator]MSP[N] return t instanceof GenericArrayType && equals ( a . getGenericComponentType () , ( ( GenericArrayType ) t ) . getGenericComponentType () ) ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR3Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR3Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR1Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.ABSMutator]MSP[N]
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI2Mutator]MSP[N]
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] ) MST[rv.CRCR5Mutator]MSP[N]
midClass = ( Class < ? > ) midType ; } else { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[NegateConditionalsMutator]MSP[S] + type ) ; } return replacementType ; }
} if ( genericInterface != null ) { MST[NonVoidMethodCallMutator]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI3Mutator]MSP[S] if ( typeArguments == null ) {
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[rv.ROR2Mutator]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
if ( containsTypeVariables ( arg ) ) { MST[ConditionalsBoundaryMutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
&& ! ( toTypeArg instanceof WildcardType && isAssignable ( fromTypeArg , toTypeArg , typeVarAssigns ) ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } return true ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( t1 instanceof WildcardType ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI3Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
&& ! ( toTypeArg instanceof WildcardType && isAssignable ( fromTypeArg , toTypeArg , typeVarAssigns ) ) ) { return false ; MST[rv.ROR5Mutator]MSP[N] } } return true ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI3Mutator]MSP[N] return false ; }
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI2Mutator]MSP[N]
Validate . notNull ( var , lr_21 ) ; final StringBuilder buf = new StringBuilder () ; final GenericDeclaration d = ( ( TypeVariable < ? > ) var ) . getGenericDeclaration () ; if ( d instanceof Class < ? > ) { MST[rv.CRCR6Mutator]MSP[N]
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[rv.ROR2Mutator]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.UOI4Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; break; } } if ( ! subtypeFound ) { MST[InlineConstantMutator]MSP[N] types . add ( type1 ) ; } }
if ( t1 instanceof ParameterizedType ) { MST[NonVoidMethodCallMutator]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[NullReturnValsMutator]MSP[S]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI4Mutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( toParameterizedType . equals ( type ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI1Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR5Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return cls . isArray () MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } MST[NonVoidMethodCallMutator]MSP[S] if ( type instanceof ParameterizedType ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.CRCR3Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( type instanceof Class < ? > ) { MST[NegateConditionalsMutator]MSP[N] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; MST[BooleanTrueReturnValsMutator]MSP[N] } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) {
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () : isAssignable ( value . getClass () , type , null ) ; MST[rv.CRCR5Mutator]MSP[N] }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR4Mutator]MSP[S]
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI3Mutator]MSP[N]
return isAssignable ( type , ( Class < ? > ) toType ) ; MST[ReturnValsMutator]MSP[N] } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR4Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR4Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR5Mutator]MSP[S]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[InlineConstantMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR4Mutator]MSP[N]
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI1Mutator]MSP[N] if ( typeArguments == null ) {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR1Mutator]MSP[N] } return false ; }
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[NonVoidMethodCallMutator]MSP[S] return null ; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[ConditionalsBoundaryMutator]MSP[S]
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.CRCR3Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[NonVoidMethodCallMutator]MSP[S]
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ROR2Mutator]MSP[S] if ( typeArguments == null ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
Class < ? > c = ( Class < ? > ) d ; MST[ConstructorCallMutator]MSP[N] while ( true ) { if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[NonVoidMethodCallMutator]MSP[S]
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR1Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( type == null ) { MST[rv.ROR5Mutator]MSP[N] return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR4Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return parameterizeWithOwner ( p . getOwnerType () , ( Class < ? > ) p . getRawType () , args ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ;
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR3Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[rv.CRCR6Mutator]MSP[N] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[IncrementsMutator]MSP[N]
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[rv.CRCR3Mutator]MSP[S]
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; break; } } if ( ! subtypeFound ) { MST[rv.CRCR4Mutator]MSP[N] types . add ( type1 ) ; } }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR5Mutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[ReturnValsMutator]MSP[S] final Class < ? > cls = ( Class < ? > ) type ;
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR4Mutator]MSP[N] } }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; MST[NonVoidMethodCallMutator]MSP[N] final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[rv.ROR5Mutator]MSP[N] } else {
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[NegateConditionalsMutator]MSP[S] } else {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[NonVoidMethodCallMutator]MSP[S] } else {
return buf . toString () ; MST[rv.ROR3Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
return buf . toString () ; MST[rv.CRCR1Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[rv.ROR4Mutator]MSP[S] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[rv.ROR1Mutator]MSP[S] if ( midType instanceof Class < ? > ) {
if ( toParameterizedType . equals ( type ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.UOI3Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[rv.ROR2Mutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[rv.CRCR5Mutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
if ( type == null ) { MST[NegateConditionalsMutator]MSP[N] return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.ROR4Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[rv.ROR5Mutator]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[NegateConditionalsMutator]MSP[N] } else {
if ( toParameterizedType . equals ( type ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
if ( cls . equals ( superClass ) ) { MST[rv.ROR3Mutator]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI3Mutator]MSP[N]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ABSMutator]MSP[S] if ( t1 . length == t2 . length ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[NonVoidMethodCallMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.ABSMutator]MSP[N]
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI2Mutator]MSP[N] } return null ; }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; MST[ReturnValsMutator]MSP[N] }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI2Mutator]MSP[N] return false ; }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[ReturnValsMutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[rv.ROR4Mutator]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
} if ( genericInterface != null ) { return genericInterface ; } } return cls . getGenericSuperclass () ; MST[ReturnValsMutator]MSP[N] } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
return types . toArray ( new Type [ types . size () ] ) ; } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR6Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[rv.CRCR4Mutator]MSP[N] return false ; }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] + type ) ; } return replacementType ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } MST[ArgumentPropagationMutator]MSP[S] if ( type instanceof ParameterizedType ) {
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; MST[NonVoidMethodCallMutator]MSP[N] } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
if ( t1 instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR5Mutator]MSP[S] } }
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[NegateConditionalsMutator]MSP[S] && ! toTypeArg . equals ( fromTypeArg )
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR1Mutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[NegateConditionalsMutator]MSP[S]
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[rv.ROR2Mutator]MSP[N] }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR5Mutator]MSP[N]
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NegateConditionalsMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , MST[ReturnValsMutator]MSP[S] typeVarAssigns ) ) {
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[rv.ROR5Mutator]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[InlineConstantMutator]MSP[S] final Class < ? > cls = ( Class < ? > ) type ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[rv.ROR2Mutator]MSP[N] } } return false ; }
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[NegateConditionalsMutator]MSP[S] } }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[rv.ROR2Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[rv.CRCR4Mutator]MSP[N] return false ; }
if ( toClass . equals ( cls ) ) { MST[rv.ROR5Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[NegateConditionalsMutator]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
} if ( genericInterface != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
if ( type instanceof ParameterizedType ) { MST[rv.ROR1Mutator]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[rv.CRCR3Mutator]MSP[N] return null ; }
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR2Mutator]MSP[N]
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI3Mutator]MSP[N] } return null ; }
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; MST[NonVoidMethodCallMutator]MSP[N] } final Type ownerType = parameterizedType . getOwnerType () ; Map < TypeVariable < ? > , Type > typeVarAssigns ;
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR5Mutator]MSP[N]
final HashMap < TypeVariable < ? > , Type > typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > () MST[NonVoidMethodCallMutator]MSP[N] : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ;
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
public static boolean containsTypeVariables ( final Type type ) { MST[InlineConstantMutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[rv.ROR1Mutator]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; MST[rv.ROR3Mutator]MSP[S] } } return true ; } return false ; }
return types . toArray ( new Type [ types . size () ] ) ; } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { MST[rv.CRCR3Mutator]MSP[S] Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[NonVoidMethodCallMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR3Mutator]MSP[N] final Type ... typeArguments ) {
public static String toString ( final Type type ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[NonVoidMethodCallMutator]MSP[N] final Type ... typeArguments ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.ROR3Mutator]MSP[S]
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[NonVoidMethodCallMutator]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
return types . toArray ( new Type [ types . size () ] ) ; MST[NegateConditionalsMutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI1Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR6Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
buf . append ( toString ( types [ 0 ] ) ) ; for ( int i = 1 ; i < types . length ; i ++ ) { MST[BooleanFalseReturnValsMutator]MSP[S] buf . append ( sep ) . append ( toString ( types [ i ] ) ) ; } }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] ) MST[InlineConstantMutator]MSP[N]
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR1Mutator]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[BooleanTrueReturnValsMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR6Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI3Mutator]MSP[S] if ( typeArguments == null ) {
return buf . toString () ; MST[rv.UOI4Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[NonVoidMethodCallMutator]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
: new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; final TypeVariable < ? > [] typeParams = cls . getTypeParameters () ;
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR3Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
buf . append ( c . getName () ) ; } if ( c . getTypeParameters () . length > 0 ) { buf . append ( '<' ) ; appendAllTo ( buf , lr_22 , c . getTypeParameters () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buf . append ( '>' ) ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR2Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR2Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; final Class < ? > midClass = getRawType ( midParameterizedType ) ; MST[ReturnValsMutator]MSP[S]
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[rv.ROR4Mutator]MSP[N]
if ( toWildcardType . equals ( type ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR2Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR2Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[rv.ROR4Mutator]MSP[N]
result |= Arrays . hashCode ( lowerBounds ) ; return result ; } public static boolean isAssignable ( final Type type , final Type toType ) { return isAssignable ( type , toType , null ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[NegateConditionalsMutator]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
useOwner = raw . getEnclosingClass () ; MST[experimental.NakedReceiverMutator]MSP[N] } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
if ( t1 instanceof ParameterizedType ) { MST[rv.ROR2Mutator]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR5Mutator]MSP[S] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[NonVoidMethodCallMutator]MSP[S]
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; MST[ReturnValsMutator]MSP[N] } if ( type instanceof TypeVariable < ? > ) { if ( assigningType == null ) { return null ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.ROR4Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[rv.ROR1Mutator]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
final Type [] bounds = wildcardType . getUpperBounds () ; return bounds . length == 0 ? new Type [] { Object . class } : normalizeUpperBounds ( bounds ) ; } public static Type [] getImplicitLowerBounds ( final WildcardType wildcardType ) { MST[ArgumentPropagationMutator]MSP[N]
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[ReturnValsMutator]MSP[S]
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI1Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[NegateConditionalsMutator]MSP[S] buf . insert ( 0 , c . getName () ) ; break; }
public static boolean containsTypeVariables ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[InlineConstantMutator]MSP[N] }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[NonVoidMethodCallMutator]MSP[N] if ( typeArguments == null ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR3Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR2Mutator]MSP[N]
public static < T > Typed < T > wrap ( final Class < T > type ) { return TypeUtils . <T > wrap ( ( Type ) type ) ; } private static String classToString ( final Class < ? > c ) { MST[NonVoidMethodCallMutator]MSP[N]
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] + type ) ; } return replacementType ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[rv.CRCR3Mutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
Validate . notNull ( raw , lr_13 ) ; final Type useOwner ; if ( raw . getEnclosingClass () == null ) { Validate . isTrue ( owner == null , lr_15 , raw ) ; useOwner = null ; MST[rv.CRCR6Mutator]MSP[N] } else if ( owner == null ) {
buf . append ( c . getName () ) ; } if ( c . getTypeParameters () . length > 0 ) { buf . append ( '<' ) ; appendAllTo ( buf , lr_22 , c . getTypeParameters () ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( '>' ) ; }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR3Mutator]MSP[N]
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[rv.ROR4Mutator]MSP[S]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR1Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) { MST[rv.ROR2Mutator]MSP[N]
throw new IllegalStateException ( lr_12 + rawType ) ; } return ( Class < ? > ) rawType ; MST[rv.ROR1Mutator]MSP[N] } public static Class < ? > getRawType ( final Type type , final Type assigningType ) { if ( type instanceof Class < ? > ) {
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[rv.ROR5Mutator]MSP[S] + type ) ; } return replacementType ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[rv.ROR5Mutator]MSP[S] buf . insert ( 0 , c . getName () ) ; break; }
buf . append ( toString ( types [ 0 ] ) ) ; for ( int i = 1 ; i < types . length ; i ++ ) { MST[ReturnValsMutator]MSP[S] buf . append ( sep ) . append ( toString ( types [ i ] ) ) ; } }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR3Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[rv.ROR5Mutator]MSP[S] } else {
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[rv.ROR2Mutator]MSP[N] } } }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.ABSMutator]MSP[N] return false ; }
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR1Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.ROR1Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[NonVoidMethodCallMutator]MSP[S]
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[InlineConstantMutator]MSP[N]
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR3Mutator]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI2Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( containsTypeVariables ( arg ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[InlineConstantMutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[ConditionalsBoundaryMutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[rv.ROR3Mutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[NonVoidMethodCallMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; MST[ReturnValsMutator]MSP[N] }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI1Mutator]MSP[N] if ( t1 . length == t2 . length ) {
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] && ! toTypeArg . equals ( fromTypeArg )
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR5Mutator]MSP[N]
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; MST[rv.ROR3Mutator]MSP[N] } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
public static boolean containsTypeVariables ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR3Mutator]MSP[S] final Type ... typeArguments ) {
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[ArgumentPropagationMutator]MSP[N]
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR5Mutator]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
&& ! ( toTypeArg instanceof WildcardType && isAssignable ( fromTypeArg , toTypeArg , typeVarAssigns ) ) ) { return false ; MST[NegateConditionalsMutator]MSP[N] } } return true ; }
if ( toParameterizedType . equals ( type ) ) { return true ; MST[InlineConstantMutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR5Mutator]MSP[S]
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR3Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return wildcardType () . withUpperBounds ( unrollBounds ( typeArguments , wild . getUpperBounds () ) ) MST[NonVoidMethodCallMutator]MSP[S] . withLowerBounds ( unrollBounds ( typeArguments , wild . getLowerBounds () ) ) . build () ; } } return type ; }
return types . toArray ( new Type [ types . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[NegateConditionalsMutator]MSP[N] }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[rv.CRCR6Mutator]MSP[S] return false ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR5Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR1Mutator]MSP[N] if ( t1 . length == t2 . length ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI3Mutator]MSP[S]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[NegateConditionalsMutator]MSP[N] } while ( true ); return result ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[rv.CRCR4Mutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } return false ; }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR2Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[InlineConstantMutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[ReturnValsMutator]MSP[N] if ( typeArguments == null ) {
return buf . toString () ; MST[rv.ROR4Mutator]MSP[N] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; MST[rv.CRCR4Mutator]MSP[N] } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( t1 . length == t2 . length ) {
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ABSMutator]MSP[N] if ( typeArguments == null ) {
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; MST[rv.ROR3Mutator]MSP[N] } } return false ; }
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR3Mutator]MSP[S] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
&& typeVarAssigns . containsKey ( typeVar ) ) { typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; MST[rv.ROR5Mutator]MSP[S] } } }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.ROR3Mutator]MSP[S] if ( typeArguments == null ) {
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI4Mutator]MSP[N] if ( t1 . length == t2 . length ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI2Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR3Mutator]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[rv.CRCR3Mutator]MSP[N] return false ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[rv.ROR5Mutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[rv.ROR2Mutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR6Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[NegateConditionalsMutator]MSP[N]
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI1Mutator]MSP[S] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { MST[rv.CRCR4Mutator]MSP[N] final Class < ? > cls = ( Class < ? > ) type ;
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ABSMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( toParameterizedType . equals ( type ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] toComponentType , typeVarAssigns ) ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[rv.ROR1Mutator]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[ReturnValsMutator]MSP[S]
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( assigningType == null ) { return null ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.UOI1Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI3Mutator]MSP[N]
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR5Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[rv.ROR4Mutator]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[rv.ROR3Mutator]MSP[S] buf . insert ( 0 , c . getName () ) ; break; }
public static boolean containsTypeVariables ( final Type type ) { MST[NegateConditionalsMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( toParameterizedType . equals ( type ) ) { return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; MST[NonVoidMethodCallMutator]MSP[N] final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[NegateConditionalsMutator]MSP[N]
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( lowerBounds . length > 1 || lowerBounds . length == 1 && lowerBounds [ 0 ] != null ) { appendAllTo ( buf . append ( lr_25 ) , lr_24 , lowerBounds ) ; MST[ReturnValsMutator]MSP[N]
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean containsTypeVariables ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NonVoidMethodCallMutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI3Mutator]MSP[S] return false ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI4Mutator]MSP[S] return false ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( t1 . length == t2 . length ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI2Mutator]MSP[N] } return null ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI1Mutator]MSP[S] } return null ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; MST[rv.ROR5Mutator]MSP[S] useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; MST[rv.ROR1Mutator]MSP[N] } public static String toLongString ( final TypeVariable < ? > var ) {
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; final Class < ? > midClass = getRawType ( midParameterizedType ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
if ( type == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; MST[NonVoidMethodCallMutator]MSP[S] } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls ,
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; MST[ReturnValsMutator]MSP[S] } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
result |= Arrays . hashCode ( lowerBounds ) ; return result ; } public static boolean isAssignable ( final Type type , final Type toType ) { return isAssignable ( type , toType , null ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[rv.ROR1Mutator]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR2Mutator]MSP[N] return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
final TypeVariable < ? > typeVar = entry . getKey () ; MST[rv.CRCR3Mutator]MSP[N] final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR6Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[rv.ROR2Mutator]MSP[N] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[ReturnValsMutator]MSP[N] }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[NonVoidMethodCallMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR6Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[ReturnValsMutator]MSP[N] }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR1Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[rv.ROR5Mutator]MSP[N]
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
if ( toParameterizedType . equals ( type ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[rv.ROR4Mutator]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[InlineConstantMutator]MSP[N]
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; MST[rv.ROR5Mutator]MSP[S] if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] ) MST[rv.CRCR6Mutator]MSP[N]
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[ConditionalsBoundaryMutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
private static boolean equals ( final GenericArrayType a , final Type t ) { MST[rv.CRCR6Mutator]MSP[N] return t instanceof GenericArrayType && equals ( a . getGenericComponentType () , ( ( GenericArrayType ) t ) . getGenericComponentType () ) ; }
midClass = ( Class < ? > ) midType ; } else { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[BooleanFalseReturnValsMutator]MSP[N] if ( t1 . length == t2 . length ) {
return null ; } if ( cls . isPrimitive () ) { if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; MST[rv.ROR3Mutator]MSP[N] } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR5Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[NonVoidMethodCallMutator]MSP[S] if ( typeArguments == null ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.CRCR2Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
return isAssignable ( type , ( Class < ? > ) toType ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR3Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR1Mutator]MSP[S]
if ( toClass . equals ( cls ) ) { MST[ConstructorCallMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[NonVoidMethodCallMutator]MSP[S] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( toParameterizedType . equals ( type ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.ROR3Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.ABSMutator]MSP[N] } return null ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; MST[ReturnValsMutator]MSP[N] if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[rv.ROR3Mutator]MSP[S] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR3Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.CRCR4Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) { MST[rv.ROR1Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[rv.ROR4Mutator]MSP[S] } else {
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI3Mutator]MSP[N]
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[rv.ROR4Mutator]MSP[S] && ! toTypeArg . equals ( fromTypeArg )
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR1Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
} if ( genericInterface != null ) { return genericInterface ; } } return cls . getGenericSuperclass () ; MST[NullReturnValsMutator]MSP[N] } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[NonVoidMethodCallMutator]MSP[N] final Type ... typeArguments ) {
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI4Mutator]MSP[N]
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI1Mutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
Validate . notNull ( var , lr_21 ) ; final StringBuilder buf = new StringBuilder () ; final GenericDeclaration d = ( ( TypeVariable < ? > ) var ) . getGenericDeclaration () ; if ( d instanceof Class < ? > ) { MST[rv.CRCR5Mutator]MSP[N]
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[NegateConditionalsMutator]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR6Mutator]MSP[S] toComponentType , typeVarAssigns ) ; }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR3Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.CRCR5Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
final TypeVariable < ? > typeVar = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; MST[NonVoidMethodCallMutator]MSP[N] typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( fromTypeArg != null && ! toTypeArg . equals ( fromTypeArg )
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.ROR2Mutator]MSP[N] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[NonVoidMethodCallMutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[NonVoidMethodCallMutator]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[rv.ROR4Mutator]MSP[N] if ( midType instanceof Class < ? > ) {
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR4Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR4Mutator]MSP[S]
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[NonVoidMethodCallMutator]MSP[N]
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR6Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR1Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR2Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; MST[rv.CRCR5Mutator]MSP[N] c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.ROR5Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { return null ; MST[NonVoidMethodCallMutator]MSP[N] }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR3Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( toClass . equals ( cls ) ) { MST[NegateConditionalsMutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.CRCR5Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( type instanceof Class < ? > ) { MST[rv.ROR2Mutator]MSP[S] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
if ( type instanceof ParameterizedType ) { MST[NegateConditionalsMutator]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.ROR3Mutator]MSP[S] toComponentType , typeVarAssigns ) ; }
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[NonVoidMethodCallMutator]MSP[S] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
return false ; } } for ( final Type toBound : toLowerBounds ) { MST[rv.CRCR1Mutator]MSP[N] if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { return false ; } } return true ; }
final TypeVariable < ? > typeVar = entry . getKey () ; MST[rv.CRCR6Mutator]MSP[N] final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR3Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR2Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR2Mutator]MSP[S]
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[NegateConditionalsMutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
midClass = ( Class < ? > ) midType ; } else { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
if ( containsTypeVariables ( arg ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR3Mutator]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] ) MST[BooleanTrueReturnValsMutator]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ABSMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[InlineConstantMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
static Map < TypeVariable < ? > , Type > getTypeArguments ( final ParameterizedType type ) { MST[ReturnValsMutator]MSP[S] return getTypeArguments ( type , getRawType ( type ) , null ) ; }
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; MST[ReturnValsMutator]MSP[N] } if ( toType instanceof TypeVariable < ? > ) {
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[NegateConditionalsMutator]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI1Mutator]MSP[S] if ( typeArguments == null ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.CRCR6Mutator]MSP[S] if ( typeArguments == null ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalStateException ( lr_12 + rawType ) ; } return ( Class < ? > ) rawType ; MST[rv.ROR2Mutator]MSP[N] } public static Class < ? > getRawType ( final Type type , final Type assigningType ) { if ( type instanceof Class < ? > ) {
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR1Mutator]MSP[N]
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } } return false ; }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( assigningType == null ) { return null ; }
parameterizedTypeArguments = new HashMap < TypeVariable < ? > , Type > ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; MST[rv.ROR5Mutator]MSP[S] } final Type [] args = p . getActualTypeArguments () ;
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; MST[rv.ROR2Mutator]MSP[N] } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI4Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; MST[rv.CRCR5Mutator]MSP[N] } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( t1 instanceof WildcardType ) {
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR5Mutator]MSP[N] return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.CRCR3Mutator]MSP[S] if ( typeArguments == null ) {
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[InlineConstantMutator]MSP[S] toComponentType , typeVarAssigns ) ; }
if ( type instanceof Class < ? > ) { final Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray () ? clazz . getComponentType () : null ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR1Mutator]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[rv.CRCR3Mutator]MSP[N] return false ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[ReturnValsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[rv.CRCR3Mutator]MSP[N] toComponentType , typeVarAssigns ) ; }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
private static boolean equals ( final WildcardType w , final Type t ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; } MST[experimental.NakedReceiverMutator]MSP[N]
private static StringBuilder appendAllTo ( final StringBuilder buf , final String sep , final Type ... types ) { MST[NonVoidMethodCallMutator]MSP[N] Validate . notEmpty ( Validate . noNullElements ( types ) ) ; if ( types . length > 0 ) {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buf . insert ( 0 , c . getName () ) ; break; }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.CRCR1Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[NonVoidMethodCallMutator]MSP[S]
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[NegateConditionalsMutator]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.ROR2Mutator]MSP[S]
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; MST[rv.CRCR4Mutator]MSP[N] if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
return parameterizeWithOwner ( p . getOwnerType () , ( Class < ? > ) p . getRawType () , args ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ;
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; MST[NonVoidMethodCallMutator]MSP[S] final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.ABSMutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ABSMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
throw new IllegalStateException ( lr_12 + rawType ) ; } return ( Class < ? > ) rawType ; MST[rv.ROR5Mutator]MSP[N] } public static Class < ? > getRawType ( final Type type , final Type assigningType ) { if ( type instanceof Class < ? > ) {
if ( lowerBounds . length > 1 || lowerBounds . length == 1 && lowerBounds [ 0 ] != null ) { appendAllTo ( buf . append ( lr_25 ) , lr_24 , lowerBounds ) ; MST[NonVoidMethodCallMutator]MSP[N]
return new GenericArrayTypeImpl ( Validate . notNull ( componentType , lr_20 ) ) ; } @SuppressWarnings ( lr_1 ) MST[BooleanFalseReturnValsMutator]MSP[N] public static boolean equals ( final Type t1 , final Type t2 ) { if ( ObjectUtils . equals ( t1 , t2 ) ) { return true ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; MST[NonVoidMethodCallMutator]MSP[N] if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; MST[rv.ROR2Mutator]MSP[N] } } return true ; } return false ; }
return types . toArray ( new Type [ types . size () ] ) ; } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { MST[rv.CRCR6Mutator]MSP[S] Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; MST[rv.ROR3Mutator]MSP[N] } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[rv.ROR1Mutator]MSP[N] } else {
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[ReturnValsMutator]MSP[S]
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR6Mutator]MSP[S] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.ROR3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[InlineConstantMutator]MSP[N]
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.UOI4Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI3Mutator]MSP[N] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[NegateConditionalsMutator]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
if ( cls . equals ( superClass ) ) { return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; MST[NullReturnValsMutator]MSP[N] if ( midType instanceof Class < ? > ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[NonVoidMethodCallMutator]MSP[S] } return null ; }
: new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; } final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[ConstructorCallMutator]MSP[N] final TypeVariable < ? > [] typeParams = cls . getTypeParameters () ;
return value == null ? ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) . isPrimitive () MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] : isAssignable ( value . getClass () , type , null ) ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI4Mutator]MSP[S] if ( typeArguments == null ) {
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( toClass . equals ( type ) ) { return true ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR2Mutator]MSP[N] } } return null ; }
useOwner = raw . getEnclosingClass () ; } else { MST[InlineConstantMutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[BooleanTrueReturnValsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } MST[NonVoidMethodCallMutator]MSP[N] break; } while ( true ); return result ; }
} static boolean isArrayType ( final Type type ) { MST[NonVoidMethodCallMutator]MSP[N] return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) {
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[rv.ROR1Mutator]MSP[N] } while ( true ); return result ; }
if ( type instanceof Class < ? > ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
typeVarAssigns ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } } return true ; } private static Class < ? > getRawType ( final ParameterizedType parameterizedType ) { final Type rawType = parameterizedType . getRawType () ; if ( ! ( rawType instanceof Class < ? > ) ) {
public static String toString ( final Type type ) { MST[InlineConstantMutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( toType instanceof TypeVariable < ? > ) {
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { MST[InlineConstantMutator]MSP[N] if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
buf . append ( c . getName () ) ; } if ( c . getTypeParameters () . length > 0 ) { buf . append ( '<' ) ; appendAllTo ( buf , lr_22 , c . getTypeParameters () ) ; MST[NegateConditionalsMutator]MSP[N] buf . append ( '>' ) ; }
return buf . toString () ; MST[rv.ABSMutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
if ( type instanceof Class < ? > ) { MST[rv.ROR5Mutator]MSP[N] return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
} if ( genericInterface != null ) { MST[NegateConditionalsMutator]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[rv.CRCR6Mutator]MSP[S] return false ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR3Mutator]MSP[N] }
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR5Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[rv.ROR1Mutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
return buf . toString () ; MST[rv.ROR1Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; MST[NonVoidMethodCallMutator]MSP[N] }
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.ROR3Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[NonVoidMethodCallMutator]MSP[N] final Type ... typeArguments ) {
buf . append ( '.' ) . append ( raw . getSimpleName () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } appendAllTo ( buf . append ( '<' ) , lr_22 , typeArguments ) . append ( '>' ) ; return buf . toString () ; }
if ( toWildcardType . equals ( type ) ) { return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; MST[rv.ROR3Mutator]MSP[N] final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } } return null ; MST[rv.ROR5Mutator]MSP[N] }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR2Mutator]MSP[S] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( toClass . equals ( cls ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[rv.ROR4Mutator]MSP[S] } } return false ; }
useOwner = raw . getEnclosingClass () ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[rv.ROR4Mutator]MSP[S] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR4Mutator]MSP[N]
: new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; } final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final TypeVariable < ? > [] typeParams = cls . getTypeParameters () ;
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR2Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI1Mutator]MSP[S] } return null ; }
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[rv.CRCR3Mutator]MSP[N]
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI3Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR1Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
public static < T > Typed < T > wrap ( final Class < T > type ) { return TypeUtils . <T > wrap ( ( Type ) type ) ; } private static String classToString ( final Class < ? > c ) { MST[ReturnValsMutator]MSP[N]
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , MST[NonVoidMethodCallMutator]MSP[N] toComponentType , typeVarAssigns ) ; }
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; MST[rv.CRCR6Mutator]MSP[N] for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) {
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.UOI3Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
if ( containsTypeVariables ( arg ) ) { MST[ReturnValsMutator]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR2Mutator]MSP[N]
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[NegateConditionalsMutator]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
} if ( genericInterface != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR1Mutator]MSP[N]
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[rv.ROR5Mutator]MSP[N]
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( toType instanceof TypeVariable < ? > ) {
if ( containsTypeVariables ( arg ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[ReturnValsMutator]MSP[N] if ( t1 . length == t2 . length ) {
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR4Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
final Class < ? > raw = ( Class < ? > ) p . getRawType () ; final Type [] typeArguments = p . getActualTypeArguments () ; if ( useOwner == null ) { buf . append ( raw . getName () ) ; } else { MST[ConstructorCallMutator]MSP[N]
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , MST[NonVoidMethodCallMutator]MSP[N] toClass , typeVarAssigns ) ;
return buf . toString () ; MST[rv.UOI2Mutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] && ! toTypeArg . equals ( fromTypeArg )
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR5Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return types . toArray ( new Type [ types . size () ] ) ; } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { MST[rv.CRCR1Mutator]MSP[N] Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
private static boolean equals ( final WildcardType w , final Type t ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
if ( type instanceof WildcardType ) { MST[ReturnValsMutator]MSP[N] for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) {
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) { MST[rv.ROR2Mutator]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[InlineConstantMutator]MSP[S] return false ; }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; MST[InlineConstantMutator]MSP[N] break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR4Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[ConstructorCallMutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
: new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; } final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[NegateConditionalsMutator]MSP[N] final TypeVariable < ? > [] typeParams = cls . getTypeParameters () ;
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR4Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI1Mutator]MSP[S] if ( typeArguments == null ) {
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[experimental.NakedReceiverMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.CRCR3Mutator]MSP[S]
private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , final Class < ? > toClass , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.CRCR6Mutator]MSP[S]
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR3Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR4Mutator]MSP[N] }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( toGenericArrayType . equals ( type ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR5Mutator]MSP[N] final Type ... typeArguments ) {
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[rv.ROR5Mutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[rv.ROR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.ROR1Mutator]MSP[S] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private static boolean equals ( final ParameterizedType p , final Type t ) { if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
return types . toArray ( new Type [ types . size () ] ) ; MST[rv.UOI1Mutator]MSP[N] } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR4Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[NegateConditionalsMutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[InlineConstantMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI4Mutator]MSP[N]
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[rv.ROR3Mutator]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } return getRawType ( typeArgument , assigningType ) ; MST[rv.ROR5Mutator]MSP[S]
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[NonVoidMethodCallMutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; MST[rv.ROR3Mutator]MSP[N] } public static String toLongString ( final TypeVariable < ? > var ) {
private static String wildcardTypeToString ( final WildcardType w ) { final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; MST[NonVoidMethodCallMutator]MSP[N] final Type [] upperBounds = w . getUpperBounds () ;
Validate . notNull ( raw , lr_13 ) ; final Type useOwner ; if ( raw . getEnclosingClass () == null ) { Validate . isTrue ( owner == null , lr_15 , raw ) ; useOwner = null ; MST[NonVoidMethodCallMutator]MSP[S] } else if ( owner == null ) {
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR6Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI1Mutator]MSP[N] if ( t1 . length == t2 . length ) {
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { MST[rv.ROR1Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) {
buf . append ( c . getName () ) ; } if ( c . getTypeParameters () . length > 0 ) { buf . append ( '<' ) ; appendAllTo ( buf , lr_22 , c . getTypeParameters () ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( '>' ) ; }
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > () MST[ArgumentPropagationMutator]MSP[N]
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[rv.CRCR6Mutator]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < args . length ; i ++ ) { final Type unrolled = unrollVariables ( parameterizedTypeArguments , args [ i ] ) ; if ( unrolled != null ) { args [ i ] = unrolled ; MST[NonVoidMethodCallMutator]MSP[S] } }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR2Mutator]MSP[N] final Type ... typeArguments ) {
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR1Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( toParameterizedType . equals ( type ) ) { return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ; MST[NonVoidMethodCallMutator]MSP[N]
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR1Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static String toLongString ( final TypeVariable < ? > var ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[VoidMethodCallMutator]MSP[N] }
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] + type ) ; } return replacementType ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
result |= Arrays . hashCode ( lowerBounds ) ; return result ; } public static boolean isAssignable ( final Type type , final Type toType ) { return isAssignable ( type , toType , null ) ; MST[ReturnValsMutator]MSP[N] }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( t1 instanceof ParameterizedType ) { MST[rv.ROR3Mutator]MSP[N] return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; }
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; MST[rv.ROR5Mutator]MSP[N] } if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
if ( toParameterizedType . equals ( type ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
return cls . isArray () MST[rv.ROR5Mutator]MSP[N] && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
if ( cls . equals ( superClass ) ) { MST[NegateConditionalsMutator]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[InlineConstantMutator]MSP[S] return false ; }
return ( ( GenericArrayType ) type ) . getGenericComponentType () ; } return null ; } public static Type unrollVariables ( Map < TypeVariable < ? > , Type > typeArguments , final Type type ) { MST[rv.UOI4Mutator]MSP[S] if ( typeArguments == null ) {
if ( toParameterizedType . equals ( type ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
return buf . toString () ; MST[NegateConditionalsMutator]MSP[S] } private static String genericArrayTypeToString ( final GenericArrayType g ) { return String . format ( lr_26 , toString ( g . getGenericComponentType () ) ) ; }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR5Mutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( cls . equals ( superClass ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return getTypeArguments ( superType , superClass , null ) ; } final Type midType = getClosestParentType ( cls , superClass ) ; if ( midType instanceof Class < ? > ) {
return null ; } if ( cls . isPrimitive () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[rv.ROR4Mutator]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[rv.ROR4Mutator]MSP[N] } while ( true ); return result ; }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR1Mutator]MSP[S] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
result [ index ++ ] = mappings . get ( var ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } public static WildcardTypeBuilder wildcardType () { return new WildcardTypeBuilder () ; } public static GenericArrayType genericArrayType ( final Type componentType ) {
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; MST[rv.ROR5Mutator]MSP[S] } } return null ; }
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.ROR3Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final Class < ? > cls = getRawType ( parameterizedType ) ; if ( ! isAssignable ( cls , toClass ) ) { return null ; } final Type ownerType = parameterizedType . getOwnerType () ; MST[NonVoidMethodCallMutator]MSP[N] Map < TypeVariable < ? > , Type > typeVarAssigns ;
final TypeVariable < ? > typeVar = entry . getKey () ; MST[InlineConstantMutator]MSP[N] final Type type = entry . getValue () ; for ( final Type bound : getImplicitBounds ( typeVar ) ) { if ( ! isAssignable ( type , substituteTypeVariables ( bound , typeVarAssigns ) ,
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { MST[rv.CRCR1Mutator]MSP[N] toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) {
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[NonVoidMethodCallMutator]MSP[S]
private static boolean equals ( final WildcardType w , final Type t ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
if ( type instanceof GenericArrayType ) { return genericArrayTypeToString ( ( GenericArrayType ) type ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[InlineConstantMutator]MSP[N] final Type ... typeArguments ) {
public static String toString ( final Type type ) { MST[rv.CRCR1Mutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( toType instanceof GenericArrayType ) {
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR5Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
for ( int i = 0 ; i < t1 . length ; i ++ ) { if ( ! equals ( t1 [ i ] , t2 [ i ] ) ) { return false ; MST[rv.ROR5Mutator]MSP[N] } } return true ; } return false ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[VoidMethodCallMutator]MSP[N]
public static boolean containsTypeVariables ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.ROR5Mutator]MSP[S]
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[rv.ROR2Mutator]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final Type bound : upperBounds ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR3Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] && ! toTypeArg . equals ( fromTypeArg )
private static String wildcardTypeToString ( final WildcardType w ) { MST[InlineConstantMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return null ; } if ( cls . isPrimitive () ) { MST[rv.ROR5Mutator]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.UOI4Mutator]MSP[N] if ( t1 . length == t2 . length ) {
if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR5Mutator]MSP[N] for ( final Type bound : ( ( TypeVariable < ? > ) type ) . getBounds () ) { if ( isAssignable ( bound , toClass ) ) { return true ; } } return false ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( equals ( p . getRawType () , other . getRawType () ) && equals ( p . getOwnerType () , other . getOwnerType () ) ) { return equals ( p . getActualTypeArguments () , other . getActualTypeArguments () ) ; MST[NegateConditionalsMutator]MSP[N] } } return false ; }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
public static boolean containsTypeVariables ( final Type type ) { MST[BooleanFalseReturnValsMutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR5Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 + type ) ; } return replacementType ; MST[rv.ROR5Mutator]MSP[S] }
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR5Mutator]MSP[N] }
for ( final TypeVariable < ? > var : toTypeVarAssigns . keySet () ) { final Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; final Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; if ( fromTypeArg != null MST[NegateConditionalsMutator]MSP[N] && ! toTypeArg . equals ( fromTypeArg )
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; MST[rv.ROR2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; } else {
final ParameterizedType superType ) { Validate . notNull ( cls , lr_4 ) ; Validate . notNull ( superType , lr_5 ) ; final Class < ? > superClass = getRawType ( superType ) ; if ( ! isAssignable ( cls , superClass ) ) { MST[rv.CRCR5Mutator]MSP[N] return null ; }
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[rv.ROR1Mutator]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; } MST[experimental.NakedReceiverMutator]MSP[S]
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[rv.ROR4Mutator]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
: new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; } final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[ConstructorCallMutator]MSP[N] final TypeVariable < ? > [] typeParams = cls . getTypeParameters () ;
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] }
if ( type instanceof Class < ? > ) { final Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray () ? clazz . getComponentType () : null ; } if ( type instanceof GenericArrayType ) { MST[NegateConditionalsMutator]MSP[N]
return ( ( Class < ? > ) type ) . getTypeParameters () . length > 0 ; } MST[InlineConstantMutator]MSP[N] if ( type instanceof ParameterizedType ) { for ( final Type arg : ( ( ParameterizedType ) type ) . getActualTypeArguments () ) {
return types . toArray ( new Type [ types . size () ] ) ; } public static Type [] getImplicitBounds ( final TypeVariable < ? > typeVariable ) { MST[InlineConstantMutator]MSP[N] Validate . notNull ( typeVariable , lr_9 ) ; final Type [] bounds = typeVariable . getBounds () ;
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR3Mutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { MST[ArgumentPropagationMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ABSMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( result instanceof TypeVariable < ? > && ! result . equals ( var ) ) { var = ( TypeVariable < ? > ) result ; continue; } break; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } while ( true ); return result ; }
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; MST[ReturnValsMutator]MSP[N] } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , typeVarAssigns ) ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.CRCR3Mutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { MST[BooleanTrueReturnValsMutator]MSP[N] if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { MST[rv.UOI3Mutator]MSP[N] subtypeFound = true ; break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[rv.CRCR1Mutator]MSP[N] final Type ... typeArguments ) {
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { MST[rv.UOI1Mutator]MSP[N] return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
if ( ownerType instanceof ParameterizedType ) { final ParameterizedType parameterizedOwnerType = ( ParameterizedType ) ownerType ; typeVarAssigns = getTypeArguments ( parameterizedOwnerType , getRawType ( parameterizedOwnerType ) , subtypeVarAssigns ) ; MST[NegateConditionalsMutator]MSP[N] } else { typeVarAssigns = subtypeVarAssigns == null ? new HashMap < TypeVariable < ? > , Type > ()
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.ROR1Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
useOwner = raw . getEnclosingClass () ; } else { Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ; MST[rv.CRCR2Mutator]MSP[S]
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; } if ( toClass == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( toClass . equals ( type ) ) { return true ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.CRCR5Mutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
public static boolean containsTypeVariables ( final Type type ) { MST[NegateConditionalsMutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[NegateConditionalsMutator]MSP[N] if ( assigningType == null ) { return null ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.CRCR1Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
final ParameterizedType parameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { final Type ownerType = parameterizedType . getOwnerType () ; if ( ownerType instanceof ParameterizedType ) { mapTypeVariablesToArguments ( cls , ( ParameterizedType ) ownerType , typeVarAssigns ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toGenericArrayType == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[rv.ROR2Mutator]MSP[N] } public static Map < TypeVariable < ? > , Type > determineTypeArguments ( final Class < ? > cls ,
return buf . toString () ; } private static String typeVariableToString ( final TypeVariable < ? > v ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final StringBuilder buf = new StringBuilder ( v . getName () ) ; final Type [] bounds = v . getBounds () ;
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } if ( toParameterizedType == null ) { return false ; }
if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType () ; MST[rv.ROR3Mutator]MSP[N] if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ;
&& ! ( toTypeArg instanceof WildcardType && isAssignable ( fromTypeArg , toTypeArg , typeVarAssigns ) ) ) { return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } return true ; }
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { if ( t1 . length == t2 . length ) {
return wildcardType () . withUpperBounds ( unrollBounds ( typeArguments , wild . getUpperBounds () ) ) MST[ReturnValsMutator]MSP[S] . withLowerBounds ( unrollBounds ( typeArguments , wild . getLowerBounds () ) ) . build () ; } } return type ; }
final Type [] typeArgs = parameterizedType . getActualTypeArguments () ; MST[NegateConditionalsMutator]MSP[S] final TypeVariable < ? > [] typeVars = getRawType ( parameterizedType ) . getTypeParameters () ; final List < TypeVariable < Class < T > > > typeVarList = Arrays . asList ( cls . getTypeParameters () ) ;
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 MST[NonVoidMethodCallMutator]MSP[N] + lr_7 + midType ) ; } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI4Mutator]MSP[N]
if ( type instanceof Class < ? > ) { return ClassUtils . isAssignable ( ( Class < ? > ) type , toClass ) ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return isAssignable ( getRawType ( ( ParameterizedType ) type ) , toClass ) ; }
for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } MST[rv.UOI4Mutator]MSP[N] } return null ; }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[NegateConditionalsMutator]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
private static String wildcardTypeToString ( final WildcardType w ) { MST[experimental.NakedReceiverMutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } MST[rv.UOI1Mutator]MSP[N] return false ; }
if ( type1 != type2 && isAssignable ( type2 , type1 , null ) ) { subtypeFound = true ; MST[rv.CRCR1Mutator]MSP[N] break; } } if ( ! subtypeFound ) { types . add ( type1 ) ; } }
Class < ? > c = ( Class < ? > ) d ; while ( true ) { if ( c . getEnclosingClass () == null ) { buf . insert ( 0 , c . getName () ) ; break; } MST[NegateConditionalsMutator]MSP[N]
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[experimental.NakedReceiverMutator]MSP[S]
} static boolean isArrayType ( final Type type ) { return type instanceof GenericArrayType || type instanceof Class < ? > && ( ( Class < ? > ) type ) . isArray () ; } public static Type getArrayComponentType ( final Type type ) { MST[rv.ROR4Mutator]MSP[S]
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[NegateConditionalsMutator]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } else {
final Set < Type > types = new HashSet < Type > ( bounds . length ) ; for ( final Type type1 : bounds ) { boolean subtypeFound = false ; for ( final Type type2 : bounds ) { MST[ConstructorCallMutator]MSP[N]
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[rv.CRCR3Mutator]MSP[N] if ( t1 . length == t2 . length ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.CRCR6Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR4Mutator]MSP[N] }
private static String wildcardTypeToString ( final WildcardType w ) { MST[rv.UOI4Mutator]MSP[S] final StringBuilder buf = new StringBuilder () . append ( '?' ) ; final Type [] lowerBounds = w . getLowerBounds () ; final Type [] upperBounds = w . getUpperBounds () ;
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[rv.CRCR1Mutator]MSP[N] }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.CRCR3Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg ) MST[rv.UOI3Mutator]MSP[S]
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType ,
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR1Mutator]MSP[N] return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
return getTypeArguments ( ( Class < ? > ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof ParameterizedType ) { return getTypeArguments ( ( ParameterizedType ) type , toClass , subtypeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { MST[rv.ROR5Mutator]MSP[N]
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[NegateConditionalsMutator]MSP[S] + type ) ; } return replacementType ; }
public static boolean containsTypeVariables ( final Type type ) { MST[ReturnValsMutator]MSP[S] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
public static boolean containsTypeVariables ( final Type type ) { MST[rv.ROR2Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
if ( type instanceof ParameterizedType ) { final ParameterizedType p = ( ParameterizedType ) type ; final Map < TypeVariable < ? > , Type > parameterizedTypeArguments ; if ( p . getOwnerType () == null ) { parameterizedTypeArguments = typeArguments ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } else {
if ( type instanceof GenericArrayType ) { MST[rv.ROR2Mutator]MSP[N] return genericArrayTypeToString ( ( GenericArrayType ) type ) ; } throw new IllegalArgumentException ( ObjectUtils . identityToString ( type ) ) ; } public static String toLongString ( final TypeVariable < ? > var ) {
if ( type instanceof WildcardType ) { for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } } return false ; }
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[rv.ROR5Mutator]MSP[S] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( ! isAssignable ( toBound , bound , typeVarAssigns ) ) { return false ; } } } return true ; } for ( final Type toBound : toUpperBounds ) { if ( ! isAssignable ( type , substituteTypeVariables ( toBound , typeVarAssigns ) , MST[rv.CRCR2Mutator]MSP[S] typeVarAssigns ) ) {
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR3Mutator]MSP[S] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return null ; } if ( cls . isPrimitive () ) { MST[rv.ROR2Mutator]MSP[N] if ( toClass . isPrimitive () ) { return new HashMap < TypeVariable < ? > , Type > () ; } cls = ClassUtils . primitiveToWrapper ( cls ) ; }
if ( fromTypeVarAssigns == null ) { return false ; } if ( fromTypeVarAssigns . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } final Map < TypeVariable < ? > , Type > toTypeVarAssigns = getTypeArguments ( toParameterizedType , toClass , typeVarAssigns ) ;
final Object genericDeclaration = ( ( TypeVariable < ? > ) type ) . getGenericDeclaration () ; if ( ! ( genericDeclaration instanceof Class < ? > ) ) { return null ; } final Map < TypeVariable < ? > , Type > typeVarAssigns = getTypeArguments ( assigningType , MST[rv.ROR3Mutator]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.CRCR5Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return isAssignable ( type , ( Class < ? > ) toType ) ; } if ( toType instanceof ParameterizedType ) { MST[rv.ROR5Mutator]MSP[N] return isAssignable ( type , ( ParameterizedType ) toType , typeVarAssigns ) ; } if ( toType instanceof GenericArrayType ) {
for ( int i = 0 ; i < typeArgs . length ; i ++ ) { final TypeVariable < ? > typeVar = typeVars [ i ] ; MST[NonVoidMethodCallMutator]MSP[S] final Type typeArg = typeArgs [ i ] ; if ( typeVarList . contains ( typeArg )
} if ( genericInterface != null ) { MST[rv.ROR4Mutator]MSP[N] return genericInterface ; } } return cls . getGenericSuperclass () ; } public static boolean isInstance ( final Object value , final Type type ) { if ( type == null ) { return false ; }
return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getRawType ( ( ParameterizedType ) type ) ; } if ( type instanceof TypeVariable < ? > ) { MST[rv.ROR1Mutator]MSP[N] if ( assigningType == null ) { return null ; }
if ( type instanceof TypeVariable < ? > ) { for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { MST[ReturnValsMutator]MSP[S] if ( isAssignable ( bound , toClass ) ) { return getTypeArguments ( bound , toClass , subtypeVarAssigns ) ; } }
return parameterizedTypeToString ( ( ParameterizedType ) type ) ; } if ( type instanceof WildcardType ) { return wildcardTypeToString ( ( WildcardType ) type ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( type instanceof TypeVariable < ? > ) { return typeVariableToString ( ( TypeVariable < ? > ) type ) ; }
parameterizedTypeArguments = new HashMap < TypeVariable < ? > , Type > ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Type [] args = p . getActualTypeArguments () ;
return parameterizeWithOwner ( owner , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } private static Type [] extractTypeArgumentsFrom ( final Map < TypeVariable < ? > , Type > mappings , final TypeVariable < ? > [] variables ) { MST[NonVoidMethodCallMutator]MSP[N]
public static String toString ( final Type type ) { Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.UOI2Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
if ( t1 instanceof ParameterizedType ) { return equals ( ( ParameterizedType ) t1 , t2 ) ; } if ( t1 instanceof GenericArrayType ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return equals ( ( GenericArrayType ) t1 , t2 ) ; } if ( t1 instanceof WildcardType ) {
&& equals ( getImplicitUpperBounds ( w ) , getImplicitUpperBounds ( other ) ) ; } return false ; } private static boolean equals ( final Type [] t1 , final Type [] t2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( t1 . length == t2 . length ) {
midClass = ( Class < ? > ) midType ; } else { throw new IllegalStateException ( lr_6 + lr_7 + midType ) ; MST[rv.ROR4Mutator]MSP[N] } if ( isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass ) ) { genericInterface = midType ; }
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
buf . insert ( 0 , c . getSimpleName () ) . insert ( 0 , '.' ) ; c = c . getEnclosingClass () ; } } @Override public Type getType () { return type ; MST[ReturnValsMutator]MSP[N] }
( Class < ? > ) genericDeclaration ) ; if ( typeVarAssigns == null ) { return null ; } final Type typeArgument = typeVarAssigns . get ( type ) ; if ( typeArgument == null ) { return null ; } MST[ArgumentPropagationMutator]MSP[S] return getRawType ( typeArgument , assigningType ) ;
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; MST[rv.ROR1Mutator]MSP[N] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] )
return getTypeArguments ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toClass . isArray () ? toClass . getComponentType () : toClass , subtypeVarAssigns ) ; } if ( type instanceof WildcardType ) { MST[rv.ROR4Mutator]MSP[S]
private static boolean isAssignable ( final Type type , final Type toType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( toType == null || toType instanceof Class < ? > ) { MST[rv.ROR5Mutator]MSP[N]
final Type [] upperBounds = getImplicitUpperBounds ( wildcardType ) ; final Type [] lowerBounds = getImplicitLowerBounds ( wildcardType ) ; for ( Type toBound : toUpperBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : upperBounds ) { MST[rv.UOI1Mutator]MSP[N]
return buf . toString () ; } private static String parameterizedTypeToString ( final ParameterizedType p ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final StringBuilder buf = new StringBuilder () ; final Type useOwner = p . getOwnerType () ;
if ( containsTypeVariables ( arg ) ) { return true ; } } return false ; } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ; return containsTypeVariables ( TypeUtils . getImplicitLowerBounds ( wild ) [ 0 ] ) MST[rv.CRCR3Mutator]MSP[N]
if ( type == null ) { return toClass == null || ! toClass . isPrimitive () ; MST[rv.ROR4Mutator]MSP[N] } if ( toClass == null ) { return false ; } if ( toClass . equals ( type ) ) { return true ; }
&& typeVarAssigns . containsKey ( typeVar ) ) { MST[rv.ABSMutator]MSP[N] typeVarAssigns . put ( ( TypeVariable < ? > ) typeArg , typeVarAssigns . get ( typeVar ) ) ; } } }
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
return equals ( ( WildcardType ) t1 , t2 ) ; } return false ; } private static boolean equals ( final ParameterizedType p , final Type t ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( t instanceof ParameterizedType ) { final ParameterizedType other = ( ParameterizedType ) t ;
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI4Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return parameterizeWithOwner ( p . getOwnerType () , ( Class < ? > ) p . getRawType () , args ) ; MST[NegateConditionalsMutator]MSP[S] } if ( type instanceof WildcardType ) { final WildcardType wild = ( WildcardType ) type ;
return false ; } } for ( final Type toBound : toLowerBounds ) { if ( ! isAssignable ( substituteTypeVariables ( toBound , typeVarAssigns ) , type , typeVarAssigns ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
public static boolean containsTypeVariables ( final Type type ) { MST[rv.UOI1Mutator]MSP[N] if ( type instanceof TypeVariable < ? > ) { return true ; } if ( type instanceof Class < ? > ) {
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[ArgumentPropagationMutator]MSP[N] }
public static String toString ( final Type type ) { MST[ReturnValsMutator]MSP[N] Validate . notNull ( type ) ; if ( type instanceof Class < ? > ) { return classToString ( ( Class < ? > ) type ) ; } if ( type instanceof ParameterizedType ) {
static boolean isAssignable ( final Type type , final WildcardType toWildcardType , MST[NegateConditionalsMutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toWildcardType == null ) { return false ; }
private static boolean equals ( final WildcardType w , final Type t ) { MST[rv.ROR4Mutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
private static Type getClosestParentType ( final Class < ? > cls , final Class < ? > superClass ) { MST[rv.ROR2Mutator]MSP[N] if ( superClass . isInterface () ) { final Type [] interfaceTypes = cls . getGenericInterfaces () ; Type genericInterface = null ;
private static boolean equals ( final WildcardType w , final Type t ) { MST[NonVoidMethodCallMutator]MSP[N] if ( t instanceof WildcardType ) { final WildcardType other = ( WildcardType ) t ; return equals ( getImplicitLowerBounds ( w ) , getImplicitLowerBounds ( other ) )
return null ; } static Map < TypeVariable < ? > , Type > getTypeArguments ( MST[rv.UOI2Mutator]MSP[N] final ParameterizedType parameterizedType , final Class < ? > toClass , final Map < TypeVariable < ? > , Type > subtypeVarAssigns ) {
if ( toWildcardType . equals ( type ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } final Type [] toUpperBounds = getImplicitUpperBounds ( toWildcardType ) ; final Type [] toLowerBounds = getImplicitLowerBounds ( toWildcardType ) ; if ( type instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) type ;
if ( ! isAssignable ( bound , toBound , typeVarAssigns ) ) { return false ; } } } for ( Type toBound : toLowerBounds ) { toBound = substituteTypeVariables ( toBound , typeVarAssigns ) ; for ( final Type bound : lowerBounds ) { MST[rv.UOI1Mutator]MSP[N]
if ( type instanceof TypeVariable < ? > && typeVarAssigns != null ) { final Type replacementType = typeVarAssigns . get ( type ) ; if ( replacementType == null ) { throw new IllegalArgumentException ( lr_3 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] + type ) ; } return replacementType ; }
public static Type [] normalizeUpperBounds ( final Type [] bounds ) { MST[rv.CRCR4Mutator]MSP[N] Validate . notNull ( bounds , lr_8 ) ; if ( bounds . length < 2 ) { return bounds ; }
public static boolean typesSatisfyVariables ( final Map < TypeVariable < ? > , Type > typeVarAssigns ) { MST[rv.UOI3Mutator]MSP[S] Validate . notNull ( typeVarAssigns , lr_11 ) ; for ( final Map . Entry < TypeVariable < ? > , Type > entry : typeVarAssigns . entrySet () ) {
return isAssignable ( type , ( GenericArrayType ) toType , typeVarAssigns ) ; } if ( toType instanceof WildcardType ) { MST[rv.ROR3Mutator]MSP[N] return isAssignable ( type , ( WildcardType ) toType , typeVarAssigns ) ; } if ( toType instanceof TypeVariable < ? > ) {
private static boolean isAssignable ( final Type type , final ParameterizedType toParameterizedType , MST[rv.ROR4Mutator]MSP[N] final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type == null ) { return true ; } if ( toParameterizedType == null ) { return false ; }
return cls . isArray () && isAssignable ( cls . getComponentType () , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType () , toComponentType , typeVarAssigns ) ; } MST[rv.ROR2Mutator]MSP[N]
|| containsTypeVariables ( TypeUtils . getImplicitUpperBounds ( wild ) [ 0 ] ) ; } return false ; } public static final ParameterizedType parameterize ( final Class < ? > raw , final Type ... typeArguments ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return parameterizeWithOwner ( null , raw , typeArguments ) ; }
return determineTypeArguments ( ( Class < ? > ) midType , superType ) ; } final ParameterizedType midParameterizedType = ( ParameterizedType ) midType ; MST[rv.ROR5Mutator]MSP[N] final Class < ? > midClass = getRawType ( midParameterizedType ) ;
return parameterizeWithOwner ( null , raw , extractTypeArgumentsFrom ( typeArgMappings , raw . getTypeParameters () ) ) ; } public static final ParameterizedType parameterizeWithOwner ( final Type owner , final Class < ? > raw , MST[InlineConstantMutator]MSP[N] final Type ... typeArguments ) {
final Map < TypeVariable < ? > , Type > typeVarAssigns = determineTypeArguments ( midClass , superType ) ; mapTypeVariablesToArguments ( cls , midParameterizedType , typeVarAssigns ) ; return typeVarAssigns ; } private static < T > void mapTypeVariablesToArguments ( final Class < T > cls , MST[NonVoidMethodCallMutator]MSP[S]
useOwner = raw . getEnclosingClass () ; } else { MST[rv.CRCR1Mutator]MSP[N] Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , lr_16 , owner , raw ) ; useOwner = owner ; } Validate . noNullElements ( typeArguments , lr_17 ) ;
Validate . isTrue ( raw . getTypeParameters () . length == typeArguments . length , lr_18 , raw . getTypeParameters () . length , typeArguments . length ) ; return new ParameterizedTypeImpl ( raw , useOwner , typeArguments ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
final StringBuilder buf = new StringBuilder () ; if ( c . getEnclosingClass () != null ) { buf . append ( classToString ( c . getEnclosingClass () ) ) . append ( '.' ) . append ( c . getSimpleName () ) ; } else { MST[NonVoidMethodCallMutator]MSP[S]
. get ( typeArg ) : typeArg ) ; } if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( toParameterizedType . equals ( type ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } final Class < ? > toClass = getRawType ( toParameterizedType ) ; final Map < TypeVariable < ? > , Type > fromTypeVarAssigns = getTypeArguments ( type , toClass , null ) ;
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI4Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
for ( final Type midType : interfaceTypes ) { Class < ? > midClass = null ; if ( midType instanceof ParameterizedType ) { midClass = getRawType ( ( ParameterizedType ) midType ) ; MST[rv.UOI3Mutator]MSP[N] } else if ( midType instanceof Class < ? > ) {
Validate . notNull ( raw , lr_13 ) ; final Type useOwner ; if ( raw . getEnclosingClass () == null ) { Validate . isTrue ( owner == null , lr_15 , raw ) ; useOwner = null ; MST[rv.CRCR1Mutator]MSP[N] } else if ( owner == null ) {
public WildcardTypeBuilder withUpperBounds ( final Type ... bounds ) { this . upperBounds = bounds ; return this ; } public WildcardTypeBuilder withLowerBounds ( final Type ... bounds ) { MST[NullReturnValsMutator]MSP[N] this . lowerBounds = bounds ; return this ; } @Override public WildcardType build () {
return new WildcardTypeImpl ( upperBounds , lowerBounds ) ; } MST[ConstructorCallMutator]MSP[N] @Override public Type getGenericComponentType () { return componentType ; } @Override public String toString () { return TypeUtils . toString ( this ) ; } @Override public boolean equals ( final Object obj ) {
return new WildcardTypeImpl ( upperBounds , lowerBounds ) ; } MST[ReturnValsMutator]MSP[N] @Override public Type getGenericComponentType () { return componentType ; } @Override public String toString () { return TypeUtils . toString ( this ) ; } @Override public boolean equals ( final Object obj ) {
public WildcardTypeBuilder withUpperBounds ( final Type ... bounds ) { this . upperBounds = bounds ; return this ; } public WildcardTypeBuilder withLowerBounds ( final Type ... bounds ) { MST[ReturnValsMutator]MSP[N] this . lowerBounds = bounds ; return this ; } @Override public WildcardType build () {
public WildcardTypeBuilder withUpperBounds ( final Type ... bounds ) { this . upperBounds = bounds ; return this ; MST[experimental.MemberVariableMutator]MSP[N] } public WildcardTypeBuilder withLowerBounds ( final Type ... bounds ) { this . lowerBounds = bounds ; return this ; } @Override public WildcardType build () {
public WildcardTypeBuilder withUpperBounds ( final Type ... bounds ) { MST[NullReturnValsMutator]MSP[N] this . upperBounds = bounds ; return this ; } public WildcardTypeBuilder withLowerBounds ( final Type ... bounds ) { this . lowerBounds = bounds ; return this ; } @Override public WildcardType build () {
return new WildcardTypeImpl ( upperBounds , lowerBounds ) ; } MST[NullReturnValsMutator]MSP[N] @Override public Type getGenericComponentType () { return componentType ; } @Override public String toString () { return TypeUtils . toString ( this ) ; } @Override public boolean equals ( final Object obj ) {
public WildcardTypeBuilder withUpperBounds ( final Type ... bounds ) { this . upperBounds = bounds ; return this ; } public WildcardTypeBuilder withLowerBounds ( final Type ... bounds ) { this . lowerBounds = bounds ; return this ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public WildcardType build () {
public WildcardTypeBuilder withUpperBounds ( final Type ... bounds ) { MST[ReturnValsMutator]MSP[N] this . upperBounds = bounds ; return this ; } public WildcardTypeBuilder withLowerBounds ( final Type ... bounds ) { this . lowerBounds = bounds ; return this ; } @Override public WildcardType build () {
