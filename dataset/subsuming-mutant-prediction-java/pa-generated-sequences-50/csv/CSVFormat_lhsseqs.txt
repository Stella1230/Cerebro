public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; MST[ReturnValsMutator]MSP[] } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI1Mutator]MSP[]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( isLineBreak ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR1Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[InlineConstantMutator]MSP[] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR2Mutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI1Mutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR2Mutator]MSP[] return false ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
return false ; MST[rv.CRCR3Mutator]MSP[] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException (
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; MST[MathMutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( isQuoting () ) { MST[rv.ROR3Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR2Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR3Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR1Mutator]MSP[]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI4Mutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
if ( isQuoting () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD1Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI1Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[InlineConstantMutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( isLineBreak ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( this == obj ) { return true ; MST[rv.CRCR2Mutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[BooleanTrueReturnValsMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI2Mutator]MSP[] }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException (
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR2Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR1Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR4Mutator]MSP[]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD1Mutator]MSP[]
if( recordSeparator != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR1Mutator]MSP[]
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[NullReturnValsMutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[ReturnValsMutator]MSP[] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[MathMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[InlineConstantMutator]MSP[] } @Override public boolean equals ( final Object obj ) {
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR1Mutator]MSP[] int result = 1 ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR4Mutator]MSP[] int result = 1 ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR4Mutator]MSP[] sb . append ( ' ' ) ;
public CSVFormat withHeader ( final String ... header ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreEmptyLines ( final boolean ignoreEmptyLines ) {
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[]
result = prime * result + delimiter ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR4Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR1Mutator]MSP[]
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; MST[ConstructorCallMutator]MSP[] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR3Mutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
public CSVFormat withHeader ( final String ... header ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreEmptyLines ( final boolean ignoreEmptyLines ) {
if ( isQuoting () ) { MST[NonVoidMethodCallMutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[MathMutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuotePolicy ( final Quote quotePolicy ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[NegateConditionalsMutator]MSP[] if ( other . escape != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI1Mutator]MSP[]
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; MST[ConstructorCallMutator]MSP[] }
result = prime * result + delimiter ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[NegateConditionalsMutator]MSP[] sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[MathMutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI4Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! escape . equals ( other . escape ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[ReturnValsMutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[MathMutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI1Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[MathMutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI1Mutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR3Mutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.ROR5Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR1Mutator]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.UOI3Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR3Mutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI4Mutator]MSP[] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + delimiter ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[ReturnValsMutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI1Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[ReturnValsMutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuotePolicy ( final Quote quotePolicy ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[InlineConstantMutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; MST[EmptyObjectReturnValsMutator]MSP[] }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR3Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[MathMutator]MSP[]
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException (
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI1Mutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
return false ; } return true ; MST[rv.CRCR5Mutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI4Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR6Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI4Mutator]MSP[]
return header != null ? header . clone () : null ; MST[rv.ROR5Mutator]MSP[] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[NullReturnValsMutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[NonVoidMethodCallMutator]MSP[]
return false ; } return true ; MST[ReturnValsMutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI4Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[]
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR5Mutator]MSP[]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[NegateConditionalsMutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD1Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( other . commentStart != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR5Mutator]MSP[] }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI4Mutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( this == obj ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
public CSVFormat withHeader ( final String ... header ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreEmptyLines ( final boolean ignoreEmptyLines ) {
public Quote getQuotePolicy () { return quotePolicy ; MST[ReturnValsMutator]MSP[] } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[InlineConstantMutator]MSP[] }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR3Mutator]MSP[] }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR6Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[NegateConditionalsMutator]MSP[]
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_17 ) ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[ReturnValsMutator]MSP[] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD1Mutator]MSP[]
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[rv.ROR5Mutator]MSP[] sb . append ( ' ' ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[rv.ROR5Mutator]MSP[] if ( other . escape != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR6Mutator]MSP[] int result = 1 ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR4Mutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR5Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI2Mutator]MSP[] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[InlineConstantMutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD1Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NegateConditionalsMutator]MSP[] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException (
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[InlineConstantMutator]MSP[] } @Override public boolean equals ( final Object obj ) {
public Quote getQuotePolicy () { return quotePolicy ; MST[NullReturnValsMutator]MSP[] } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR3Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR1Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[InlineConstantMutator]MSP[]
result = prime * result + delimiter ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; MST[ReturnValsMutator]MSP[] } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException (
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR6Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR1Mutator]MSP[] sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR6Mutator]MSP[]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR5Mutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( isLineBreak ( escape ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.ABSMutator]MSP[] }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( delimiter != other . delimiter ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[InlineConstantMutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} else if ( ! escape . equals ( other . escape ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
if( recordSeparator != null ) { MST[NegateConditionalsMutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[ReturnValsMutator]MSP[] }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[NegateConditionalsMutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException (
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[PrimitiveReturnsMutator]MSP[] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; MST[ReturnValsMutator]MSP[] } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR4Mutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR4Mutator]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR3Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[]
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR1Mutator]MSP[] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[NegateConditionalsMutator]MSP[] return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[]
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; MST[BooleanTrueReturnValsMutator]MSP[] } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR3Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI4Mutator]MSP[] }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( other . escape != null ) { return false ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[NegateConditionalsMutator]MSP[] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( this == obj ) { return true ; MST[InlineConstantMutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( isQuoting () ) { MST[NegateConditionalsMutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; MST[PrimitiveReturnsMutator]MSP[] } public Character getEscape () { return escape ; } public String [] getHeader () {
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException (
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[NullReturnValsMutator]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR2Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR2Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuotePolicy ( final Quote quotePolicy ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[InlineConstantMutator]MSP[] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( ' ' ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( isLineBreak ( commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public boolean isQuoting () { return quoteChar != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[MathMutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI2Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return false ; } return true ; MST[rv.CRCR6Mutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR4Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI2Mutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( isLineBreak ( escape ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[MathMutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return false ; MST[rv.CRCR1Mutator]MSP[] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
if ( isLineBreak ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isQuoting () ) { MST[rv.ROR1Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[InlineConstantMutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD1Mutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return false ; MST[ReturnValsMutator]MSP[] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[MathMutator]MSP[]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( set . size () != header . length ) {
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[InlineConstantMutator]MSP[] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + delimiter ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[NonVoidMethodCallMutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[]
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[NullReturnValsMutator]MSP[] } @Override public boolean equals ( final Object obj ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[MathMutator]MSP[]
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR2Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
public boolean isQuoting () { return quoteChar != null ; MST[rv.ROR5Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD1Mutator]MSP[]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[NegateConditionalsMutator]MSP[] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[MathMutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[InlineConstantMutator]MSP[] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[InlineConstantMutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR3Mutator]MSP[]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI3Mutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR6Mutator]MSP[] }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR1Mutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR4Mutator]MSP[]
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( delimiter != other . delimiter ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR1Mutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.UOI1Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR4Mutator]MSP[]
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR5Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[MathMutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException (
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR1Mutator]MSP[]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR3Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR2Mutator]MSP[]
result = prime * result + delimiter ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.CRCR4Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[ReturnValsMutator]MSP[] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
public boolean isQuoting () { return quoteChar != null ; MST[NegateConditionalsMutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR2Mutator]MSP[] sb . append ( ' ' ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR6Mutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[rv.ROR5Mutator]MSP[] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[] } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR2Mutator]MSP[]
if ( getIgnoreSurroundingSpaces () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
if ( isLineBreak ( escape ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.ABSMutator]MSP[] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR3Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[] } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[NegateConditionalsMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI4Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.ABSMutator]MSP[] } @Override public boolean equals ( final Object obj ) {
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[NonVoidMethodCallMutator]MSP[] sb . append ( lr_7 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; MST[BooleanFalseReturnValsMutator]MSP[] } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[NegateConditionalsMutator]MSP[] return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR3Mutator]MSP[] }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR2Mutator]MSP[] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR4Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI4Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD1Mutator]MSP[]
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; MST[BooleanFalseReturnValsMutator]MSP[] } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI4Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( other . quoteChar != null ) { return false ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR6Mutator]MSP[] }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR1Mutator]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR2Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final CSVFormat other = ( CSVFormat ) obj ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR4Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[MathMutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR5Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR4Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.ABSMutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI4Mutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[ReturnValsMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[ReturnValsMutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
if ( this == obj ) { MST[NegateConditionalsMutator]MSP[] return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR2Mutator]MSP[]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR2Mutator]MSP[]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI2Mutator]MSP[]
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
return false ; MST[rv.CRCR6Mutator]MSP[] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[NegateConditionalsMutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
return header != null ? header . clone () : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR4Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR2Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[NegateConditionalsMutator]MSP[] if ( other . commentStart != null ) { return false ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; MST[EmptyObjectReturnValsMutator]MSP[] } public Character getQuoteChar () { return quoteChar ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR5Mutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
return false ; } return true ; MST[rv.CRCR3Mutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR4Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR5Mutator]MSP[] return false ;
if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI2Mutator]MSP[]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[InlineConstantMutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; MST[ReturnValsMutator]MSP[] }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[]
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[NonVoidMethodCallMutator]MSP[] if ( header != null ) { sb . append ( ' ' ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[]
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; MST[ConstructorCallMutator]MSP[] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[NegateConditionalsMutator]MSP[] }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI2Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( other . commentStart != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[NegateConditionalsMutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( this == obj ) { MST[rv.ROR5Mutator]MSP[] return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( delimiter != other . delimiter ) { return false ; MST[ReturnValsMutator]MSP[] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR4Mutator]MSP[] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[]
if ( header != null ) { MST[rv.ROR5Mutator]MSP[] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
if ( this == obj ) { return true ; } if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR6Mutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( this == obj ) { return true ; MST[rv.CRCR5Mutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI2Mutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR5Mutator]MSP[]
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; MST[ReturnValsMutator]MSP[] } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR2Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException (
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[MathMutator]MSP[]
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[ConstructorCallMutator]MSP[] } @Override public boolean equals ( final Object obj ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ABSMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR1Mutator]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR5Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR4Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.ROR5Mutator]MSP[] }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR3Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR2Mutator]MSP[] int result = 1 ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR4Mutator]MSP[]
result = prime * result + delimiter ; MST[rv.AOR4Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[NullReturnValsMutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( isLineBreak ( escape ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
return false ; } return true ; MST[InlineConstantMutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + delimiter ; MST[rv.UOI4Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR2Mutator]MSP[]
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; MST[ReturnValsMutator]MSP[] } public Character getQuoteChar () { return quoteChar ; }
public boolean isQuoting () { return quoteChar != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
return header != null ? header . clone () : null ; MST[NonVoidMethodCallMutator]MSP[] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public boolean isNullHandling () { return nullString != null ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[MathMutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR6Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR2Mutator]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR5Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR2Mutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR5Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; MST[EmptyObjectReturnValsMutator]MSP[] } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[rv.ROR5Mutator]MSP[] if ( other . commentStart != null ) { return false ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalStateException (
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( lr_7 ) ; }
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( delimiter != other . delimiter ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR2Mutator]MSP[]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( ' ' ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR2Mutator]MSP[]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[]
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI2Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR5Mutator]MSP[]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR5Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; MST[ReturnValsMutator]MSP[] } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR1Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; MST[ReturnValsMutator]MSP[] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI4Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
return false ; MST[BooleanTrueReturnValsMutator]MSP[] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR2Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR6Mutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_17 ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI4Mutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[NegateConditionalsMutator]MSP[] sb . append ( lr_7 ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR5Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
return false ; } return true ; MST[rv.CRCR4Mutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[ReturnValsMutator]MSP[] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + delimiter ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR6Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException (
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR2Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { MST[NonVoidMethodCallMutator]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR6Mutator]MSP[]
result = prime * result + delimiter ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; MST[ConstructorCallMutator]MSP[] set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR4Mutator]MSP[] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR2Mutator]MSP[]
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( this == obj ) { return true ; MST[rv.CRCR6Mutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[NegateConditionalsMutator]MSP[] sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; MST[ReturnValsMutator]MSP[] } public String [] getHeader () {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[ConstructorCallMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[NonVoidMethodCallMutator]MSP[] if ( header != null ) { sb . append ( ' ' ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR4Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[]
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR4Mutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; }
if ( delimiter != other . delimiter ) { return false ; MST[InlineConstantMutator]MSP[] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ABSMutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR3Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[experimental.NakedReceiverMutator]MSP[] }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR5Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ABSMutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR5Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR2Mutator]MSP[]
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; MST[ConstructorCallMutator]MSP[] return out . toString () . trim () ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR5Mutator]MSP[] sb . append ( ' ' ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.ABSMutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( isLineBreak ( escape ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; }
if ( isLineBreak ( escape ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
return false ; MST[InlineConstantMutator]MSP[] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public boolean isQuoting () { return quoteChar != null ; MST[BooleanTrueReturnValsMutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.ABSMutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR1Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR1Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[NegateConditionalsMutator]MSP[]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD2Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.ABSMutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR4Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR5Mutator]MSP[] sb . append ( lr_7 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.ABSMutator]MSP[]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[InlineConstantMutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( delimiter != other . delimiter ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.ABSMutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR2Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR1Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( delimiter != other . delimiter ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR3Mutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[NonVoidMethodCallMutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR3Mutator]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[NonVoidMethodCallMutator]MSP[] sb . append ( ' ' ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( header != null ) { sb . append ( ' ' ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR3Mutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI1Mutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR3Mutator]MSP[] return false ;
if ( header != null ) { MST[NegateConditionalsMutator]MSP[] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR2Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return header != null ? header . clone () : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.ROR5Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR4Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.ABSMutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR1Mutator]MSP[]
throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[InlineConstantMutator]MSP[] }
if ( getIgnoreSurroundingSpaces () ) { MST[NegateConditionalsMutator]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR4Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI3Mutator]MSP[] }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR3Mutator]MSP[] }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( isLineBreak ( escape ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[NegateConditionalsMutator]MSP[] if ( other . quoteChar != null ) { return false ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + delimiter ; MST[rv.AOR2Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR3Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[MathMutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final CSVFormat other = ( CSVFormat ) obj ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR2Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean equals ( final Object obj ) {
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI3Mutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; MST[rv.CRCR2Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR5Mutator]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR4Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR3Mutator]MSP[]
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR5Mutator]MSP[] int result = 1 ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR3Mutator]MSP[]
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR4Mutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD2Mutator]MSP[]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR5Mutator]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR1Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR5Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI3Mutator]MSP[] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[NonVoidMethodCallMutator]MSP[]
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + delimiter ; MST[rv.UOI2Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR4Mutator]MSP[]
result = prime * result + delimiter ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
if ( delimiter != other . delimiter ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[InlineConstantMutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[rv.ROR5Mutator]MSP[] if ( other . quoteChar != null ) { return false ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[ReturnValsMutator]MSP[] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[InlineConstantMutator]MSP[] } @Override public boolean equals ( final Object obj ) {
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[]
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[ReturnValsMutator]MSP[] }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR1Mutator]MSP[]
if ( this == obj ) { return true ; MST[rv.CRCR3Mutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR4Mutator]MSP[] }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; MST[experimental.NakedReceiverMutator]MSP[] }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR6Mutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD2Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR4Mutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( ' ' ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[InlineConstantMutator]MSP[]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( isQuoting () ) { MST[rv.ROR4Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( isLineBreak ( escape ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR1Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; MST[MathMutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[ReturnValsMutator]MSP[] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR3Mutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[InlineConstantMutator]MSP[] }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR4Mutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
return false ; MST[rv.CRCR5Mutator]MSP[] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.ROR5Mutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR3Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[EmptyObjectReturnValsMutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI3Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; MST[NonVoidMethodCallMutator]MSP[] } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException (
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR4Mutator]MSP[] return false ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
return header != null ? header . clone () : null ; MST[ReturnValsMutator]MSP[] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[rv.ROR5Mutator]MSP[] return false ; }
return false ; } return true ; MST[rv.CRCR2Mutator]MSP[] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.ROR5Mutator]MSP[]
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb . append ( lr_7 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI3Mutator]MSP[]
if ( isQuoting () ) { MST[rv.ROR5Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[rv.ROR5Mutator]MSP[] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[InlineConstantMutator]MSP[] int result = 1 ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD2Mutator]MSP[]
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException (
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[experimental.NakedReceiverMutator]MSP[]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR4Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR1Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR2Mutator]MSP[] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR3Mutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR6Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[NegateConditionalsMutator]MSP[]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR4Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException (
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ABSMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD2Mutator]MSP[]
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.ROR5Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI2Mutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR5Mutator]MSP[] }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR3Mutator]MSP[] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR5Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI3Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR5Mutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.ROR5Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( delimiter != other . delimiter ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI3Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_17 ) ; }
if( recordSeparator != null ) { MST[rv.ROR5Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR2Mutator]MSP[] }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR1Mutator]MSP[]
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI3Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[ConstructorCallMutator]MSP[] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( isQuoting () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR5Mutator]MSP[]
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR1Mutator]MSP[] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR4Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR1Mutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[ReturnValsMutator]MSP[] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; MST[ConstructorCallMutator]MSP[] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[NegateConditionalsMutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NegateConditionalsMutator]MSP[] }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR3Mutator]MSP[]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[NegateConditionalsMutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; MST[ConstructorCallMutator]MSP[] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR3Mutator]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR6Mutator]MSP[] }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( delimiter != other . delimiter ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.ROR5Mutator]MSP[]
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[InlineConstantMutator]MSP[] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if( recordSeparator != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR6Mutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; MST[ConstructorCallMutator]MSP[] try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI1Mutator]MSP[] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[ReturnValsMutator]MSP[] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[NegateConditionalsMutator]MSP[]
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[NonVoidMethodCallMutator]MSP[]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD2Mutator]MSP[]
if ( this == obj ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; MST[EmptyObjectReturnValsMutator]MSP[] } public String [] getHeader () {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR1Mutator]MSP[]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR2Mutator]MSP[]
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if ( this == obj ) { return true ; MST[rv.CRCR4Mutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[NegateConditionalsMutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR3Mutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR5Mutator]MSP[] }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException (
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_17 ) ; }
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; MST[ReturnValsMutator]MSP[] } public Character getEscape () { return escape ; } public String [] getHeader () {
public boolean isQuoting () { return quoteChar != null ; MST[ReturnValsMutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR5Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR4Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( set . size () != header . length ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[NegateConditionalsMutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException (
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR5Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.ABSMutator]MSP[] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI1Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[BooleanTrueReturnValsMutator]MSP[] }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_17 ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[InlineConstantMutator]MSP[] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR1Mutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR3Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR1Mutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[InlineConstantMutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI3Mutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[ReturnValsMutator]MSP[] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR3Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR1Mutator]MSP[]
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[InlineConstantMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR4Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR3Mutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[ReturnValsMutator]MSP[]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR2Mutator]MSP[]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; MST[ReturnValsMutator]MSP[] } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; } public String [] getHeader () {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI2Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return header != null ? header . clone () : null ; MST[NegateConditionalsMutator]MSP[] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[InlineConstantMutator]MSP[] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR3Mutator]MSP[]
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR4Mutator]MSP[]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR2Mutator]MSP[] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_17 ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR1Mutator]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD2Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR1Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[NegateConditionalsMutator]MSP[] return false ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; MST[ConstructorCallMutator]MSP[] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[]
if ( isQuoting () ) { MST[rv.ROR2Mutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR1Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR1Mutator]MSP[] return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD2Mutator]MSP[]
if ( escape != null && escape . equals ( commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + delimiter ; MST[rv.ABSMutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[InlineConstantMutator]MSP[]
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[NegateConditionalsMutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR1Mutator]MSP[]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[NegateConditionalsMutator]MSP[]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[NegateConditionalsMutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR6Mutator]MSP[] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[]
if ( delimiter != other . delimiter ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + delimiter ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[InlineConstantMutator]MSP[]
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR3Mutator]MSP[] int result = 1 ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR3Mutator]MSP[] sb . append ( ' ' ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR2Mutator]MSP[] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[NegateConditionalsMutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR3Mutator]MSP[] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; MST[EmptyObjectReturnValsMutator]MSP[] } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; } public String [] getHeader () {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[rv.ROR5Mutator]MSP[] return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[NonVoidMethodCallMutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[InlineConstantMutator]MSP[] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI3Mutator]MSP[]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD2Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR5Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; MST[NullReturnValsMutator]MSP[] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_15 + commentStart + lr_12 ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR5Mutator]MSP[] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.ABSMutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[InlineConstantMutator]MSP[] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[ReturnValsMutator]MSP[] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + delimiter ; MST[rv.AOD1Mutator]MSP[] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR3Mutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
if ( isLineBreak ( escape ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( other . escape != null ) { return false ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI2Mutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[InlineConstantMutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[ReturnValsMutator]MSP[] } public CSVFormat withCommentStart ( final Character commentStart ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[ReturnValsMutator]MSP[]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public CSVFormat withEscape ( final Character escape ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI1Mutator]MSP[] }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; MST[VoidMethodCallMutator]MSP[] return out . toString () . trim () ;
if ( this == obj ) { return true ; MST[ReturnValsMutator]MSP[] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[]
} else if ( ! escape . equals ( other . escape ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[]
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[NonVoidMethodCallMutator]MSP[] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR1Mutator]MSP[] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[InlineConstantMutator]MSP[]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[InlineConstantMutator]MSP[] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI3Mutator]MSP[] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
