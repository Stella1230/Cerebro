return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR4Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ABSMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR1Mutator]MSP[N] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.UOI2Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI1Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR2Mutator]MSP[S]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ABSMutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR4Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
case 'n' : return LF ; MST[rv.CRCR6Mutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR4Mutator]MSP[N] return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR5Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR5Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR1Mutator]MSP[S]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[PrimitiveReturnsMutator]MSP[S]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ABSMutator]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { while ( true ) { c = in . read () ;
if ( isDelimiter ( c ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR5Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR1Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI4Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
if ( isDelimiter ( c ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI2Mutator]MSP[N] case 'r' : return CR ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR6Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR3Mutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR1Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR5Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR4Mutator]MSP[S] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR3Mutator]MSP[N]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[NonVoidMethodCallMutator]MSP[S] } boolean isStartOfLine ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI2Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[S]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[N]
final String line = in . readLine () ; MST[NonVoidMethodCallMutator]MSP[N] if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR3Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
lastChar = c ; MST[rv.UOI2Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI2Mutator]MSP[N] } }
return c == null ? DISABLED : c . charValue () ; MST[PrimitiveReturnsMutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR1Mutator]MSP[N]
} else if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[NegateConditionalsMutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == escape ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR5Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR4Mutator]MSP[S] } boolean isClosed () {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[NegateConditionalsMutator]MSP[N]
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI1Mutator]MSP[N] } } else if ( isQuoteChar ( c ) ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR4Mutator]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; MST[rv.UOI1Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI2Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI4Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR2Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI3Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.ROR1Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR5Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR4Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR4Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return c == null ? DISABLED : c . charValue () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI1Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
return ch == escape ; MST[rv.CRCR2Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ; return token ; } } }
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[InlineConstantMutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR3Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI3Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[N] } boolean isClosed () {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR4Mutator]MSP[N]
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOD2Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
} else if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR5Mutator]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[PrimitiveReturnsMutator]MSP[S] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR5Mutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
case 'n' : return LF ; MST[ReturnValsMutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[S]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; MST[NullReturnValsMutator]MSP[N] } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI2Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR2Mutator]MSP[N] return token ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[N] } boolean isClosed () {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI4Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[N]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR4Mutator]MSP[S]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[NegateConditionalsMutator]MSP[N] } boolean isClosed () {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ABSMutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR2Mutator]MSP[N]
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EOF ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI4Mutator]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR4Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI3Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI3Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.ABSMutator]MSP[N] } } return token ; }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isDelimiter ( c ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; MST[experimental.MemberVariableMutator]MSP[N] return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.ABSMutator]MSP[N] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI1Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] parseEncapsulatedToken ( token ) ;
return ch == escape ; MST[InlineConstantMutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( isDelimiter ( c ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI2Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[NegateConditionalsMutator]MSP[N] buffer . setLength ( length ) ; } }
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR1Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[NegateConditionalsMutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR6Mutator]MSP[S]
token . isReady = true ; MST[rv.CRCR4Mutator]MSP[N] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR3Mutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI4Mutator]MSP[N] } else { while ( true ) { c = in . read () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR3Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; MST[experimental.MemberVariableMutator]MSP[S] token . isReady = true ; return token ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI4Mutator]MSP[N] } boolean isEscape ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EOF ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR1Mutator]MSP[N] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI3Mutator]MSP[N] } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR4Mutator]MSP[N]
lastChar = c ; MST[rv.UOI3Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
token . content . append ( ( char ) ch ) ; MST[rv.UOI1Mutator]MSP[N] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[PrimitiveReturnsMutator]MSP[N] case END_OF_STREAM :
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR1Mutator]MSP[N]
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR4Mutator]MSP[S] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR1Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR1Mutator]MSP[S] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[InlineConstantMutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI2Mutator]MSP[N]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI4Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI2Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR6Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR2Mutator]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ABSMutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; MST[rv.CRCR3Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR5Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR3Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else if ( isQuoteChar ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[N]
case 'n' : return LF ; MST[rv.CRCR2Mutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR5Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI4Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[N]
if ( isDelimiter ( c ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == escape ; MST[rv.CRCR6Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI1Mutator]MSP[N] } ch = in . read () ; } else {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI4Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; MST[ReturnValsMutator]MSP[S] } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[NegateConditionalsMutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR4Mutator]MSP[N]
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI3Mutator]MSP[N] } } } private char mapNullToDisabled ( final Character c ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI1Mutator]MSP[N] } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[BooleanTrueReturnValsMutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ABSMutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI4Mutator]MSP[N] } } else if ( isQuoteChar ( c ) ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR1Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI4Mutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == escape ; MST[rv.UOI4Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI4Mutator]MSP[N] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR5Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI1Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI2Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR1Mutator]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI4Mutator]MSP[S] } boolean isStartOfLine ( final int ch ) {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI2Mutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[S]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR1Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.UOI2Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR1Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ABSMutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.UOI4Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[NegateConditionalsMutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI1Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI1Mutator]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR2Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) ch ) ; MST[rv.ABSMutator]MSP[N] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR3Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR2Mutator]MSP[N] } boolean isClosed () {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EOF ; return token ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR4Mutator]MSP[N] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[InlineConstantMutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[NegateConditionalsMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI2Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; MST[NonVoidMethodCallMutator]MSP[N] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[NegateConditionalsMutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI4Mutator]MSP[N] case 'r' : return CR ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR3Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; MST[ReturnValsMutator]MSP[N] }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.CRCR4Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI2Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI4Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[PrimitiveReturnsMutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[InlineConstantMutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR2Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR4Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[S]
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N]
case 'n' : return LF ; MST[rv.CRCR4Mutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR3Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR1Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[N]
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR1Mutator]MSP[S] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.ROR2Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI3Mutator]MSP[N] } ch = in . read () ; } else {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI3Mutator]MSP[N] } }
final String line = in . readLine () ; if ( line == null ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N]
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[NonVoidMethodCallMutator]MSP[N] } ch = in . read () ; } else {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI4Mutator]MSP[N] } boolean isClosed () {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.UOI2Mutator]MSP[N]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR5Mutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR6Mutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR3Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR1Mutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[S]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 'r' : return CR ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ABSMutator]MSP[S] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 'r' : return CR ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; MST[NonVoidMethodCallMutator]MSP[N] boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_7]MSP[N] case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI4Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_6]MSP[N] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_9]MSP[S] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_8]MSP[N] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_3]MSP[N] case 'r' : return CR ;
token . isReady = true ; MST[rv.CRCR2Mutator]MSP[S] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_5]MSP[N] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_4]MSP[S] case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NegateConditionalsMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[N] } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR1Mutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI2Mutator]MSP[N] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI2Mutator]MSP[N] } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR4Mutator]MSP[N]
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[NegateConditionalsMutator]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[InlineConstantMutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
token . content . append ( ( char ) ch ) ; MST[rv.UOI3Mutator]MSP[N] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[N] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI1Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR1Mutator]MSP[N] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR4Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR5Mutator]MSP[N] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR3Mutator]MSP[N] buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI2Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR2Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR2Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR2Mutator]MSP[S]
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } private char mapNullToDisabled ( final Character c ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI3Mutator]MSP[N] } } return token ; }
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR4Mutator]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR2Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI2Mutator]MSP[N] case END_OF_STREAM :
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI3Mutator]MSP[N] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ABSMutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[NegateConditionalsMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; MST[ReturnValsMutator]MSP[N] } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; MST[rv.UOI3Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI2Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[InlineConstantMutator]MSP[S]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR4Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI3Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[InlineConstantMutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI1Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; MST[PrimitiveReturnsMutator]MSP[S] } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR2Mutator]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] token . type = EOF ; token . isReady = true ; return token ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[N] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[N]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ABSMutator]MSP[N]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; MST[NonVoidMethodCallMutator]MSP[N] int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR2Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR3Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.CRCR5Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; MST[rv.CRCR4Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[NegateConditionalsMutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ABSMutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR2Mutator]MSP[N]
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI4Mutator]MSP[N] } } return token ; }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI4Mutator]MSP[N] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR6Mutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } private char mapNullToDisabled ( final Character c ) {
if ( isDelimiter ( c ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR5Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI3Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR5Mutator]MSP[N]
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[InlineConstantMutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; MST[NonVoidMethodCallMutator]MSP[N] token . content . append ( comment ) ; token . type = COMMENT ;
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ABSMutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR5Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI4Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR3Mutator]MSP[N]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR4Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI2Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI2Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR3Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[InlineConstantMutator]MSP[N] } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI1Mutator]MSP[N] } } } private char mapNullToDisabled ( final Character c ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR5Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR4Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EOF ; return token ; } } }
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; MST[NullReturnValsMutator]MSP[N] } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
if ( isDelimiter ( c ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EOF ; return token ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[InlineConstantMutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI4Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[N] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR4Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI1Mutator]MSP[N] } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR4Mutator]MSP[N]
return in . isClosed () ; MST[NonVoidMethodCallMutator]MSP[S] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[S]
} else if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { while ( true ) { c = in . read () ;
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; MST[ReturnValsMutator]MSP[N] } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI2Mutator]MSP[N] } else { while ( true ) { c = in . read () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI4Mutator]MSP[S] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR1Mutator]MSP[S] } boolean isStartOfLine ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR2Mutator]MSP[N]
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ABSMutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR3Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR5Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI1Mutator]MSP[N] } }
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
lastChar = c ; MST[rv.UOI1Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR3Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR6Mutator]MSP[N]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI1Mutator]MSP[N] case 'r' : return CR ;
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[InlineConstantMutator]MSP[N] } else { parseSimpleToken ( token , c ) ; } } return token ; }
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR3Mutator]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR4Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR2Mutator]MSP[N] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ABSMutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NegateConditionalsMutator]MSP[N]
token . isReady = true ; MST[experimental.MemberVariableMutator]MSP[S] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR4Mutator]MSP[N] } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI1Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[N] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ; MST[NonVoidMethodCallMutator]MSP[N]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR1Mutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR5Mutator]MSP[N] return token ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EOF ; return token ; } } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.ABSMutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; MST[NonVoidMethodCallMutator]MSP[S] } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR4Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR6Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[experimental.MemberVariableMutator]MSP[N] } else { parseSimpleToken ( token , c ) ; } } return token ; }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[NonVoidMethodCallMutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI2Mutator]MSP[N] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI2Mutator]MSP[N] } } else if ( isQuoteChar ( c ) ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR1Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[NegateConditionalsMutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.ROR5Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.ROR3Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI2Mutator]MSP[S] } boolean isStartOfLine ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ABSMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI2Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[N] } boolean isClosed () {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR3Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI3Mutator]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[InlineConstantMutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR1Mutator]MSP[S] c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EOF ;
if ( isQuoteChar ( in . lookAhead () ) ) { MST[NonVoidMethodCallMutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] parseEncapsulatedToken ( token ) ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; MST[NullReturnValsMutator]MSP[N] } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[NegateConditionalsMutator]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI4Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR3Mutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOD1Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR1Mutator]MSP[N] buffer . setLength ( length ) ; } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR5Mutator]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR2Mutator]MSP[N] } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[NegateConditionalsMutator]MSP[N] parseEncapsulatedToken ( token ) ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ABSMutator]MSP[N] buffer . setLength ( length ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[NonVoidMethodCallMutator]MSP[S] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[ReturnValsMutator]MSP[S]
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; MST[experimental.MemberVariableMutator]MSP[N] break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = EOF ; return token ; } } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[ReturnValsMutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI1Mutator]MSP[N] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR3Mutator]MSP[N] return token ;
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR4Mutator]MSP[N] } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR2Mutator]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NegateConditionalsMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ; MST[NullReturnValsMutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[experimental.MemberVariableMutator]MSP[N] return token ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI2Mutator]MSP[N] buffer . setLength ( length ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR6Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI4Mutator]MSP[N] case END_OF_STREAM :
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[ConditionalsBoundaryMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI1Mutator]MSP[N] } } return token ; }
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else if ( isQuoteChar ( c ) ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( isDelimiter ( c ) ) { MST[rv.ABSMutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ; MST[experimental.MemberVariableMutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.UOI1Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[N] } boolean isClosed () {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isStartOfLine ( final int ch ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = EOF ; return token ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR5Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR3Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR3Mutator]MSP[N] } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR5Mutator]MSP[S]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[N]
token . isReady = true ; MST[rv.CRCR5Mutator]MSP[S] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR5Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
case 'n' : return LF ; MST[rv.CRCR1Mutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR5Mutator]MSP[N] } else { parseSimpleToken ( token , c ) ; } } return token ; }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI3Mutator]MSP[N] buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR4Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI2Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ; MST[ReturnValsMutator]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR5Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI2Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR5Mutator]MSP[N] } boolean isClosed () {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ABSMutator]MSP[N]
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI4Mutator]MSP[N] } } } private char mapNullToDisabled ( final Character c ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return c == null ? DISABLED : c . charValue () ; MST[NonVoidMethodCallMutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR2Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[NegateConditionalsMutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR1Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ch = in . read () ; } else {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI4Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR2Mutator]MSP[N] } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI3Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[N]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; MST[experimental.MemberVariableMutator]MSP[N] return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI2Mutator]MSP[S] } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR4Mutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
token . content . append ( ( char ) ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR1Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ; return token ; } } }
return ch == escape ; MST[rv.ROR4Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR5Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; MST[NonVoidMethodCallMutator]MSP[N] } else {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR2Mutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI3Mutator]MSP[N] } boolean isClosed () {
} else if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[S] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI3Mutator]MSP[N] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
return token ; MST[NullReturnValsMutator]MSP[S] } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; MST[NonVoidMethodCallMutator]MSP[N] switch ( ch ) { case 'r' : return CR ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR1Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR1Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI1Mutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
} else if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[InlineConstantMutator]MSP[N] return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; MST[NonVoidMethodCallMutator]MSP[N] if ( unescaped == Constants . END_OF_STREAM ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI3Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.CRCR6Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI3Mutator]MSP[N] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ABSMutator]MSP[N]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[MathMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return in . isClosed () ; MST[ReturnValsMutator]MSP[N] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI2Mutator]MSP[N] } } return token ; }
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI1Mutator]MSP[N] case END_OF_STREAM :
return c == null ? DISABLED : c . charValue () ; MST[NegateConditionalsMutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI2Mutator]MSP[N] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ; MST[NonVoidMethodCallMutator]MSP[N]
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[ReturnValsMutator]MSP[N] case END_OF_STREAM :
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI1Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR1Mutator]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI3Mutator]MSP[N] case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR1Mutator]MSP[N] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR4Mutator]MSP[N] buffer . setLength ( length ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.CRCR5Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI1Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; MST[InlineConstantMutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
final long startLineNumber = getCurrentLineNumber () ; MST[NonVoidMethodCallMutator]MSP[N] int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[NegateConditionalsMutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[N]
if ( isDelimiter ( c ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; MST[experimental.NakedReceiverMutator]MSP[N] token . type = COMMENT ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.UOI1Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR3Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[InlineConstantMutator]MSP[S]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ABSMutator]MSP[N]
return c == null ? DISABLED : c . charValue () ; MST[rv.ROR5Mutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[ReturnValsMutator]MSP[S] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[ReturnValsMutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR1Mutator]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR5Mutator]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR4Mutator]MSP[N] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; MST[NonVoidMethodCallMutator]MSP[N] eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[N] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ABSMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isStartOfLine ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; MST[NonVoidMethodCallMutator]MSP[S] if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI4Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.ABSMutator]MSP[S] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[NegateConditionalsMutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR4Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; MST[NonVoidMethodCallMutator]MSP[N] token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR3Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR5Mutator]MSP[N] } boolean isEscape ( final int ch ) {
case 'n' : return LF ; MST[rv.CRCR5Mutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
token . isReady = true ; MST[rv.CRCR3Mutator]MSP[N] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR1Mutator]MSP[S]
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.ABSMutator]MSP[N] case END_OF_STREAM :
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR1Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ; return token ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[N]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = EOF ; return token ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[NegateConditionalsMutator]MSP[N] } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[NegateConditionalsMutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_10]MSP[N] case 'r' : return CR ;
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI4Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR2Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; MST[rv.ROR3Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR3Mutator]MSP[N]
case 'n' : return LF ; MST[PrimitiveReturnsMutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI4Mutator]MSP[N] } ch = in . read () ; } else {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI4Mutator]MSP[N] } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR3Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR4Mutator]MSP[N]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR5Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; MST[NonVoidMethodCallMutator]MSP[N] } return ch == LF || ch == CR ; } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI4Mutator]MSP[S] } boolean isClosed () {
if ( isDelimiter ( c ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR4Mutator]MSP[N] } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR5Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[NonVoidMethodCallMutator]MSP[N] buffer . setLength ( length ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR5Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR4Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR2Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR3Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR3Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[S]
throw new IOException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[S] default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . content . append ( ( char ) ch ) ; MST[rv.UOI4Mutator]MSP[N] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ABSMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean isClosed () {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI1Mutator]MSP[N] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR3Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR2Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.SwitchMutator]MSP[N] case 'r' : return CR ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EOF ; return token ; } } }
return c == null ? DISABLED : c . charValue () ; MST[ReturnValsMutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[ReturnValsMutator]MSP[N] } boolean isClosed () {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR6Mutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ABSMutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
case 'n' : return LF ; MST[InlineConstantMutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] c = in . read () ; eol = readEndOfLine ( c ) ; } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[NegateConditionalsMutator]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR5Mutator]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( readEndOfLine ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR1Mutator]MSP[S] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[S] token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.ROR1Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI4Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.ABSMutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final String line = in . readLine () ; if ( line == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
ch == escape || ch == quoteChar || ch == commentStart ; } void close () throws IOException { in . close () ; MST[VoidMethodCallMutator]MSP[S] }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR4Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR5Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ABSMutator]MSP[S] } boolean isStartOfLine ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI3Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[S]
if ( isDelimiter ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EOF ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ABSMutator]MSP[N] } boolean isClosed () {
if ( isDelimiter ( c ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[InlineConstantMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR2Mutator]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR4Mutator]MSP[N] } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[ReturnValsMutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.ABSMutator]MSP[N] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isDelimiter ( c ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[S]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; MST[ReturnValsMutator]MSP[N] } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR4Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR4Mutator]MSP[N]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI3Mutator]MSP[N]
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.ABSMutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
token . isReady = true ; MST[InlineConstantMutator]MSP[S] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR2Mutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI1Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[N] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] parseEncapsulatedToken ( token ) ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI3Mutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.ROR2Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.ABSMutator]MSP[N] } else { while ( true ) { c = in . read () ;
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR2Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EOF ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[ReturnValsMutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
lastChar = c ; MST[rv.UOI4Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR5Mutator]MSP[N]
token . content . append ( ( char ) ch ) ; MST[rv.UOI2Mutator]MSP[N] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
} else if ( readEndOfLine ( c ) ) { MST[rv.ABSMutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR2Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI4Mutator]MSP[N] } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI1Mutator]MSP[N] } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR2Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ABSMutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI2Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI2Mutator]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI3Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR2Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR5Mutator]MSP[S]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; MST[experimental.MemberVariableMutator]MSP[N] return token ; } } }
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[NegateConditionalsMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; MST[NonVoidMethodCallMutator]MSP[N] token . type = COMMENT ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ABSMutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
case 'n' : return LF ; MST[rv.CRCR3Mutator]MSP[N] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
if ( isDelimiter ( c ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[VoidMethodCallMutator]MSP[N] } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR2Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR4Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR6Mutator]MSP[N] return token ;
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; MST[NullReturnValsMutator]MSP[N] }
return ch == escape ; MST[rv.ROR1Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR6Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI2Mutator]MSP[N] } ch = in . read () ; } else {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[S] token . type = EOF ; token . isReady = true ; return token ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI2Mutator]MSP[N] } }
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI2Mutator]MSP[N] } } } private char mapNullToDisabled ( final Character c ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR5Mutator]MSP[N]
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR3Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR5Mutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI1Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NegateConditionalsMutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI1Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ABSMutator]MSP[N] parseEncapsulatedToken ( token ) ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI3Mutator]MSP[N]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI3Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR4Mutator]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI3Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR3Mutator]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR1Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR6Mutator]MSP[N]
if ( isDelimiter ( c ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return ch == escape ; MST[rv.ABSMutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR5Mutator]MSP[N]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI3Mutator]MSP[N] } else { while ( true ) { c = in . read () ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer . setLength ( length ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR2Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR2Mutator]MSP[N] } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR3Mutator]MSP[N] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.ABSMutator]MSP[N] } } else if ( isQuoteChar ( c ) ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[NegateConditionalsMutator]MSP[N]
return c == null ? DISABLED : c . charValue () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR2Mutator]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR2Mutator]MSP[S] } boolean isClosed () {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI1Mutator]MSP[N] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; MST[NullReturnValsMutator]MSP[S] } } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ABSMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI3Mutator]MSP[N] } } else if ( isQuoteChar ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI4Mutator]MSP[N]
return ch == escape ; MST[ReturnValsMutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.AOR4Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI3Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
return ch == escape ; MST[NegateConditionalsMutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { MST[NegateConditionalsMutator]MSP[N] if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI3Mutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return in . isClosed () ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { MST[rv.ABSMutator]MSP[N] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR2Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI1Mutator]MSP[N] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[InlineConstantMutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; MST[experimental.NakedReceiverMutator]MSP[N] token . content . append ( comment ) ; token . type = COMMENT ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[N]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR5Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI3Mutator]MSP[N] case END_OF_STREAM :
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[MathMutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.UOI1Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { MST[rv.ROR5Mutator]MSP[N] if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.AOD2Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR2Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[S] token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI2Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR3Mutator]MSP[N] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI4Mutator]MSP[N]
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR2Mutator]MSP[S] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR4Mutator]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; MST[NullReturnValsMutator]MSP[N] } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; MST[rv.ROR5Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[N]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR1Mutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; MST[rv.CRCR1Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; MST[VoidMethodCallMutator]MSP[N] } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR1Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return c == null ? DISABLED : c . charValue () ; MST[InlineConstantMutator]MSP[N] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR1Mutator]MSP[N]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR3Mutator]MSP[N]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[S]
if ( isDelimiter ( c ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI3Mutator]MSP[S] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR1Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[NegateConditionalsMutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR4Mutator]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR1Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ABSMutator]MSP[S] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[NonVoidMethodCallMutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.ABSMutator]MSP[N] } } } private char mapNullToDisabled ( final Character c ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR4Mutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[ReturnValsMutator]MSP[N]
} else if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.ABSMutator]MSP[N] case 'r' : return CR ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ABSMutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.ABSMutator]MSP[N] } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI3Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR6Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR6Mutator]MSP[S]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; MST[ReturnValsMutator]MSP[N] } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; MST[rv.CRCR6Mutator]MSP[S] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR5Mutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR3Mutator]MSP[S]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR1Mutator]MSP[N]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.ABSMutator]MSP[N] } }
lastChar = c ; c = in . read () ; MST[NonVoidMethodCallMutator]MSP[N] eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR3Mutator]MSP[N] } else { parseSimpleToken ( token , c ) ; } } return token ; }
lastChar = c ; MST[rv.ABSMutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
} else if ( readEndOfLine ( c ) ) { MST[NonVoidMethodCallMutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI1Mutator]MSP[N] buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI4Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR1Mutator]MSP[N] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR3Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR3Mutator]MSP[N] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI2Mutator]MSP[N] } boolean isClosed () {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI2Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR6Mutator]MSP[N] } boolean isEscape ( final int ch ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.CRCR3Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR2Mutator]MSP[N] buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR2Mutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR2Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[N]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI4Mutator]MSP[S] } boolean isStartOfLine ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ABSMutator]MSP[N] } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR6Mutator]MSP[N] } else { parseSimpleToken ( token , c ) ; } } return token ; }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR2Mutator]MSP[N] } boolean isStartOfLine ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI2Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI1Mutator]MSP[N]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[S] } boolean isClosed () {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.ABSMutator]MSP[N] } ch = in . read () ; } else {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI2Mutator]MSP[S] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; MST[rv.CRCR5Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[ReturnValsMutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR5Mutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[N]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI4Mutator]MSP[N] buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI1Mutator]MSP[N] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR6Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI1Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; MST[ReturnValsMutator]MSP[S] } } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } boolean isStartOfLine ( final int ch ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[N] token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { MST[rv.UOI3Mutator]MSP[N] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI3Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[S] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR3Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR3Mutator]MSP[N] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( readEndOfLine ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.UOI2Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR5Mutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[InlineConstantMutator]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI4Mutator]MSP[N]
final String line = in . readLine () ; if ( line == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ABSMutator]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[InlineConstantMutator]MSP[N] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR2Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI2Mutator]MSP[N] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.AOR1Mutator]MSP[N] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[S]
return in . isClosed () ; MST[BooleanFalseReturnValsMutator]MSP[S] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR3Mutator]MSP[N] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI4Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI3Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI1Mutator]MSP[N] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR4Mutator]MSP[N] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; MST[experimental.MemberVariableMutator]MSP[N] return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[N] token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final String line = in . readLine () ; if ( line == null ) { MST[rv.ROR5Mutator]MSP[N] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
} else if ( readEndOfLine ( c ) ) { MST[NegateConditionalsMutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; MST[experimental.MemberVariableMutator]MSP[N] break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR2Mutator]MSP[N] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[N] } boolean isClosed () {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR4Mutator]MSP[S] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR2Mutator]MSP[N] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[N] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR5Mutator]MSP[N] buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ABSMutator]MSP[N]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[N]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR5Mutator]MSP[N] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR4Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; MST[ReturnValsMutator]MSP[S] } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI3Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR4Mutator]MSP[N] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR1Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI4Mutator]MSP[N] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR4Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI1Mutator]MSP[N] } else { while ( true ) { c = in . read () ;
return ch == escape ; MST[rv.CRCR3Mutator]MSP[N] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isQuoteChar ( in . lookAhead () ) ) { MST[NonVoidMethodCallMutator]MSP[N] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR1Mutator]MSP[N] while ( eol && isStartOfLine ( lastChar ) ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI1Mutator]MSP[N]
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI1Mutator]MSP[N] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR4Mutator]MSP[N] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
