public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI1Mutator]MSP[N]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( isLineBreak ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR1Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[InlineConstantMutator]MSP[S] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR2Mutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI1Mutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR2Mutator]MSP[N] return false ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException (
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; MST[MathMutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( isQuoting () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI1Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR3Mutator]MSP[S] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI4Mutator]MSP[S] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
if ( isQuoting () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD1Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI1Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[InlineConstantMutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( isLineBreak ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( this == obj ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[BooleanTrueReturnValsMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI2Mutator]MSP[N] }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException (
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR2Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR1Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR4Mutator]MSP[N]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N]
if( recordSeparator != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N]
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[NullReturnValsMutator]MSP[N] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[MathMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[InlineConstantMutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR1Mutator]MSP[N] int result = 1 ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR4Mutator]MSP[N] int result = 1 ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR4Mutator]MSP[S] sb . append ( ' ' ) ;
public CSVFormat withHeader ( final String ... header ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreEmptyLines ( final boolean ignoreEmptyLines ) {
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N]
result = prime * result + delimiter ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR4Mutator]MSP[N]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N]
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; MST[ConstructorCallMutator]MSP[S] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR3Mutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
public CSVFormat withHeader ( final String ... header ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreEmptyLines ( final boolean ignoreEmptyLines ) {
if ( isQuoting () ) { MST[NonVoidMethodCallMutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[MathMutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuotePolicy ( final Quote quotePolicy ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[NegateConditionalsMutator]MSP[S] if ( other . escape != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI1Mutator]MSP[N]
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; MST[ConstructorCallMutator]MSP[S] }
result = prime * result + delimiter ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[MathMutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI4Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! escape . equals ( other . escape ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[ReturnValsMutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[MathMutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI1Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[MathMutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI1Mutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR3Mutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[S]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.ROR5Mutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR1Mutator]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR4Mutator]MSP[S] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.UOI3Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR3Mutator]MSP[N]
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI4Mutator]MSP[N] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + delimiter ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[ReturnValsMutator]MSP[N] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI1Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[ReturnValsMutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuotePolicy ( final Quote quotePolicy ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[InlineConstantMutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; MST[EmptyObjectReturnValsMutator]MSP[N] }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_15 + commentStart + lr_12 ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR3Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[MathMutator]MSP[N]
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException (
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI1Mutator]MSP[N] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
return false ; } return true ; MST[rv.CRCR5Mutator]MSP[S] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI4Mutator]MSP[N]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR6Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI4Mutator]MSP[N]
return header != null ? header . clone () : null ; MST[rv.ROR5Mutator]MSP[N] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[NullReturnValsMutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[NonVoidMethodCallMutator]MSP[S]
return false ; } return true ; MST[ReturnValsMutator]MSP[S] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI4Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N]
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR5Mutator]MSP[N]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[NegateConditionalsMutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR4Mutator]MSP[S] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD1Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( other . commentStart != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR5Mutator]MSP[N] }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI4Mutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( this == obj ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
public CSVFormat withHeader ( final String ... header ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreEmptyLines ( final boolean ignoreEmptyLines ) {
public Quote getQuotePolicy () { return quotePolicy ; MST[ReturnValsMutator]MSP[N] } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[InlineConstantMutator]MSP[N] }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR3Mutator]MSP[N] }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[NegateConditionalsMutator]MSP[S]
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_17 ) ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N]
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( ' ' ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[rv.ROR5Mutator]MSP[S] if ( other . escape != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR6Mutator]MSP[N] int result = 1 ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR4Mutator]MSP[S]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR5Mutator]MSP[S] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI2Mutator]MSP[N] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI4Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[InlineConstantMutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NegateConditionalsMutator]MSP[N] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException (
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[InlineConstantMutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
public Quote getQuotePolicy () { return quotePolicy ; MST[NullReturnValsMutator]MSP[N] } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR3Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR1Mutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[InlineConstantMutator]MSP[S]
result = prime * result + delimiter ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; MST[ReturnValsMutator]MSP[N] } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException (
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR6Mutator]MSP[N]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR5Mutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( isLineBreak ( escape ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.ABSMutator]MSP[N] }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( delimiter != other . delimiter ) { MST[rv.ROR3Mutator]MSP[S] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[InlineConstantMutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} else if ( ! escape . equals ( other . escape ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
if( recordSeparator != null ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[ReturnValsMutator]MSP[N] }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[NegateConditionalsMutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException (
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; MST[ReturnValsMutator]MSP[N] } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR4Mutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR4Mutator]MSP[S] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR3Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N]
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N]
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; MST[BooleanTrueReturnValsMutator]MSP[N] } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR3Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI4Mutator]MSP[N] }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( other . escape != null ) { return false ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[NegateConditionalsMutator]MSP[S] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( this == obj ) { return true ; MST[InlineConstantMutator]MSP[S] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( isQuoting () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; MST[PrimitiveReturnsMutator]MSP[N] } public Character getEscape () { return escape ; } public String [] getHeader () {
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException (
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[NullReturnValsMutator]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR2Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuotePolicy ( final Quote quotePolicy ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( ' ' ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( isLineBreak ( commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public boolean isQuoting () { return quoteChar != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[MathMutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI2Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return false ; } return true ; MST[rv.CRCR6Mutator]MSP[S] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR4Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI2Mutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( isLineBreak ( escape ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[MathMutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
if ( isLineBreak ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isQuoting () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[InlineConstantMutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return false ; MST[ReturnValsMutator]MSP[S] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[MathMutator]MSP[N]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( set . size () != header . length ) {
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
result = prime * result + delimiter ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[NonVoidMethodCallMutator]MSP[S]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N]
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[NullReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[MathMutator]MSP[N]
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR2Mutator]MSP[S] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
public boolean isQuoting () { return quoteChar != null ; MST[rv.ROR5Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[NegateConditionalsMutator]MSP[S] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[MathMutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[InlineConstantMutator]MSP[S]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR3Mutator]MSP[S]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI3Mutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR6Mutator]MSP[N] }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR1Mutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR4Mutator]MSP[N]
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( delimiter != other . delimiter ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR1Mutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.UOI1Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR4Mutator]MSP[N]
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR5Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_15 + commentStart + lr_12 ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[MathMutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException (
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR1Mutator]MSP[S]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N]
result = prime * result + delimiter ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.CRCR4Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[ReturnValsMutator]MSP[N] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
public boolean isQuoting () { return quoteChar != null ; MST[NegateConditionalsMutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( ' ' ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR6Mutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[rv.ROR5Mutator]MSP[S] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N]
if ( getIgnoreSurroundingSpaces () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
if ( isLineBreak ( escape ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.ABSMutator]MSP[N] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[S] } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[NegateConditionalsMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI4Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.ABSMutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[NonVoidMethodCallMutator]MSP[S] sb . append ( lr_7 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; MST[BooleanFalseReturnValsMutator]MSP[N] } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[NegateConditionalsMutator]MSP[N] return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR3Mutator]MSP[N] }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR4Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI4Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N]
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI4Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( other . quoteChar != null ) { return false ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR6Mutator]MSP[N] }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR1Mutator]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR2Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } final CSVFormat other = ( CSVFormat ) obj ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR4Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[MathMutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR4Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.ABSMutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI4Mutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[ReturnValsMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[ReturnValsMutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
if ( this == obj ) { MST[NegateConditionalsMutator]MSP[N] return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR2Mutator]MSP[S]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI2Mutator]MSP[N]
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
return header != null ? header . clone () : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR4Mutator]MSP[S] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR2Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[NegateConditionalsMutator]MSP[S] if ( other . commentStart != null ) { return false ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Character getQuoteChar () { return quoteChar ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR4Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR5Mutator]MSP[N] return false ;
if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI2Mutator]MSP[N]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[InlineConstantMutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; MST[ReturnValsMutator]MSP[N] }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( header != null ) { sb . append ( ' ' ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; MST[ConstructorCallMutator]MSP[S] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[NegateConditionalsMutator]MSP[N] }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI2Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( other . commentStart != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[N]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( this == obj ) { MST[rv.ROR5Mutator]MSP[N] return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( delimiter != other . delimiter ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR4Mutator]MSP[S] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( header != null ) { MST[rv.ROR5Mutator]MSP[N] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
if ( this == obj ) { return true ; } if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR6Mutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI2Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( this == obj ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI2Mutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR5Mutator]MSP[S]
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; MST[ReturnValsMutator]MSP[N] } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR2Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalStateException (
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[MathMutator]MSP[N]
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[ConstructorCallMutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ABSMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR1Mutator]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR5Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR4Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.ROR5Mutator]MSP[N] }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR4Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR2Mutator]MSP[N] int result = 1 ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR4Mutator]MSP[N]
result = prime * result + delimiter ; MST[rv.AOR4Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[NullReturnValsMutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( isLineBreak ( escape ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
return false ; } return true ; MST[InlineConstantMutator]MSP[S] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_15 + commentStart + lr_12 ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR4Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + delimiter ; MST[rv.UOI4Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR2Mutator]MSP[N]
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; MST[ReturnValsMutator]MSP[N] } public Character getQuoteChar () { return quoteChar ; }
public boolean isQuoting () { return quoteChar != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
return header != null ? header . clone () : null ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[MathMutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR6Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR2Mutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[S]
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR5Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_15 + commentStart + lr_12 ) ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { MST[rv.ROR5Mutator]MSP[S] if ( other . commentStart != null ) { return false ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalStateException (
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( lr_7 ) ; }
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( delimiter != other . delimiter ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( ' ' ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N]
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI2Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR5Mutator]MSP[N]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
return header != null ? header . clone () : null ; } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; MST[ReturnValsMutator]MSP[N] } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR1Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI4Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR2Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_17 ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI4Mutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( lr_7 ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR5Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + delimiter ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException (
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR2Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { MST[NonVoidMethodCallMutator]MSP[S] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR6Mutator]MSP[S]
result = prime * result + delimiter ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; MST[ConstructorCallMutator]MSP[N] set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR4Mutator]MSP[N] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR2Mutator]MSP[N]
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( this == obj ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; MST[ReturnValsMutator]MSP[N] } public String [] getHeader () {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[ConstructorCallMutator]MSP[S] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( header != null ) { sb . append ( ' ' ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR4Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N]
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[N]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR4Mutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; }
if ( delimiter != other . delimiter ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ABSMutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR3Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR5Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ABSMutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR2Mutator]MSP[N]
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; MST[ConstructorCallMutator]MSP[S] return out . toString () . trim () ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( ' ' ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.ABSMutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( isLineBreak ( escape ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; }
if ( isLineBreak ( escape ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
return false ; MST[InlineConstantMutator]MSP[S] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public boolean isQuoting () { return quoteChar != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI2Mutator]MSP[N]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.ABSMutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR1Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[NegateConditionalsMutator]MSP[N]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD2Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.ABSMutator]MSP[N]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR4Mutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( lr_7 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[N]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.ABSMutator]MSP[N]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[InlineConstantMutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( delimiter != other . delimiter ) { MST[rv.ROR2Mutator]MSP[S] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.ABSMutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR2Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( delimiter != other . delimiter ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR2Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR3Mutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[NonVoidMethodCallMutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { MST[NegateConditionalsMutator]MSP[S] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[NonVoidMethodCallMutator]MSP[S] sb . append ( ' ' ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( header != null ) { sb . append ( ' ' ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI1Mutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR3Mutator]MSP[N] return false ;
if ( header != null ) { MST[NegateConditionalsMutator]MSP[N] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR2Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return header != null ? header . clone () : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.ROR5Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[S] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR4Mutator]MSP[S]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.ABSMutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR1Mutator]MSP[N]
throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[InlineConstantMutator]MSP[N] }
if ( getIgnoreSurroundingSpaces () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR4Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI3Mutator]MSP[N] }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR3Mutator]MSP[N] }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( isLineBreak ( escape ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[NegateConditionalsMutator]MSP[S] if ( other . quoteChar != null ) { return false ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + delimiter ; MST[rv.AOR2Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[MathMutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } final CSVFormat other = ( CSVFormat ) obj ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR2Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI3Mutator]MSP[S] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; MST[rv.CRCR2Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR4Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR3Mutator]MSP[N]
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR5Mutator]MSP[N] int result = 1 ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR3Mutator]MSP[N]
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR4Mutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_15 + commentStart + lr_12 ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR5Mutator]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR1Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI3Mutator]MSP[N] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR3Mutator]MSP[S] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[S]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + delimiter ; MST[rv.UOI2Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR4Mutator]MSP[S]
result = prime * result + delimiter ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
if ( delimiter != other . delimiter ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[InlineConstantMutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { MST[rv.ROR5Mutator]MSP[S] if ( other . quoteChar != null ) { return false ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[InlineConstantMutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR3Mutator]MSP[S] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { MST[rv.ROR5Mutator]MSP[S] return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N]
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[ReturnValsMutator]MSP[N] }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR1Mutator]MSP[S]
if ( this == obj ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR4Mutator]MSP[N] }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; MST[experimental.NakedReceiverMutator]MSP[S] }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR6Mutator]MSP[S]
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOD2Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR4Mutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] sb . append ( ' ' ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[InlineConstantMutator]MSP[N]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR1Mutator]MSP[S] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if ( isQuoting () ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( isLineBreak ( escape ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR1Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + delimiter ; MST[MathMutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR3Mutator]MSP[S]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[InlineConstantMutator]MSP[N] }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR4Mutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( escape != null && escape . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
return false ; MST[rv.CRCR5Mutator]MSP[S] } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[InlineConstantMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.ROR5Mutator]MSP[N]
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.CRCR3Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[EmptyObjectReturnValsMutator]MSP[S]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.UOI3Mutator]MSP[N]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException (
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR4Mutator]MSP[S] return false ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
return header != null ? header . clone () : null ; MST[ReturnValsMutator]MSP[N] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
return false ; } return true ; MST[rv.CRCR2Mutator]MSP[S] } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.ROR5Mutator]MSP[N]
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] sb . append ( lr_7 ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.UOI3Mutator]MSP[N]
if ( isQuoting () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { MST[rv.ROR5Mutator]MSP[S] if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.ABSMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[InlineConstantMutator]MSP[N] int result = 1 ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N]
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException (
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[experimental.NakedReceiverMutator]MSP[S]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR4Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR1Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR2Mutator]MSP[N] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR3Mutator]MSP[S]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR6Mutator]MSP[S] } public boolean isNullHandling () { return nullString != null ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[NegateConditionalsMutator]MSP[N]
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isLineBreak ( commentStart ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_19 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.UOI3Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException (
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ABSMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N]
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.ROR5Mutator]MSP[S] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.UOI2Mutator]MSP[N] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.ROR5Mutator]MSP[N] }
if( recordSeparator != null ) { sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( lr_7 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR5Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR6Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.UOI3Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR5Mutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_15 + commentStart + lr_12 ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.ROR5Mutator]MSP[S] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( delimiter != other . delimiter ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.UOI3Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_17 ) ; }
if( recordSeparator != null ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR2Mutator]MSP[N] }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) { MST[rv.ROR1Mutator]MSP[N]
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.UOI3Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; MST[ConstructorCallMutator]MSP[S] } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( isQuoting () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
if ( getIgnoreSurroundingSpaces () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { sb . append ( ' ' ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR1Mutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; MST[ConstructorCallMutator]MSP[N] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[NegateConditionalsMutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[NegateConditionalsMutator]MSP[N] }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[rv.CRCR3Mutator]MSP[N]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[NegateConditionalsMutator]MSP[S] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( isLineBreak ( commentStart ) ) { throw new IllegalArgumentException ( lr_19 ) ; MST[ConstructorCallMutator]MSP[S] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR3Mutator]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
if ( delimiter != other . delimiter ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.ROR5Mutator]MSP[S]
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
if( recordSeparator != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_6 ) . append ( recordSeparator ) . append ( '>' ) ; } if ( getIgnoreEmptyLines () ) { sb . append ( lr_7 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[rv.CRCR6Mutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; MST[ConstructorCallMutator]MSP[S] try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; MST[rv.UOI1Mutator]MSP[N] } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[ReturnValsMutator]MSP[S] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[NegateConditionalsMutator]MSP[N]
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ConstructorCallMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[NonVoidMethodCallMutator]MSP[S]
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N]
if ( this == obj ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String [] getHeader () {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_15 + commentStart + lr_12 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR2Mutator]MSP[S]
throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
if ( this == obj ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! escape . equals ( other . escape ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.ROR2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[NegateConditionalsMutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR3Mutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[rv.CRCR5Mutator]MSP[N] }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException (
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_17 ) ; }
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; } public char getDelimiter () { return delimiter ; MST[ReturnValsMutator]MSP[N] } public Character getEscape () { return escape ; } public String [] getHeader () {
public boolean isQuoting () { return quoteChar != null ; MST[ReturnValsMutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR5Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR4Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( delimiter != other . delimiter ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( set . size () != header . length ) {
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[NegateConditionalsMutator]MSP[S] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException (
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.ROR5Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
} public CSVFormat withRecordSeparator ( final char recordSeparator ) { return withRecordSeparator ( String . valueOf ( recordSeparator ) ) ; MST[rv.ABSMutator]MSP[S] } public CSVFormat withRecordSeparator ( final String recordSeparator ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
} else if ( ! escape . equals ( other . escape ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI1Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_17 ) ; }
} else if ( ! quoteChar . equals ( other . quoteChar ) ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( commentStart == null ) { if ( other . commentStart != null ) { return false ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[rv.CRCR1Mutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR3Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; MST[rv.AOR1Mutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[InlineConstantMutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.UOI3Mutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[ReturnValsMutator]MSP[N] }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_15 + commentStart + lr_12 ) ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withSkipHeaderRecord ( final boolean skipHeaderRecord ) { return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI1Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR3Mutator]MSP[N]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N]
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ; MST[InlineConstantMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR4Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[rv.ROR3Mutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[ReturnValsMutator]MSP[S]
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) { MST[rv.ROR2Mutator]MSP[N]
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_15 + commentStart + lr_12 ) ; }
if ( isQuoting () ) { sb . append ( ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[N] sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; MST[ReturnValsMutator]MSP[N] } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; } public String [] getHeader () {
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.UOI2Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return header != null ? header . clone () : null ; MST[NegateConditionalsMutator]MSP[N] } public boolean getIgnoreEmptyLines () { return ignoreEmptyLines ; } public boolean getIgnoreSurroundingSpaces () { return ignoreSurroundingSpaces ; } public String getNullString () { return nullString ; } public Character getQuoteChar () { return quoteChar ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.AOR3Mutator]MSP[N]
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ; MST[rv.CRCR4Mutator]MSP[S]
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; MST[rv.CRCR2Mutator]MSP[N] if ( isEscaping () ) { sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( lr_17 ) ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOR1Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; MST[ConstructorCallMutator]MSP[S] } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S]
if ( isQuoting () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
if ( isLineBreak ( escape ) ) { throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[NullReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR1Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { MST[rv.ROR1Mutator]MSP[S] return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N]
if ( escape != null && escape . equals ( commentStart ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
result = prime * result + delimiter ; MST[rv.ABSMutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[InlineConstantMutator]MSP[N]
public static CSVFormat newFormat ( final char delimiter ) { return new CSVFormat ( delimiter , null , null , null , null , false , false , null , null , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean equals ( final Object obj ) {
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[NegateConditionalsMutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
} else if ( ! escape . equals ( other . escape ) ) { return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ; MST[rv.CRCR1Mutator]MSP[S]
if ( header != null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size () != header . length ) { MST[NegateConditionalsMutator]MSP[N]
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[NegateConditionalsMutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; MST[rv.CRCR6Mutator]MSP[N] } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S]
if ( delimiter != other . delimiter ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( quotePolicy != other . quotePolicy ) { return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + delimiter ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[InlineConstantMutator]MSP[N]
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( isCommentingEnabled () ) { sb . append ( ' ' ) ;
public Quote getQuotePolicy () { return quotePolicy ; } public String getRecordSeparator () { return recordSeparator ; } public boolean getSkipHeaderRecord () { return skipHeaderRecord ; } @Override public int hashCode () { final int prime = 31 ; MST[rv.CRCR3Mutator]MSP[N] int result = 1 ;
if ( isQuoting () ) { sb . append ( ' ' ) ; sb . append ( lr_3 ) . append ( quoteChar ) . append ( '>' ) ; } if ( isCommentingEnabled () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( ' ' ) ;
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; MST[rv.CRCR2Mutator]MSP[S] } if ( isNullHandling () ) { sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[ReturnValsMutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withIgnoreSurroundingSpaces ( final boolean ignoreSurroundingSpaces ) {
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[NegateConditionalsMutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
} catch ( final IOException e ) { throw new IllegalStateException ( e ) ; } } public Character getCommentStart () { return commentStart ; MST[EmptyObjectReturnValsMutator]MSP[S] } public char getDelimiter () { return delimiter ; } public Character getEscape () { return escape ; } public String [] getHeader () {
if ( delimiter != other . delimiter ) { return false ; } if ( quotePolicy != other . quotePolicy ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( quoteChar == null ) { if ( other . quoteChar != null ) { return false ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { if ( other . escape != null ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
sb . append ( lr_4 ) . append ( commentStart ) . append ( '>' ) ; } if ( isNullHandling () ) { MST[NonVoidMethodCallMutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_5 ) . append ( nullString ) . append ( '>' ) ; }
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.CRCR1Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; MST[InlineConstantMutator]MSP[N] return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ; MST[rv.UOI3Mutator]MSP[N]
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.AOD2Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.ROR5Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI4Mutator]MSP[N] ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withNullString ( final String nullString ) {
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
if ( getIgnoreSurroundingSpaces () ) { sb . append ( lr_8 ) ; } sb . append ( lr_9 ) . append ( skipHeaderRecord ) ; if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( ' ' ) ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.AOR3Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
public boolean isQuoting () { return quoteChar != null ; } public CSVParser parse ( final Reader in ) throws IOException { return new CSVParser ( in , this ) ; MST[NullReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
throw new IllegalStateException ( lr_14 + commentStart + lr_12 ) ; } if ( quoteChar != null && quoteChar . equals ( commentStart ) ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S] lr_15 + commentStart + lr_12 ) ; }
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; } public boolean isNullHandling () { return nullString != null ; MST[rv.CRCR5Mutator]MSP[N] }
sb . append ( lr_10 ) . append ( Arrays . toString ( header ) ) ; } return sb . toString () ; } void validate () throws IllegalStateException { if ( quoteChar != null && delimiter == quoteChar . charValue () ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[rv.ABSMutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( escape == null ) { if ( other . escape != null ) { return false ; }
result = prime * result + delimiter ; MST[rv.AOD1Mutator]MSP[N] result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isNullHandling () { return nullString != null ; }
if ( isLineBreak ( escape ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_21 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; }
result = prime * result + ( ( commentStart == null ) ? 0 : commentStart . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] result = prime * result + ( ( escape == null ) ? 0 : escape . hashCode () ) ;
if ( escape != null && escape . equals ( commentStart ) ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
lr_11 + quoteChar + lr_12 ) ; } if ( escape != null && delimiter == escape . charValue () ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalStateException ( lr_13 + escape + lr_12 ) ; } if ( commentStart != null && delimiter == commentStart . charValue () ) {
} else if ( ! commentStart . equals ( other . commentStart ) ) { return false ; } if ( escape == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( other . escape != null ) { return false ; }
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[rv.UOI2Mutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[InlineConstantMutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
throw new IllegalStateException ( lr_18 + Arrays . toString ( header ) ) ; } } } public CSVFormat withCommentStart ( final char commentStart ) { return withCommentStart ( Character . valueOf ( commentStart ) ) ; MST[ReturnValsMutator]MSP[N] } public CSVFormat withCommentStart ( final Character commentStart ) {
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; return out . toString () . trim () ; MST[ReturnValsMutator]MSP[S]
ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withEscape ( final char escape ) { return withEscape ( Character . valueOf ( escape ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CSVFormat withEscape ( final Character escape ) {
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N] result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ;
return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , ignoreSurroundingSpaces , ignoreEmptyLines , recordSeparator , nullString , header , skipHeaderRecord ) ; } public CSVFormat withQuoteChar ( final char quoteChar ) { return withQuoteChar ( Character . valueOf ( quoteChar ) ) ; MST[rv.UOI1Mutator]MSP[N] }
} if ( ignoreEmptyLines != other . ignoreEmptyLines ) { MST[rv.ROR4Mutator]MSP[S] return false ; } if ( recordSeparator == null ) { if ( other . recordSeparator != null ) { return false ; } } else if ( ! recordSeparator . equals ( other . recordSeparator ) ) {
return false ; } return true ; } public String format ( final Object ... values ) { final StringWriter out = new StringWriter () ; try { new CSVPrinter ( out , this ) . printRecord ( values ) ; MST[VoidMethodCallMutator]MSP[S] return out . toString () . trim () ;
if ( this == obj ) { return true ; MST[ReturnValsMutator]MSP[S] } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; } final CSVFormat other = ( CSVFormat ) obj ;
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape , MST[rv.UOI3Mutator]MSP[N]
} else if ( ! escape . equals ( other . escape ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( ! Arrays . equals ( header , other . header ) ) { return false ; } if ( ignoreSurroundingSpaces != other . ignoreSurroundingSpaces ) { return false ;
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N]
public CSVFormat withQuoteChar ( final Character quoteChar ) { if ( isLineBreak ( quoteChar ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_22 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
sb . append ( lr_1 ) . append ( delimiter ) . append ( '>' ) ; if ( isEscaping () ) { MST[NonVoidMethodCallMutator]MSP[N] sb . append ( ' ' ) ; sb . append ( lr_2 ) . append ( escape ) . append ( '>' ) ; }
if ( escape != null && escape . equals ( commentStart ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalStateException ( lr_16 + commentStart + lr_12 ) ; } if ( escape == null && quotePolicy == Quote . NONE ) { throw new IllegalStateException ( lr_17 ) ; }
private static boolean isLineBreak ( final char c ) { return c == LF || c == CR ; MST[rv.CRCR1Mutator]MSP[N] } private static boolean isLineBreak ( final Character c ) { return c != null && isLineBreak ( c . charValue () ) ; }
result = prime * result + delimiter ; result = prime * result + ( ( quotePolicy == null ) ? 0 : quotePolicy . hashCode () ) ; result = prime * result + ( ( quoteChar == null ) ? 0 : quoteChar . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[InlineConstantMutator]MSP[N]
public CSVFormat withDelimiter ( final char delimiter ) { if ( isLineBreak ( delimiter ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_20 ) ; } return new CSVFormat ( delimiter , quoteChar , quotePolicy , commentStart , escape ,
if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass () != obj . getClass () ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } final CSVFormat other = ( CSVFormat ) obj ;
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[N]
result = prime * result + Arrays . hashCode ( header ) ; return result ; } public boolean isCommentingEnabled () { return commentStart != null ; } public boolean isEscaping () { return escape != null ; MST[InlineConstantMutator]MSP[S] } public boolean isNullHandling () { return nullString != null ; }
result = prime * result + ( ignoreSurroundingSpaces ? 1231 : 1237 ) ; MST[rv.UOI3Mutator]MSP[N] result = prime * result + ( ignoreEmptyLines ? 1231 : 1237 ) ; result = prime * result + ( ( recordSeparator == null ) ? 0 : recordSeparator . hashCode () ) ;
