return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR4Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ABSMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR1Mutator]MSP[] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR6Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.UOI2Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI1Mutator]MSP[] parseEncapsulatedToken ( token ) ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR1Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR2Mutator]MSP[]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ABSMutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR4Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR3Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
case 'n' : return LF ; MST[rv.CRCR6Mutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR4Mutator]MSP[] return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR5Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR5Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR3Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR1Mutator]MSP[]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[PrimitiveReturnsMutator]MSP[]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ABSMutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { while ( true ) { c = in . read () ;
if ( isDelimiter ( c ) ) { MST[rv.ROR2Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR5Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR1Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI4Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
if ( isDelimiter ( c ) ) { MST[rv.ROR2Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI2Mutator]MSP[] case 'r' : return CR ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR3Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR6Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR3Mutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR5Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR5Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR4Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR3Mutator]MSP[]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[NonVoidMethodCallMutator]MSP[] } boolean isStartOfLine ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI2Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[]
final String line = in . readLine () ; MST[NonVoidMethodCallMutator]MSP[] if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR3Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
lastChar = c ; MST[rv.UOI2Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI2Mutator]MSP[] } }
return c == null ? DISABLED : c . charValue () ; MST[PrimitiveReturnsMutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR1Mutator]MSP[]
} else if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[NegateConditionalsMutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == escape ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI1Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR5Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR4Mutator]MSP[] } boolean isClosed () {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[NegateConditionalsMutator]MSP[]
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI1Mutator]MSP[] } } else if ( isQuoteChar ( c ) ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR4Mutator]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; MST[rv.UOI1Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI2Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI4Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI3Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.ROR1Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR5Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR4Mutator]MSP[] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR4Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return c == null ? DISABLED : c . charValue () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI1Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
return ch == escape ; MST[rv.CRCR2Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ; return token ; } } }
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[InlineConstantMutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR3Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI3Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[] } boolean isClosed () {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR4Mutator]MSP[]
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOD2Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
} else if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR5Mutator]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[PrimitiveReturnsMutator]MSP[] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR5Mutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
case 'n' : return LF ; MST[ReturnValsMutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; MST[NullReturnValsMutator]MSP[] } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI2Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR2Mutator]MSP[] return token ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[] } boolean isClosed () {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI4Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR4Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[NegateConditionalsMutator]MSP[] } boolean isClosed () {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ABSMutator]MSP[] } boolean isStartOfLine ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR2Mutator]MSP[]
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EOF ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI4Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR4Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI3Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI3Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.ABSMutator]MSP[] } } return token ; }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isDelimiter ( c ) ) { MST[rv.UOI1Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; MST[experimental.MemberVariableMutator]MSP[] return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NonVoidMethodCallMutator]MSP[]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.ABSMutator]MSP[] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] parseEncapsulatedToken ( token ) ;
return ch == escape ; MST[InlineConstantMutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI1Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[NegateConditionalsMutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI2Mutator]MSP[] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[NegateConditionalsMutator]MSP[] buffer . setLength ( length ) ; } }
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR1Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR1Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[NegateConditionalsMutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR6Mutator]MSP[]
token . isReady = true ; MST[rv.CRCR4Mutator]MSP[] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR3Mutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI4Mutator]MSP[] } else { while ( true ) { c = in . read () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR3Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; MST[experimental.MemberVariableMutator]MSP[] token . isReady = true ; return token ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR5Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI4Mutator]MSP[] } boolean isEscape ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EOF ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR1Mutator]MSP[] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI3Mutator]MSP[] } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR4Mutator]MSP[]
lastChar = c ; MST[rv.UOI3Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI4Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
token . content . append ( ( char ) ch ) ; MST[rv.UOI1Mutator]MSP[] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[PrimitiveReturnsMutator]MSP[] case END_OF_STREAM :
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR1Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR4Mutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR1Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR1Mutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[InlineConstantMutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI2Mutator]MSP[]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI4Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR6Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR2Mutator]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ABSMutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI3Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; MST[rv.CRCR3Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR5Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR3Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[experimental.NakedReceiverMutator]MSP[] } } else if ( isQuoteChar ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[]
case 'n' : return LF ; MST[rv.CRCR2Mutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR5Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI4Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[rv.ROR3Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == escape ; MST[rv.CRCR6Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI1Mutator]MSP[] } ch = in . read () ; } else {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI4Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; MST[ReturnValsMutator]MSP[] } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[NegateConditionalsMutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR4Mutator]MSP[]
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI3Mutator]MSP[] } } } private char mapNullToDisabled ( final Character c ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI1Mutator]MSP[] } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[BooleanTrueReturnValsMutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ABSMutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI4Mutator]MSP[] } } else if ( isQuoteChar ( c ) ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR1Mutator]MSP[] parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI4Mutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == escape ; MST[rv.UOI4Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI4Mutator]MSP[] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI1Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI2Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR1Mutator]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI4Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI2Mutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR1Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.UOI2Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR1Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ABSMutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.UOI4Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[NegateConditionalsMutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI1Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI1Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR2Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) ch ) ; MST[rv.ABSMutator]MSP[] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR3Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR2Mutator]MSP[] } boolean isClosed () {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EOF ; return token ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR2Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR4Mutator]MSP[] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[InlineConstantMutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[NegateConditionalsMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI2Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; MST[NonVoidMethodCallMutator]MSP[] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[NegateConditionalsMutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI4Mutator]MSP[] case 'r' : return CR ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR1Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR3Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; MST[ReturnValsMutator]MSP[] }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.CRCR4Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR3Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI2Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NonVoidMethodCallMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[PrimitiveReturnsMutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[InlineConstantMutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { MST[rv.UOI3Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR2Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR4Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[]
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[NonVoidMethodCallMutator]MSP[]
case 'n' : return LF ; MST[rv.CRCR4Mutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[NegateConditionalsMutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR3Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR1Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[]
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.ROR2Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI3Mutator]MSP[] } ch = in . read () ; } else {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI3Mutator]MSP[] } }
final String line = in . readLine () ; if ( line == null ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NonVoidMethodCallMutator]MSP[]
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[NonVoidMethodCallMutator]MSP[] } ch = in . read () ; } else {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI4Mutator]MSP[] } boolean isClosed () {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.UOI2Mutator]MSP[]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR5Mutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR6Mutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR3Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR1Mutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 'r' : return CR ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ABSMutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 'r' : return CR ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR3Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; MST[NonVoidMethodCallMutator]MSP[] boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_7]MSP[] case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI4Mutator]MSP[] parseEncapsulatedToken ( token ) ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_6]MSP[] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_9]MSP[] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_8]MSP[] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case 'r' : return CR ;
token . isReady = true ; MST[rv.CRCR2Mutator]MSP[] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_5]MSP[] case 'r' : return CR ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_4]MSP[] case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NegateConditionalsMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[] } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR1Mutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI2Mutator]MSP[] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI2Mutator]MSP[] } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR4Mutator]MSP[]
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[NegateConditionalsMutator]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[InlineConstantMutator]MSP[] } boolean isStartOfLine ( final int ch ) {
token . content . append ( ( char ) ch ) ; MST[rv.UOI3Mutator]MSP[] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI1Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR1Mutator]MSP[] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR5Mutator]MSP[] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR3Mutator]MSP[] buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI2Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { MST[rv.ROR5Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR2Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR2Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR2Mutator]MSP[]
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[NonVoidMethodCallMutator]MSP[] } } } private char mapNullToDisabled ( final Character c ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR4Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI3Mutator]MSP[] } } return token ; }
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR4Mutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR2Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI2Mutator]MSP[] case END_OF_STREAM :
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI3Mutator]MSP[] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ABSMutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[NegateConditionalsMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; MST[ReturnValsMutator]MSP[] } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[NegateConditionalsMutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; MST[rv.UOI3Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI2Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[InlineConstantMutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI3Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[InlineConstantMutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI1Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; MST[PrimitiveReturnsMutator]MSP[] } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR2Mutator]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EOF ; token . isReady = true ; return token ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ABSMutator]MSP[]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; MST[NonVoidMethodCallMutator]MSP[] int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR2Mutator]MSP[] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR3Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.CRCR5Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; MST[rv.CRCR4Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[NegateConditionalsMutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ABSMutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR2Mutator]MSP[]
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI4Mutator]MSP[] } } return token ; }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI4Mutator]MSP[] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[NegateConditionalsMutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR6Mutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[experimental.NakedReceiverMutator]MSP[] } } } private char mapNullToDisabled ( final Character c ) {
if ( isDelimiter ( c ) ) { MST[rv.ROR3Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI3Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR5Mutator]MSP[]
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[InlineConstantMutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; MST[NonVoidMethodCallMutator]MSP[] token . content . append ( comment ) ; token . type = COMMENT ;
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ABSMutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR5Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI4Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR3Mutator]MSP[]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR4Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI2Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI2Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR3Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[InlineConstantMutator]MSP[] } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI1Mutator]MSP[] } } } private char mapNullToDisabled ( final Character c ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR5Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR4Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EOF ; return token ; } } }
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; MST[NullReturnValsMutator]MSP[] } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
if ( isDelimiter ( c ) ) { MST[rv.ROR1Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EOF ; return token ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI3Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[InlineConstantMutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI4Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR4Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI1Mutator]MSP[] } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR4Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR4Mutator]MSP[]
return in . isClosed () ; MST[NonVoidMethodCallMutator]MSP[] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[]
} else if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[NonVoidMethodCallMutator]MSP[] } else { while ( true ) { c = in . read () ;
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; MST[ReturnValsMutator]MSP[] } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI2Mutator]MSP[] } else { while ( true ) { c = in . read () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI4Mutator]MSP[] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR1Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR2Mutator]MSP[]
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ABSMutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR3Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR5Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI1Mutator]MSP[] } }
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
lastChar = c ; MST[rv.UOI1Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR3Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR6Mutator]MSP[]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI1Mutator]MSP[] case 'r' : return CR ;
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[InlineConstantMutator]MSP[] } else { parseSimpleToken ( token , c ) ; } } return token ; }
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR3Mutator]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR4Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR2Mutator]MSP[] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ABSMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR6Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NegateConditionalsMutator]MSP[]
token . isReady = true ; MST[experimental.MemberVariableMutator]MSP[] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR4Mutator]MSP[] } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { MST[rv.UOI1Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[NegateConditionalsMutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI1Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI3Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ; MST[NonVoidMethodCallMutator]MSP[]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR1Mutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR5Mutator]MSP[] return token ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EOF ; return token ; } } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.ABSMutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; MST[NonVoidMethodCallMutator]MSP[] } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR5Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR4Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR6Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[experimental.MemberVariableMutator]MSP[] } else { parseSimpleToken ( token , c ) ; } } return token ; }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[NonVoidMethodCallMutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI2Mutator]MSP[] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI2Mutator]MSP[] } } else if ( isQuoteChar ( c ) ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[NegateConditionalsMutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.ROR5Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.ROR3Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI2Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ABSMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI2Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR3Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[] } boolean isClosed () {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR3Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI3Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[InlineConstantMutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR1Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EOF ;
if ( isQuoteChar ( in . lookAhead () ) ) { MST[NonVoidMethodCallMutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { MST[rv.UOI4Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] parseEncapsulatedToken ( token ) ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; MST[NullReturnValsMutator]MSP[] } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[NegateConditionalsMutator]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI4Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR3Mutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOD1Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR1Mutator]MSP[] buffer . setLength ( length ) ; } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR5Mutator]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR2Mutator]MSP[] } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[NegateConditionalsMutator]MSP[] parseEncapsulatedToken ( token ) ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ABSMutator]MSP[] buffer . setLength ( length ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[ReturnValsMutator]MSP[]
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; MST[experimental.MemberVariableMutator]MSP[] break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[] token . type = EOF ; return token ; } } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[ReturnValsMutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI1Mutator]MSP[] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR3Mutator]MSP[] return token ;
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR4Mutator]MSP[] } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR2Mutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NegateConditionalsMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ; MST[NullReturnValsMutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[experimental.MemberVariableMutator]MSP[] return token ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI2Mutator]MSP[] buffer . setLength ( length ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR6Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI4Mutator]MSP[] case END_OF_STREAM :
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[ConditionalsBoundaryMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR5Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI1Mutator]MSP[] } } return token ; }
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[NonVoidMethodCallMutator]MSP[] } } else if ( isQuoteChar ( c ) ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR2Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[rv.ABSMutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ; MST[experimental.MemberVariableMutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.UOI1Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[] } boolean isClosed () {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isStartOfLine ( final int ch ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EOF ; return token ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR5Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR3Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR3Mutator]MSP[] } boolean isEscape ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR2Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR5Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[]
token . isReady = true ; MST[rv.CRCR5Mutator]MSP[] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR5Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
case 'n' : return LF ; MST[rv.CRCR1Mutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR5Mutator]MSP[] } else { parseSimpleToken ( token , c ) ; } } return token ; }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI3Mutator]MSP[] buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR4Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI2Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR2Mutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ; MST[ReturnValsMutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR5Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI2Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR5Mutator]MSP[] } boolean isClosed () {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ABSMutator]MSP[]
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI4Mutator]MSP[] } } } private char mapNullToDisabled ( final Character c ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return c == null ? DISABLED : c . charValue () ; MST[NonVoidMethodCallMutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR2Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[NegateConditionalsMutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR1Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI3Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[experimental.NakedReceiverMutator]MSP[] } ch = in . read () ; } else {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR2Mutator]MSP[] } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI3Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; MST[experimental.MemberVariableMutator]MSP[] return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI2Mutator]MSP[] } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR4Mutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[NonVoidMethodCallMutator]MSP[] } }
token . content . append ( ( char ) ch ) ; MST[experimental.NakedReceiverMutator]MSP[] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR1Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ; return token ; } } }
return ch == escape ; MST[rv.ROR4Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR5Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; MST[NonVoidMethodCallMutator]MSP[] } else {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR2Mutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI3Mutator]MSP[] } boolean isClosed () {
} else if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI3Mutator]MSP[] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
return token ; MST[NullReturnValsMutator]MSP[] } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; MST[NonVoidMethodCallMutator]MSP[] switch ( ch ) { case 'r' : return CR ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR1Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI1Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR1Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ; token . isReady = true ; return token ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI1Mutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
} else if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[InlineConstantMutator]MSP[] return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; MST[NonVoidMethodCallMutator]MSP[] if ( unescaped == Constants . END_OF_STREAM ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI3Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.CRCR6Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI3Mutator]MSP[] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ABSMutator]MSP[]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[NonVoidMethodCallMutator]MSP[] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[MathMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return in . isClosed () ; MST[ReturnValsMutator]MSP[] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; MST[rv.UOI2Mutator]MSP[] } } return token ; }
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI1Mutator]MSP[] case END_OF_STREAM :
return c == null ? DISABLED : c . charValue () ; MST[NegateConditionalsMutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI2Mutator]MSP[] if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ; MST[NonVoidMethodCallMutator]MSP[]
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[ReturnValsMutator]MSP[] case END_OF_STREAM :
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI1Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR4Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR2Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR1Mutator]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.UOI3Mutator]MSP[] case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ROR1Mutator]MSP[] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR4Mutator]MSP[] buffer . setLength ( length ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.CRCR5Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; MST[InlineConstantMutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI4Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
final long startLineNumber = getCurrentLineNumber () ; MST[NonVoidMethodCallMutator]MSP[] int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[NegateConditionalsMutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[rv.UOI4Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; MST[experimental.NakedReceiverMutator]MSP[] token . type = COMMENT ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.UOI1Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR3Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[InlineConstantMutator]MSP[]
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ABSMutator]MSP[]
return c == null ? DISABLED : c . charValue () ; MST[rv.ROR5Mutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR3Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[ReturnValsMutator]MSP[] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[ReturnValsMutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR1Mutator]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR5Mutator]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR4Mutator]MSP[] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; MST[NonVoidMethodCallMutator]MSP[] eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ABSMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isStartOfLine ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; MST[NonVoidMethodCallMutator]MSP[] if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR2Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.ABSMutator]MSP[] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[NegateConditionalsMutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR4Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; MST[NonVoidMethodCallMutator]MSP[] token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR3Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR5Mutator]MSP[] } boolean isEscape ( final int ch ) {
case 'n' : return LF ; MST[rv.CRCR5Mutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
token . isReady = true ; MST[rv.CRCR3Mutator]MSP[] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR1Mutator]MSP[]
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.ABSMutator]MSP[] case END_OF_STREAM :
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR1Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ; return token ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ABSMutator]MSP[]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[] token . type = EOF ; return token ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[NegateConditionalsMutator]MSP[] } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[NegateConditionalsMutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.RemoveSwitchMutator_10]MSP[] case 'r' : return CR ;
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI4Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR2Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; MST[rv.ROR3Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR3Mutator]MSP[]
case 'n' : return LF ; MST[PrimitiveReturnsMutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI4Mutator]MSP[] } ch = in . read () ; } else {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI4Mutator]MSP[] } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR3Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR4Mutator]MSP[]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI2Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR5Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; MST[NonVoidMethodCallMutator]MSP[] } return ch == LF || ch == CR ; } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI4Mutator]MSP[] } boolean isClosed () {
if ( isDelimiter ( c ) ) { MST[rv.ROR1Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR4Mutator]MSP[] } boolean isClosed () {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[NonVoidMethodCallMutator]MSP[] buffer . setLength ( length ) ; } }
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR5Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR4Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR3Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[NonVoidMethodCallMutator]MSP[] } boolean isStartOfLine ( final int ch ) {
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR3Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI2Mutator]MSP[]
throw new IOException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[] default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . content . append ( ( char ) ch ) ; MST[rv.UOI4Mutator]MSP[] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ABSMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isClosed () {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI1Mutator]MSP[] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR3Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR2Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[experimental.SwitchMutator]MSP[] case 'r' : return CR ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[NegateConditionalsMutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EOF ; return token ; } } }
return c == null ? DISABLED : c . charValue () ; MST[ReturnValsMutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[ReturnValsMutator]MSP[] } boolean isClosed () {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR6Mutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ABSMutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
case 'n' : return LF ; MST[InlineConstantMutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[NegateConditionalsMutator]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR5Mutator]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( readEndOfLine ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR3Mutator]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR1Mutator]MSP[] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI3Mutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.ROR1Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI4Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.ABSMutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final String line = in . readLine () ; if ( line == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
ch == escape || ch == quoteChar || ch == commentStart ; } void close () throws IOException { in . close () ; MST[VoidMethodCallMutator]MSP[] }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR4Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR5Mutator]MSP[] parseEncapsulatedToken ( token ) ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ABSMutator]MSP[] } boolean isStartOfLine ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI3Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EOF ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ABSMutator]MSP[] } boolean isClosed () {
if ( isDelimiter ( c ) ) { MST[rv.UOI2Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[InlineConstantMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.ROR5Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR2Mutator]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR4Mutator]MSP[] } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI4Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[ReturnValsMutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR5Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.ABSMutator]MSP[] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
if ( isDelimiter ( c ) ) { MST[rv.ROR4Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; MST[ReturnValsMutator]MSP[] } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR4Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR4Mutator]MSP[]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI3Mutator]MSP[]
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.ABSMutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
token . isReady = true ; MST[InlineConstantMutator]MSP[] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR2Mutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI1Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
} else if ( readEndOfLine ( c ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] parseEncapsulatedToken ( token ) ;
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.UOI3Mutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.ROR2Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.ABSMutator]MSP[] } else { while ( true ) { c = in . read () ;
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR2Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EOF ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[ReturnValsMutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
lastChar = c ; MST[rv.UOI4Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR5Mutator]MSP[]
token . content . append ( ( char ) ch ) ; MST[rv.UOI2Mutator]MSP[] ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
} else if ( readEndOfLine ( c ) ) { MST[rv.ABSMutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR2Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.UOI4Mutator]MSP[] } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI1Mutator]MSP[] } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.CRCR2Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ABSMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI2Mutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[NonVoidMethodCallMutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.UOI3Mutator]MSP[] parseEncapsulatedToken ( token ) ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR2Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR5Mutator]MSP[]
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; MST[experimental.MemberVariableMutator]MSP[] return token ; } } }
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.ROR5Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[NegateConditionalsMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; MST[NonVoidMethodCallMutator]MSP[] token . type = COMMENT ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ABSMutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
case 'n' : return LF ; MST[rv.CRCR3Mutator]MSP[] case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; case END_OF_STREAM :
if ( isDelimiter ( c ) ) { MST[rv.ROR4Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[VoidMethodCallMutator]MSP[] } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.CRCR2Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.ROR4Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR6Mutator]MSP[] return token ;
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; MST[NullReturnValsMutator]MSP[] }
return ch == escape ; MST[rv.ROR1Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR6Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI2Mutator]MSP[] } ch = in . read () ; } else {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.UOI2Mutator]MSP[] } }
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.UOI2Mutator]MSP[] } } } private char mapNullToDisabled ( final Character c ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR5Mutator]MSP[]
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.UOI4Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR3Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isDelimiter ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR5Mutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[NegateConditionalsMutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI1Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ABSMutator]MSP[] parseEncapsulatedToken ( token ) ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI3Mutator]MSP[]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[rv.UOI3Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR4Mutator]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR3Mutator]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR1Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR6Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[rv.UOI2Mutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return ch == escape ; MST[rv.ABSMutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR5Mutator]MSP[]
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI3Mutator]MSP[] } else { while ( true ) { c = in . read () ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buffer . setLength ( length ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR2Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR2Mutator]MSP[] } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI3Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR3Mutator]MSP[] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR3Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.ABSMutator]MSP[] } } else if ( isQuoteChar ( c ) ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[NegateConditionalsMutator]MSP[]
return c == null ? DISABLED : c . charValue () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR2Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR1Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR2Mutator]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR2Mutator]MSP[] } boolean isClosed () {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[rv.UOI1Mutator]MSP[] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; MST[NullReturnValsMutator]MSP[] } } }
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ABSMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.UOI3Mutator]MSP[] } } else if ( isQuoteChar ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI4Mutator]MSP[]
return ch == escape ; MST[ReturnValsMutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.AOR4Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI3Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
return ch == escape ; MST[NegateConditionalsMutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { MST[NegateConditionalsMutator]MSP[] if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[rv.UOI3Mutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return in . isClosed () ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR2Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isDelimiter ( c ) ) { MST[rv.ABSMutator]MSP[] token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.AOR2Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI1Mutator]MSP[] } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[InlineConstantMutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
final String line = in . readLine () ; if ( line == null ) { token . type = EOF ; return token ; } final String comment = line . trim () ; MST[experimental.NakedReceiverMutator]MSP[] token . content . append ( comment ) ; token . type = COMMENT ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.CRCR5Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
case 'n' : return LF ; case 't' : return TAB ; case 'b' : return BACKSPACE ; case 'f' : return FF ; case CR : case LF : case FF : case TAB : case BACKSPACE : return ch ; MST[rv.UOI3Mutator]MSP[] case END_OF_STREAM :
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[MathMutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { MST[NegateConditionalsMutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.UOI1Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { MST[rv.ROR5Mutator]MSP[] if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.AOD2Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.ROR2Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR3Mutator]MSP[] } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[InlineConstantMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI4Mutator]MSP[]
return c == null ? DISABLED : c . charValue () ; MST[rv.CRCR2Mutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR4Mutator]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; MST[NullReturnValsMutator]MSP[] } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
return ch == escape ; MST[rv.ROR5Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { MST[rv.ROR1Mutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return ch == escape ; MST[rv.CRCR1Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { trimTrailingSpaces ( token . content ) ; MST[VoidMethodCallMutator]MSP[] } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR1Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return c == null ? DISABLED : c . charValue () ; MST[InlineConstantMutator]MSP[] } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.CRCR1Mutator]MSP[]
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR3Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI4Mutator]MSP[]
if ( isDelimiter ( c ) ) { MST[rv.ROR5Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; MST[rv.UOI3Mutator]MSP[] } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.ROR1Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[NegateConditionalsMutator]MSP[] } boolean isStartOfLine ( final int ch ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.ROR4Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR1Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ABSMutator]MSP[] } boolean isClosed () {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[NonVoidMethodCallMutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( isEndOfFile ( c ) ) { throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; MST[rv.ABSMutator]MSP[] } } } private char mapNullToDisabled ( final Character c ) {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR4Mutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[ReturnValsMutator]MSP[]
} else if ( isEndOfFile ( c ) ) { MST[NegateConditionalsMutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { MST[NegateConditionalsMutator]MSP[] final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { MST[rv.ABSMutator]MSP[] case 'r' : return CR ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ABSMutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.UOI3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; MST[rv.ABSMutator]MSP[] } }
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI3Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR6Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR6Mutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; MST[ReturnValsMutator]MSP[] } else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; MST[rv.CRCR6Mutator]MSP[] break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
if ( isQuoteChar ( in . lookAhead () ) ) { MST[rv.ROR5Mutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ; MST[rv.CRCR3Mutator]MSP[]
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ROR1Mutator]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; MST[rv.ABSMutator]MSP[] } }
lastChar = c ; c = in . read () ; MST[NonVoidMethodCallMutator]MSP[] eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR3Mutator]MSP[] } else { parseSimpleToken ( token , c ) ; } } return token ; }
lastChar = c ; MST[rv.ABSMutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; } } }
} else if ( readEndOfLine ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI1Mutator]MSP[] buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI4Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { return ch ; } return END_OF_STREAM ; MST[rv.CRCR1Mutator]MSP[] } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[rv.ROR3Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.ROR3Mutator]MSP[] } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.UOI2Mutator]MSP[] } boolean isClosed () {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI2Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.CRCR6Mutator]MSP[] } boolean isEscape ( final int ch ) {
token . content . append ( ( char ) c ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; } } else if ( isQuoteChar ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.CRCR3Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR2Mutator]MSP[] buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
private Token parseSimpleToken ( final Token token , int ch ) throws IOException { while ( true ) { if ( readEndOfLine ( ch ) ) { MST[rv.ROR5Mutator]MSP[] token . type = EORECORD ; break; } else if ( isEndOfFile ( ch ) ) { token . type = EOF ;
} else if ( isEndOfFile ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.ROR2Mutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR2Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI1Mutator]MSP[]
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.UOI4Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[rv.ABSMutator]MSP[] } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI4Mutator]MSP[] token . type = EOF ; token . isReady = true ; } else { parseSimpleToken ( token , c ) ; } } return token ; }
} else if ( isEndOfFile ( c ) ) { token . type = EOF ; token . isReady = true ; MST[rv.CRCR6Mutator]MSP[] } else { parseSimpleToken ( token , c ) ; } } return token ; }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[rv.ROR2Mutator]MSP[] } boolean isStartOfLine ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI2Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
final long startLineNumber = getCurrentLineNumber () ; int c ; while ( true ) { c = in . read () ; if ( isEscape ( c ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) { MST[rv.UOI1Mutator]MSP[]
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[InlineConstantMutator]MSP[] } boolean isClosed () {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; } else { token . content . append ( ( char ) unescaped ) ; MST[rv.ABSMutator]MSP[] } ch = in . read () ; } else {
throw new IOException ( lr_5 ) ; default: if ( isMetaChar ( ch ) ) { MST[rv.UOI2Mutator]MSP[] return ch ; } return END_OF_STREAM ; } } void trimTrailingSpaces ( final StringBuilder buffer ) { int length = buffer . length () ;
return ch == escape ; MST[rv.CRCR5Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return ch == LF || ch == CR || ch == UNDEFINED ; MST[ReturnValsMutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.CRCR5Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR1Mutator]MSP[]
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.UOI4Mutator]MSP[] buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; MST[rv.UOI1Mutator]MSP[] } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR6Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.UOI1Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { token . type = EOF ; return token ; MST[ReturnValsMutator]MSP[] } } }
return in . isClosed () ; } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isStartOfLine ( final int ch ) {
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ABSMutator]MSP[] token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { MST[rv.UOI3Mutator]MSP[] token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.UOI3Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR5Mutator]MSP[] } boolean isClosed () {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR3Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { MST[rv.ROR3Mutator]MSP[] while ( isWhitespace ( c ) && ! eol ) { c = in . read () ; eol = readEndOfLine ( c ) ; } }
} else if ( readEndOfLine ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
return ch == escape ; MST[rv.UOI2Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ROR5Mutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[InlineConstantMutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI4Mutator]MSP[]
final String line = in . readLine () ; if ( line == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.CRCR6Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[rv.ABSMutator]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return token ; } while ( token . type == INVALID ) { if ( ignoreSurroundingSpaces ) { while ( isWhitespace ( c ) && ! eol ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] c = in . read () ; eol = readEndOfLine ( c ) ; } }
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; MST[InlineConstantMutator]MSP[] } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR2Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[rv.UOI2Mutator]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR5Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; MST[rv.AOR1Mutator]MSP[] } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.ROR4Mutator]MSP[]
return in . isClosed () ; MST[BooleanFalseReturnValsMutator]MSP[] } boolean isWhitespace ( final int ch ) { return ! isDelimiter ( ch ) && Character . isWhitespace ( ( char ) ch ) ; } boolean isStartOfLine ( final int ch ) {
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { MST[rv.ROR3Mutator]MSP[] parseEncapsulatedToken ( token ) ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI4Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.UOI3Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
} else if ( readEndOfLine ( c ) ) { token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { MST[rv.UOI1Mutator]MSP[] throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
lastChar = c ; c = in . read () ; eol = readEndOfLine ( c ) ; if ( isEndOfFile ( c ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EOF ; return token ; } } }
if ( isDelimiter ( c ) ) { token . type = TOKEN ; } else if ( eol ) { MST[rv.ROR4Mutator]MSP[] token . type = EORECORD ; } else if ( isQuoteChar ( c ) ) { parseEncapsulatedToken ( token ) ;
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; MST[experimental.MemberVariableMutator]MSP[] return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.UOI1Mutator]MSP[]
if ( isDelimiter ( c ) ) { token . type = TOKEN ; return token ; } else if ( isEndOfFile ( c ) ) { MST[rv.ROR2Mutator]MSP[] token . type = EOF ; token . isReady = true ; return token ;
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { MST[rv.ROR4Mutator]MSP[] token . type = TOKEN ; break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
final String line = in . readLine () ; if ( line == null ) { MST[rv.ROR5Mutator]MSP[] token . type = EOF ; return token ; } final String comment = line . trim () ; token . content . append ( comment ) ; token . type = COMMENT ;
} else if ( readEndOfLine ( c ) ) { MST[NegateConditionalsMutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
token . isReady = true ; break; } else if ( isDelimiter ( ch ) ) { token . type = TOKEN ; MST[experimental.MemberVariableMutator]MSP[] break; } else if ( isEscape ( ch ) ) { final int unescaped = readEscape () ; if ( unescaped == Constants . END_OF_STREAM ) {
token . content . append ( ( char ) ch ) ; ch = in . read () ; } } if ( ignoreSurroundingSpaces ) { MST[rv.ROR2Mutator]MSP[] trimTrailingSpaces ( token . content ) ; } return token ; } private Token parseEncapsulatedToken ( final Token token ) throws IOException {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ch = in . read () ; } return ch == LF || ch == CR ; } boolean isClosed () {
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR6Mutator]MSP[] } boolean isClosed () {
token . content . append ( ( char ) ch ) . append ( ( char ) in . getLastChar () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { token . content . append ( ( char ) unescaped ) ; } ch = in . read () ; } else {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR4Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
return ch == LF || ch == CR || ch == UNDEFINED ; MST[rv.ROR2Mutator]MSP[] } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
} else if ( isEndOfFile ( c ) ) { MST[rv.UOI3Mutator]MSP[] throw new IOException ( lr_3 + startLineNumber + lr_4 ) ; } else { token . content . append ( ( char ) c ) ; } } } private char mapNullToDisabled ( final Character c ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { length = length - 1 ; } if ( length != buffer . length () ) { MST[rv.ROR5Mutator]MSP[] buffer . setLength ( length ) ; } }
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) { MST[rv.ABSMutator]MSP[]
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter || MST[rv.UOI3Mutator]MSP[]
return ch == LF || ch == CR || ch == UNDEFINED ; } boolean isEndOfFile ( final int ch ) { return ch == END_OF_STREAM ; MST[rv.CRCR5Mutator]MSP[] } boolean isDelimiter ( final int ch ) { return ch == delimiter ; } boolean isEscape ( final int ch ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR4Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
return c == null ? DISABLED : c . charValue () ; } long getCurrentLineNumber () { return in . getCurrentLineNumber () ; MST[ReturnValsMutator]MSP[] } int readEscape () throws IOException { final int ch = in . read () ; switch ( ch ) { case 'r' : return CR ;
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.UOI3Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
boolean readEndOfLine ( int ch ) throws IOException { if ( ch == CR && in . lookAhead () == LF ) { ch = in . read () ; } return ch == LF || ch == CR ; MST[rv.CRCR4Mutator]MSP[] } boolean isClosed () {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.ROR1Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
if ( isEndOfFile ( lastChar ) || ( ! isDelimiter ( lastChar ) && isEndOfFile ( c ) ) ) { MST[rv.UOI4Mutator]MSP[] token . type = EOF ; return token ; } if ( isStartOfLine ( lastChar ) && isCommentStart ( c ) ) {
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.ROR4Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
if ( isQuoteChar ( in . lookAhead () ) ) { c = in . read () ; token . content . append ( ( char ) c ) ; MST[rv.UOI1Mutator]MSP[] } else { while ( true ) { c = in . read () ;
return ch == escape ; MST[rv.CRCR3Mutator]MSP[] } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
if ( isQuoteChar ( in . lookAhead () ) ) { MST[NonVoidMethodCallMutator]MSP[] c = in . read () ; token . content . append ( ( char ) c ) ; } else { while ( true ) { c = in . read () ;
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { MST[rv.ROR1Mutator]MSP[] while ( eol && isStartOfLine ( lastChar ) ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) {
Token nextToken ( final Token token ) throws IOException { int lastChar = in . getLastChar () ; int c = in . read () ; boolean eol = readEndOfLine ( c ) ; if ( ignoreEmptyLines ) { while ( eol && isStartOfLine ( lastChar ) ) { MST[rv.UOI1Mutator]MSP[]
} else if ( readEndOfLine ( c ) ) { MST[rv.UOI1Mutator]MSP[] token . type = EORECORD ; return token ; } else if ( ! isWhitespace ( c ) ) { throw new IOException ( lr_1 + getCurrentLineNumber () + lr_2 ) ; } } }
while ( length > 0 && Character . isWhitespace ( buffer . charAt ( length - 1 ) ) ) { MST[rv.CRCR4Mutator]MSP[] length = length - 1 ; } if ( length != buffer . length () ) { buffer . setLength ( length ) ; } }
return ch == escape ; } boolean isQuoteChar ( final int ch ) { return ch == quoteChar ; } boolean isCommentStart ( final int ch ) { return ch == commentStart ; MST[rv.CRCR1Mutator]MSP[] } private boolean isMetaChar ( final int ch ) { return ch == delimiter ||
