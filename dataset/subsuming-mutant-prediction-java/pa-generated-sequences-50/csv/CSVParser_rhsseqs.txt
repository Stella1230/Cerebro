if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI4Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[InlineConstantMutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[InlineConstantMutator]MSP[N]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , this . recordNumber ) ; } return result ; MST[ReturnValsMutator]MSP[N] }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[NegateConditionalsMutator]MSP[N] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[ReturnValsMutator]MSP[S] }
this . lexer . nextToken ( this . reusableToken ) ; MST[ArgumentPropagationMutator]MSP[N] switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[ConstructorCallMutator]MSP[S] }
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[ConstructorCallMutator]MSP[N] }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[NegateConditionalsMutator]MSP[N]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.ABSMutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR3Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR1Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; MST[ConstructorCallMutator]MSP[N] } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; } return records ; MST[ReturnValsMutator]MSP[N] }
sb . append ( Constants . LF ) ; MST[rv.CRCR4Mutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[ReturnValsMutator]MSP[N] }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI1Mutator]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[NonVoidMethodCallMutator]MSP[N] this . recordNumber ) ; } return result ; }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[ReturnValsMutator]MSP[S] } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR1Mutator]MSP[N] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[NegateConditionalsMutator]MSP[N] for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR5Mutator]MSP[N] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
sb . append ( Constants . LF ) ; MST[experimental.NakedReceiverMutator]MSP[S] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI4Mutator]MSP[N] this . recordNumber ) ; } return result ; }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI3Mutator]MSP[S] } public List < CSVRecord > getRecords () throws IOException {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; MST[VoidMethodCallMutator]MSP[N] break; case EOF : if ( this . reusableToken . isReady ) {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR2Mutator]MSP[N] final String comment = sb == null ? null : sb . toString () ;
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; MST[experimental.NakedReceiverMutator]MSP[N] this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR6Mutator]MSP[N] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[rv.ROR5Mutator]MSP[N]
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[rv.ROR5Mutator]MSP[N] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR1Mutator]MSP[S] } }
public void close () throws IOException { if ( this . lexer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI2Mutator]MSP[N] final String comment = sb == null ? null : sb . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR5Mutator]MSP[S] } }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; MST[NonVoidMethodCallMutator]MSP[N] }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( int i = 0 ; i < header . length ; i ++ ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_3]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[NegateConditionalsMutator]MSP[S] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[NegateConditionalsMutator]MSP[N] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[PrimitiveReturnsMutator]MSP[S] } public List < CSVRecord > getRecords () throws IOException {
public void close () throws IOException { if ( this . lexer != null ) { MST[NegateConditionalsMutator]MSP[N] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( int i = 0 ; i < header . length ; i ++ ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.ABSMutator]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI1Mutator]MSP[N] this . recordNumber ) ; } return result ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_4]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[NonVoidMethodCallMutator]MSP[N]
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; MST[VoidMethodCallMutator]MSP[N] Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[NegateConditionalsMutator]MSP[S] } }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; MST[VoidMethodCallMutator]MSP[N] break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR5Mutator]MSP[N] final String comment = sb == null ? null : sb . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI3Mutator]MSP[N] this . recordNumber ) ; } return result ; }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.ABSMutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR3Mutator]MSP[N] final String comment = sb == null ? null : sb . toString () ;
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[ConstructorCallMutator]MSP[S] }
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR2Mutator]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR4Mutator]MSP[S] } }
public void close () throws IOException { if ( this . lexer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ;
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR2Mutator]MSP[N] } }
public static CSVParser parse ( URL url , Charset charset , final CSVFormat format ) throws IOException { Assertions . notNull ( url , lr_4 ) ; Assertions . notNull ( charset , lr_5 ) ; MST[VoidMethodCallMutator]MSP[S] Assertions . notNull ( format , lr_2 ) ;
sb . append ( Constants . LF ) ; MST[rv.CRCR2Mutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; MST[NullReturnValsMutator]MSP[N] } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; MST[ReturnValsMutator]MSP[S] } public Map < String , Integer > getHeaderMap () {
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[rv.ROR5Mutator]MSP[N] header = record . values () ; }
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.ABSMutator]MSP[S] this . recordNumber ) ; } return result ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI3Mutator]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[NonVoidMethodCallMutator]MSP[S] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR2Mutator]MSP[N] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[rv.ROR5Mutator]MSP[N] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[ConstructorCallMutator]MSP[S] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[experimental.MemberVariableMutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[BooleanTrueReturnValsMutator]MSP[N] } private CSVRecord getNextRecord () { try {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N]
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { MST[experimental.MemberVariableMutator]MSP[N] final String input = this . reusableToken . content . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR4Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOD1Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) { MST[rv.ROR4Mutator]MSP[N]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[MathMutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb = new StringBuilder () ; } else {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[ReturnValsMutator]MSP[N] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; MST[ReturnValsMutator]MSP[N] } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; MST[NonVoidMethodCallMutator]MSP[S] } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI4Mutator]MSP[S] } public List < CSVRecord > getRecords () throws IOException {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.ABSMutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[rv.ROR5Mutator]MSP[N] sb = new StringBuilder () ; } else {
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[rv.ROR5Mutator]MSP[N]
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI2Mutator]MSP[S] } public List < CSVRecord > getRecords () throws IOException {
final String nullString = this . format . getNullString () ; MST[NonVoidMethodCallMutator]MSP[S] if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[ConstructorCallMutator]MSP[N] this . recordNumber ) ; } return result ; }
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI1Mutator]MSP[N] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI3Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] header = record . values () ; }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR4Mutator]MSP[S] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[NullReturnValsMutator]MSP[S] }
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] records . add ( rec ) ; } return records ; }
sb . append ( Constants . LF ) ; MST[rv.CRCR1Mutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
sb . append ( Constants . LF ) ; MST[rv.CRCR5Mutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , this . recordNumber ) ; } return result ; MST[NullReturnValsMutator]MSP[N] }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; MST[NonVoidMethodCallMutator]MSP[N] if ( record != null ) { header = record . values () ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[NonVoidMethodCallMutator]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[NegateConditionalsMutator]MSP[S] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; MST[VoidMethodCallMutator]MSP[N] return new CSVParser ( new StringReader ( string ) , format ) ; }
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[ArgumentPropagationMutator]MSP[N] this . recordNumber ) ; } return result ; }
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN ); MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; MST[NonVoidMethodCallMutator]MSP[S] } public Map < String , Integer > getHeaderMap () {
this . lexer . nextToken ( this . reusableToken ) ; MST[NonVoidMethodCallMutator]MSP[N] switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI4Mutator]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
hdrMap = new LinkedHashMap < String , Integer > () ; MST[ConstructorCallMutator]MSP[N] String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; MST[VoidMethodCallMutator]MSP[S] Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; }
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { MST[NonVoidMethodCallMutator]MSP[N] records . add ( rec ) ; } return records ; }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] header = record . values () ; }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; MST[NonVoidMethodCallMutator]MSP[N] if ( formatHeader != null ) {
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[NullReturnValsMutator]MSP[N] }
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { MST[ConstructorCallMutator]MSP[N] final String input = this . reusableToken . content . toString () ;
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[NegateConditionalsMutator]MSP[N] sb = new StringBuilder () ; } else {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI4Mutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) { MST[rv.ROR2Mutator]MSP[N]
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR3Mutator]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[ReturnValsMutator]MSP[N] } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR2Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
public static CSVParser parse ( URL url , Charset charset , final CSVFormat format ) throws IOException { Assertions . notNull ( url , lr_4 ) ; MST[VoidMethodCallMutator]MSP[S] Assertions . notNull ( charset , lr_5 ) ; Assertions . notNull ( format , lr_2 ) ;
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; MST[NonVoidMethodCallMutator]MSP[S] this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
sb . append ( Constants . LF ) ; MST[NonVoidMethodCallMutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[NonVoidMethodCallMutator]MSP[N] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[rv.ROR5Mutator]MSP[N] for ( int i = 0 ; i < header . length ; i ++ ) {
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; MST[ConstructorCallMutator]MSP[N] CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; } return records ; }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; MST[PrimitiveReturnsMutator]MSP[S] } public Map < String , Integer > getHeaderMap () {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI2Mutator]MSP[S] this . recordNumber ) ; } return result ; }
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; MST[VoidMethodCallMutator]MSP[S] return new CSVParser ( new FileReader ( file ) , format ) ; }
public void remove () { throw new UnsupportedOperationException () ; } CSVRecord nextRecord () throws IOException { CSVRecord result = null ; this . record . clear () ; StringBuilder sb = null ; do { this . reusableToken . reset () ; MST[VoidMethodCallMutator]MSP[N]
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; MST[VoidMethodCallMutator]MSP[S] } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
sb . append ( Constants . LF ) ; MST[InlineConstantMutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[ReturnValsMutator]MSP[N] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ; MST[NonVoidMethodCallMutator]MSP[N]
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; MST[NonVoidMethodCallMutator]MSP[N] } return records ; }
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; } return records ; MST[EmptyObjectReturnValsMutator]MSP[N] }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[BooleanFalseReturnValsMutator]MSP[S] } private CSVRecord getNextRecord () { try {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[ConstructorCallMutator]MSP[N] }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
this . addRecordValue () ; MST[VoidMethodCallMutator]MSP[N] } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { sb = new StringBuilder () ; } else {
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR4Mutator]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; MST[ConstructorCallMutator]MSP[N] } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; MST[experimental.MemberVariableMutator]MSP[S] break; } } while ( this . reusableToken . type == TOKEN );
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOD2Mutator]MSP[S] final String comment = sb == null ? null : sb . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[rv.ROR5Mutator]MSP[N] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
sb . append ( Constants . LF ) ; MST[rv.CRCR3Mutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
sb . append ( Constants . LF ) ; MST[rv.CRCR6Mutator]MSP[N] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
public void close () throws IOException { if ( this . lexer != null ) { MST[rv.ROR5Mutator]MSP[S] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[NonVoidMethodCallMutator]MSP[N] this . recordNumber ) ; } return result ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI2Mutator]MSP[N] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[NullReturnValsMutator]MSP[S] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR3Mutator]MSP[N] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[NullReturnValsMutator]MSP[N] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR4Mutator]MSP[N] final String comment = sb == null ? null : sb . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N]
public static CSVParser parse ( URL url , Charset charset , final CSVFormat format ) throws IOException { Assertions . notNull ( url , lr_4 ) ; Assertions . notNull ( charset , lr_5 ) ; Assertions . notNull ( format , lr_2 ) ; MST[VoidMethodCallMutator]MSP[S]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[NonVoidMethodCallMutator]MSP[N] } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ;
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[NegateConditionalsMutator]MSP[N]
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR1Mutator]MSP[N] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.ABSMutator]MSP[S] } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI1Mutator]MSP[S] } public List < CSVRecord > getRecords () throws IOException {
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[NegateConditionalsMutator]MSP[N] header = record . values () ; }
} else { if ( this . format . getSkipHeaderRecord () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] } else {
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb = new StringBuilder () ; } else {
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR3Mutator]MSP[S] } }
if ( ! this . record . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ;
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; MST[ConstructorCallMutator]MSP[S] } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[NegateConditionalsMutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[InlineConstantMutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; MST[NonVoidMethodCallMutator]MSP[N] } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; MST[NonVoidMethodCallMutator]MSP[N] if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; MST[ReturnValsMutator]MSP[N] } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; MST[NullReturnValsMutator]MSP[N] }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[NegateConditionalsMutator]MSP[N] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR3Mutator]MSP[N] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; MST[ConstructorCallMutator]MSP[S] }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR1Mutator]MSP[N] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR5Mutator]MSP[N] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { MST[NegateConditionalsMutator]MSP[N] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR6Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR3Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR5Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.ROR5Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[InlineConstantMutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[ReturnValsMutator]MSP[S] }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[rv.ROR5Mutator]MSP[N] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; MST[experimental.MemberVariableMutator]MSP[N] } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[InlineConstantMutator]MSP[S] }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR2Mutator]MSP[N] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR1Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[ReturnValsMutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; MST[ReturnValsMutator]MSP[N] }
if ( this . current == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR4Mutator]MSP[S] throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; MST[NullReturnValsMutator]MSP[N] } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR5Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[NegateConditionalsMutator]MSP[N] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { MST[rv.ROR5Mutator]MSP[N] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR2Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR4Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR6Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR3Mutator]MSP[N] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; }
public void remove () { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[S] } CSVRecord nextRecord () throws IOException { CSVRecord result = null ; this . record . clear () ; StringBuilder sb = null ; do { this . reusableToken . reset () ;
