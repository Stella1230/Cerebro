if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI4Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[InlineConstantMutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[InlineConstantMutator]MSP[]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[]
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , this . recordNumber ) ; } return result ; MST[ReturnValsMutator]MSP[] }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[NegateConditionalsMutator]MSP[] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[ReturnValsMutator]MSP[] }
this . lexer . nextToken ( this . reusableToken ) ; MST[ArgumentPropagationMutator]MSP[] switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[ConstructorCallMutator]MSP[] }
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[ConstructorCallMutator]MSP[] }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[NonVoidMethodCallMutator]MSP[] } }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI3Mutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[NegateConditionalsMutator]MSP[]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.ABSMutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR3Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI1Mutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR1Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; MST[ConstructorCallMutator]MSP[] } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; } return records ; MST[ReturnValsMutator]MSP[] }
sb . append ( Constants . LF ) ; MST[rv.CRCR4Mutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[ReturnValsMutator]MSP[] }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI1Mutator]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[NonVoidMethodCallMutator]MSP[] this . recordNumber ) ; } return result ; }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[ReturnValsMutator]MSP[] } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR1Mutator]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[NegateConditionalsMutator]MSP[] for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR5Mutator]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
sb . append ( Constants . LF ) ; MST[experimental.NakedReceiverMutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI4Mutator]MSP[] this . recordNumber ) ; } return result ; }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI3Mutator]MSP[] } public List < CSVRecord > getRecords () throws IOException {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; MST[VoidMethodCallMutator]MSP[] break; case EOF : if ( this . reusableToken . isReady ) {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR2Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; MST[experimental.NakedReceiverMutator]MSP[] this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR6Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[rv.ROR5Mutator]MSP[]
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[rv.ROR5Mutator]MSP[] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR1Mutator]MSP[] } }
public void close () throws IOException { if ( this . lexer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; MST[NonVoidMethodCallMutator]MSP[] } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI2Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR5Mutator]MSP[] } }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; MST[NonVoidMethodCallMutator]MSP[] }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( int i = 0 ; i < header . length ; i ++ ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[NegateConditionalsMutator]MSP[] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[NegateConditionalsMutator]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[PrimitiveReturnsMutator]MSP[] } public List < CSVRecord > getRecords () throws IOException {
public void close () throws IOException { if ( this . lexer != null ) { MST[NegateConditionalsMutator]MSP[] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( int i = 0 ; i < header . length ; i ++ ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.ABSMutator]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI1Mutator]MSP[] this . recordNumber ) ; } return result ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[experimental.RemoveSwitchMutator_4]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[NonVoidMethodCallMutator]MSP[]
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; MST[VoidMethodCallMutator]MSP[] Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[NegateConditionalsMutator]MSP[] } }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; MST[VoidMethodCallMutator]MSP[] break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR5Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[]
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI3Mutator]MSP[] this . recordNumber ) ; } return result ; }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.ABSMutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR3Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[ConstructorCallMutator]MSP[] }
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[RemoveConditionalMutator_EQUAL_IF]MSP[] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR2Mutator]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR4Mutator]MSP[] } }
public void close () throws IOException { if ( this . lexer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI1Mutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ;
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR2Mutator]MSP[] } }
public static CSVParser parse ( URL url , Charset charset , final CSVFormat format ) throws IOException { Assertions . notNull ( url , lr_4 ) ; Assertions . notNull ( charset , lr_5 ) ; MST[VoidMethodCallMutator]MSP[] Assertions . notNull ( format , lr_2 ) ;
sb . append ( Constants . LF ) ; MST[rv.CRCR2Mutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; MST[NullReturnValsMutator]MSP[] } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; MST[ReturnValsMutator]MSP[] } public Map < String , Integer > getHeaderMap () {
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[rv.ROR5Mutator]MSP[] header = record . values () ; }
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.ABSMutator]MSP[] this . recordNumber ) ; } return result ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI3Mutator]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[NonVoidMethodCallMutator]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR2Mutator]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[rv.ROR5Mutator]MSP[] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[ConstructorCallMutator]MSP[] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[experimental.MemberVariableMutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[BooleanTrueReturnValsMutator]MSP[] } private CSVRecord getNextRecord () { try {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[]
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { MST[experimental.MemberVariableMutator]MSP[] final String input = this . reusableToken . content . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR4Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR5Mutator]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOD1Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) { MST[rv.ROR4Mutator]MSP[]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[MathMutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] sb = new StringBuilder () ; } else {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[ReturnValsMutator]MSP[] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; MST[ReturnValsMutator]MSP[] } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[ArgumentPropagationMutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[]
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; MST[NonVoidMethodCallMutator]MSP[] } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI4Mutator]MSP[] } public List < CSVRecord > getRecords () throws IOException {
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.ABSMutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[rv.ROR5Mutator]MSP[] sb = new StringBuilder () ; } else {
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[rv.ROR5Mutator]MSP[]
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI2Mutator]MSP[] } public List < CSVRecord > getRecords () throws IOException {
final String nullString = this . format . getNullString () ; MST[NonVoidMethodCallMutator]MSP[] if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ABSMutator]MSP[]
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[ConstructorCallMutator]MSP[] this . recordNumber ) ; } return result ; }
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI1Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.UOI3Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] header = record . values () ; }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[NegateConditionalsMutator]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR4Mutator]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; MST[NullReturnValsMutator]MSP[] }
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] records . add ( rec ) ; } return records ; }
sb . append ( Constants . LF ) ; MST[rv.CRCR1Mutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
sb . append ( Constants . LF ) ; MST[rv.CRCR5Mutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , this . recordNumber ) ; } return result ; MST[NullReturnValsMutator]MSP[] }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; MST[NonVoidMethodCallMutator]MSP[] if ( record != null ) { header = record . values () ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[NonVoidMethodCallMutator]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[NegateConditionalsMutator]MSP[] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; MST[VoidMethodCallMutator]MSP[] return new CSVParser ( new StringReader ( string ) , format ) ; }
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[ArgumentPropagationMutator]MSP[] this . recordNumber ) ; } return result ; }
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN ); MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; MST[NonVoidMethodCallMutator]MSP[] } public Map < String , Integer > getHeaderMap () {
this . lexer . nextToken ( this . reusableToken ) ; MST[NonVoidMethodCallMutator]MSP[] switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI4Mutator]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
hdrMap = new LinkedHashMap < String , Integer > () ; MST[ConstructorCallMutator]MSP[] String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; MST[VoidMethodCallMutator]MSP[] Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new FileReader ( file ) , format ) ; }
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { MST[NonVoidMethodCallMutator]MSP[] records . add ( rec ) ; } return records ; }
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] header = record . values () ; }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[]
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; MST[NonVoidMethodCallMutator]MSP[] if ( formatHeader != null ) {
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[NullReturnValsMutator]MSP[] }
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { MST[ConstructorCallMutator]MSP[] final String input = this . reusableToken . content . toString () ;
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[NegateConditionalsMutator]MSP[] sb = new StringBuilder () ; } else {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI4Mutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) { MST[rv.ROR2Mutator]MSP[]
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR3Mutator]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[ReturnValsMutator]MSP[] } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOR2Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
public static CSVParser parse ( URL url , Charset charset , final CSVFormat format ) throws IOException { Assertions . notNull ( url , lr_4 ) ; MST[VoidMethodCallMutator]MSP[] Assertions . notNull ( charset , lr_5 ) ; Assertions . notNull ( format , lr_2 ) ;
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; MST[NonVoidMethodCallMutator]MSP[] this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[NonVoidMethodCallMutator]MSP[] } }
sb . append ( Constants . LF ) ; MST[NonVoidMethodCallMutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[NonVoidMethodCallMutator]MSP[] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { MST[rv.ROR5Mutator]MSP[] for ( int i = 0 ; i < header . length ; i ++ ) {
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; MST[ConstructorCallMutator]MSP[] CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; } return records ; }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } }
final String nullString = this . format . getNullString () ; if ( nullString == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; } }
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; MST[PrimitiveReturnsMutator]MSP[] } public Map < String , Integer > getHeaderMap () {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[rv.UOI2Mutator]MSP[] this . recordNumber ) ; } return result ; }
public static CSVParser parse ( File file , final CSVFormat format ) throws IOException { Assertions . notNull ( file , lr_1 ) ; Assertions . notNull ( format , lr_2 ) ; MST[VoidMethodCallMutator]MSP[] return new CSVParser ( new FileReader ( file ) , format ) ; }
public void remove () { throw new UnsupportedOperationException () ; } CSVRecord nextRecord () throws IOException { CSVRecord result = null ; this . record . clear () ; StringBuilder sb = null ; do { this . reusableToken . reset () ; MST[VoidMethodCallMutator]MSP[]
public void close () throws IOException { if ( this . lexer != null ) { this . lexer . close () ; MST[VoidMethodCallMutator]MSP[] } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
sb . append ( Constants . LF ) ; MST[InlineConstantMutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[ReturnValsMutator]MSP[] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ; MST[NonVoidMethodCallMutator]MSP[]
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; MST[NonVoidMethodCallMutator]MSP[] } return records ; }
final List < CSVRecord > records = new ArrayList < CSVRecord > () ; CSVRecord rec ; while ( ( rec = this . nextRecord () ) != null ) { records . add ( rec ) ; } return records ; MST[EmptyObjectReturnValsMutator]MSP[] }
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[BooleanFalseReturnValsMutator]MSP[] } private CSVRecord getNextRecord () { try {
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public static CSVParser parse ( String string , final CSVFormat format ) throws IOException { Assertions . notNull ( string , lr_3 ) ; Assertions . notNull ( format , lr_2 ) ; return new CSVParser ( new StringReader ( string ) , format ) ; MST[ConstructorCallMutator]MSP[] }
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; MST[rv.UOI3Mutator]MSP[] } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; } private CSVRecord getNextRecord () { try {
this . addRecordValue () ; MST[VoidMethodCallMutator]MSP[] } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { sb = new StringBuilder () ; } else {
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR4Mutator]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
return new CSVParser ( new InputStreamReader ( url . openStream () , charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; MST[ConstructorCallMutator]MSP[] } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
sb . append ( Constants . LF ) ; } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; MST[experimental.MemberVariableMutator]MSP[] break; } } while ( this . reusableToken . type == TOKEN );
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.AOD2Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[rv.ROR5Mutator]MSP[] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
sb . append ( Constants . LF ) ; MST[rv.CRCR3Mutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
sb . append ( Constants . LF ) ; MST[rv.CRCR6Mutator]MSP[] } sb . append ( this . reusableToken . content ) ; this . reusableToken . type = TOKEN ; break; } } while ( this . reusableToken . type == TOKEN );
public void close () throws IOException { if ( this . lexer != null ) { MST[rv.ROR5Mutator]MSP[] this . lexer . close () ; } } public long getCurrentLineNumber () { return this . lexer . getCurrentLineNumber () ; } public Map < String , Integer > getHeaderMap () {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
result = new CSVRecord ( this . record . toArray ( new String [ this . record . size () ] ) , this . headerMap , comment , MST[NonVoidMethodCallMutator]MSP[] this . recordNumber ) ; } return result ; }
this . lexer . nextToken ( this . reusableToken ) ; switch ( this . reusableToken . type ) { MST[rv.UOI2Mutator]MSP[] case TOKEN : this . addRecordValue () ; break; case EORECORD : this . addRecordValue () ; break; case EOF : if ( this . reusableToken . isReady ) {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; MST[NullReturnValsMutator]MSP[] } public long getRecordNumber () { return this . recordNumber ; } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { MST[rv.ROR3Mutator]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[]
return new CSVParser ( new InputStreamReader ( url . openStream () , MST[NullReturnValsMutator]MSP[] charset == null ? Charset . forName ( lr_6 ) : charset ) , format ) ; } private void addRecordValue () { final String input = this . reusableToken . content . toString () ;
if ( ! this . record . isEmpty () ) { this . recordNumber ++ ; MST[rv.CRCR4Mutator]MSP[] final String comment = sb == null ? null : sb . toString () ;
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[]
public static CSVParser parse ( URL url , Charset charset , final CSVFormat format ) throws IOException { Assertions . notNull ( url , lr_4 ) ; Assertions . notNull ( charset , lr_5 ) ; Assertions . notNull ( format , lr_2 ) ; MST[VoidMethodCallMutator]MSP[]
hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } public boolean isClosed () { return this . lexer . isClosed () ; MST[NonVoidMethodCallMutator]MSP[] } private CSVRecord getNextRecord () { try {
if ( ! this . record . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ;
private Map < String , Integer > initializeHeader () throws IOException { Map < String , Integer > hdrMap = null ; final String [] formatHeader = this . format . getHeader () ; if ( formatHeader != null ) { MST[NegateConditionalsMutator]MSP[]
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { MST[rv.ROR1Mutator]MSP[] final CSVRecord record = this . nextRecord () ; if ( record != null ) { header = record . values () ; }
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.ABSMutator]MSP[] } public List < CSVRecord > getRecords () throws IOException {
} else { if ( this . format . getSkipHeaderRecord () ) { this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[]
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } public long getRecordNumber () { return this . recordNumber ; MST[rv.UOI1Mutator]MSP[] } public List < CSVRecord > getRecords () throws IOException {
hdrMap = new LinkedHashMap < String , Integer > () ; String [] header = null ; if ( formatHeader . length == 0 ) { final CSVRecord record = this . nextRecord () ; if ( record != null ) { MST[NegateConditionalsMutator]MSP[] header = record . values () ; }
} else { if ( this . format . getSkipHeaderRecord () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] this . nextRecord () ; } header = formatHeader ; } if ( header != null ) { for ( int i = 0 ; i < header . length ; i ++ ) {
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[] } else {
this . addRecordValue () ; } break; case INVALID : throw new IOException ( lr_9 + this . getCurrentLineNumber () + lr_10 ) ; case COMMENT : if ( sb == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] sb = new StringBuilder () ; } else {
final String nullString = this . format . getNullString () ; if ( nullString == null ) { this . record . add ( input ) ; } else { this . record . add ( input . equalsIgnoreCase ( nullString ) ? null : input ) ; MST[rv.ROR3Mutator]MSP[] } }
if ( ! this . record . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] this . recordNumber ++ ; final String comment = sb == null ? null : sb . toString () ;
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; MST[ConstructorCallMutator]MSP[] } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[NegateConditionalsMutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[rv.ROR5Mutator]MSP[] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[InlineConstantMutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; MST[NonVoidMethodCallMutator]MSP[] } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; MST[NonVoidMethodCallMutator]MSP[] if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; MST[ReturnValsMutator]MSP[] } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; MST[NullReturnValsMutator]MSP[] }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[NegateConditionalsMutator]MSP[] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR3Mutator]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; MST[ConstructorCallMutator]MSP[] }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[BooleanTrueReturnValsMutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR1Mutator]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR5Mutator]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { MST[NegateConditionalsMutator]MSP[] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR6Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR3Mutator]MSP[] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR3Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR5Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR1Mutator]MSP[] return false ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR5Mutator]MSP[] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.ROR5Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR5Mutator]MSP[] }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR3Mutator]MSP[] }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR6Mutator]MSP[] }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[InlineConstantMutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[ReturnValsMutator]MSP[] }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[NegateConditionalsMutator]MSP[] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { MST[rv.ROR5Mutator]MSP[] next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[rv.CRCR1Mutator]MSP[] }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; MST[experimental.MemberVariableMutator]MSP[] } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; MST[InlineConstantMutator]MSP[] }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR2Mutator]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[NonVoidMethodCallMutator]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR1Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[ReturnValsMutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { throw new NoSuchElementException ( lr_8 ) ; } } return next ; MST[ReturnValsMutator]MSP[] }
if ( this . current == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
CSVRecord next = this . current ; this . current = null ; if ( next == null ) { next = this . getNextRecord () ; if ( next == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NoSuchElementException ( lr_8 ) ; } } return next ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[NegateConditionalsMutator]MSP[] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR4Mutator]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; MST[NullReturnValsMutator]MSP[] } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR4Mutator]MSP[] return false ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[rv.ROR2Mutator]MSP[] return false ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR5Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[NegateConditionalsMutator]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { MST[rv.ROR5Mutator]MSP[] this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR2Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR4Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR6Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NoSuchElementException ( lr_7 ) ; }
if ( this . current == null ) { this . current = this . getNextRecord () ; } return this . current != null ; MST[rv.CRCR3Mutator]MSP[] } public CSVRecord next () { if ( CSVParser . this . isClosed () ) { throw new NoSuchElementException ( lr_7 ) ; }
return CSVParser . this . nextRecord () ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } } public boolean hasNext () { if ( CSVParser . this . isClosed () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; }
public void remove () { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[] } CSVRecord nextRecord () throws IOException { CSVRecord result = null ; this . record . clear () ; StringBuilder sb = null ; do { this . reusableToken . reset () ;
