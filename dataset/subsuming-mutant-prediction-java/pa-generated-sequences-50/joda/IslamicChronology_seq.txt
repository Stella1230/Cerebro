public static IslamicChronology getInstanceUTC () { return INSTANCE_UTC ; } public static IslamicChronology getInstance () { return getInstance ( DateTimeZone . getDefault () , LEAP_YEAR_16_BASED ) ; } public static IslamicChronology getInstance ( DateTimeZone zone ) { return getInstance ( zone , LEAP_YEAR_16_BASED ) ; }
public static IslamicChronology getInstance ( DateTimeZone zone , LeapYearPatternType leapYears ) { if ( zone == null ) { zone = DateTimeZone . getDefault () ; } IslamicChronology chrono ; IslamicChronology [] chronos = cCache . get ( zone ) ; if ( chronos == null ) {
chronos = new IslamicChronology [ 4 ] ; IslamicChronology [] oldChronos = cCache . putIfAbsent ( zone , chronos ) ; if ( oldChronos != null ) { chronos = oldChronos ; } } chrono = chronos [ leapYears . index ] ; if ( chrono == null ) {
synchronized ( chronos ) { chrono = chronos [ leapYears . index ] ; if ( chrono == null ) { if ( zone == DateTimeZone . UTC ) { chrono = new IslamicChronology ( null , null , leapYears ) ;
DateTime lowerLimit = new DateTime ( 1 , 1 , 1 , 0 , 0 , 0 , 0 , chrono ) ; chrono = new IslamicChronology ( LimitChronology . getInstance ( chrono , lowerLimit , null ) , null , leapYears ) ; } else {
chrono = getInstance ( DateTimeZone . UTC , leapYears ) ; chrono = new IslamicChronology ( ZonedChronology . getInstance ( chrono , zone ) , null , leapYears ) ; } chronos [ leapYears . index ] = chrono ; } } } return chrono ; }
private Object readResolve () { Chronology base = getBase () ; return base == null ? getInstanceUTC () : getInstance ( base . getZone () ) ; } public LeapYearPatternType getLeapYearPatternType () { return iLeapYears ; } public Chronology withUTC () { return INSTANCE_UTC ; }
public Chronology withZone ( DateTimeZone zone ) { if ( zone == null ) { zone = DateTimeZone . getDefault () ; } if ( zone == getZone () ) { return this ; } return getInstance ( zone ) ; } public boolean equals ( Object obj ) {
if ( this == obj ) { return true ; } if ( obj instanceof IslamicChronology ) { IslamicChronology chrono = ( IslamicChronology ) obj ; return getLeapYearPatternType () . index == chrono . getLeapYearPatternType () . index && super . equals ( obj ) ; } return false ;
} public int hashCode () { return super . hashCode () * 13 + getLeapYearPatternType () . hashCode () ; } int getYear ( long instant ) { long millisIslamic = instant - MILLIS_YEAR_1 ; long cycles = millisIslamic / MILLIS_PER_CYCLE ; long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE ;
int year = (int) ( ( cycles * CYCLE ) + 1L ) ; long yearMillis = ( isLeapYear ( year ) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR ) ; while ( cycleRemainder >= yearMillis ) { cycleRemainder -= yearMillis ;
yearMillis = ( isLeapYear ( ++ year ) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR ) ; } return year ; } long setYear ( long instant , int year ) { int thisYear = getYear ( instant ) ; int dayOfYear = getDayOfYear ( instant , thisYear ) ;
int millisOfDay = getMillisOfDay ( instant ) ; if ( dayOfYear > 354 && ! isLeapYear ( year ) ) { dayOfYear -- ; } instant = getYearMonthDayMillis ( year , 1 , dayOfYear ) ; instant += millisOfDay ; return instant ; }
long getYearDifference ( long minuendInstant , long subtrahendInstant ) { int minuendYear = getYear ( minuendInstant ) ; int subtrahendYear = getYear ( subtrahendInstant ) ; long minuendRem = minuendInstant - getYearMillis ( minuendYear ) ; long subtrahendRem = subtrahendInstant - getYearMillis ( subtrahendYear ) ;
int difference = minuendYear - subtrahendYear ; if ( minuendRem < subtrahendRem ) { difference -- ; } return difference ; } long getTotalMillisByYearMonth ( int year , int month ) { if ( -- month % 2 == 1 ) { month /= 2 ;
return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH ; } else { month /= 2 ; return month * MILLIS_PER_MONTH_PAIR ; } } int getDayOfMonth ( long millis ) { int doy = getDayOfYear ( millis ) - 1 ; if ( doy == 354 ) { return 30 ; }
return ( doy % MONTH_PAIR_LENGTH ) % LONG_MONTH_LENGTH + 1 ; } boolean isLeapYear ( int year ) { return iLeapYears . isLeapYear ( year ) ; } int getDaysInYearMax () { return 355 ; } int getDaysInYear ( int year ) {
return isLeapYear ( year ) ? 355 : 354 ; } int getDaysInYearMonth ( int year , int month ) { if ( month == 12 && isLeapYear ( year ) ) { return LONG_MONTH_LENGTH ; }
return ( -- month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH ) ; } int getDaysInMonthMax () { return LONG_MONTH_LENGTH ; } int getDaysInMonthMax ( int month ) { if ( month == 12 ) { return LONG_MONTH_LENGTH ; }
return ( -- month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH ) ; } int getMonthOfYear ( long millis , int year ) { int doyZeroBased = (int) ( ( millis - getYearMillis ( year ) ) / DateTimeConstants . MILLIS_PER_DAY ) ;
if ( doyZeroBased == 354 ) { return 12 ; } return ( ( doyZeroBased * 2 ) / MONTH_PAIR_LENGTH ) + 1 ; } long getAverageMillisPerYear () { return MILLIS_PER_YEAR ; } long getAverageMillisPerYearDividedByTwo () { return MILLIS_PER_YEAR / 2 ; } long getAverageMillisPerMonth () { return MILLIS_PER_MONTH ;
} long calculateFirstDayOfYearMillis ( int year ) { if ( year > MAX_YEAR ) { throw new ArithmeticException ( lr_1 + year + lr_2 + MAX_YEAR ) ; } if ( year < MIN_YEAR ) { throw new ArithmeticException ( lr_3 + year + lr_4 + MIN_YEAR ) ; }
year -- ; long cycle = year / CYCLE ; long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE ; int cycleRemainder = ( year % CYCLE ) + 1 ; for ( int i = 1 ; i < cycleRemainder ; i ++ ) {
millis += ( isLeapYear ( i ) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR ) ; } return millis ; } int getMinYear () { return 1 ; } int getMaxYear () { return MAX_YEAR ; } long getApproxMillisAtEpochDividedByTwo () { return ( - MILLIS_YEAR_1 ) / 2 ; }
protected void assemble ( Fields fields ) { if ( getBase () == null ) { super . assemble ( fields ) ; fields . era = ERA_FIELD ; fields . monthOfYear = new BasicMonthOfYearDateTimeField ( this , 12 ) ;
fields . months = fields . monthOfYear . getDurationField () ; } } boolean isLeapYear ( int year ) { int key = 1 << ( year % 30 ) ; return ( ( pattern & key ) > 0 ) ; } private Object readResolve () {
switch ( index ) { case 0 : return LEAP_YEAR_15_BASED ; case 1 : return LEAP_YEAR_16_BASED ; case 2 : return LEAP_YEAR_INDIAN ; case 3 : return LEAP_YEAR_HABASH_AL_HASIB ; default: return this ; } } @Override public boolean equals ( Object obj ) {
if ( obj instanceof LeapYearPatternType ) { return index == ( ( LeapYearPatternType ) obj ) . index ; } return false ; } @Override public int hashCode () { return index ; }
