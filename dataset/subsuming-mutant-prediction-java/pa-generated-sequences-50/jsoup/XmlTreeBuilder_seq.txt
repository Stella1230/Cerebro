ParseSettings defaultSettings () { return ParseSettings . preserveCase ; } @Override protected void initialiseParse ( Reader input , String baseUri , Parser parser ) { super . initialiseParse ( input , baseUri , parser ) ; stack . add ( doc ) ;
doc . outputSettings () . syntax ( Document . OutputSettings . Syntax . xml ) ; } Document parse ( Reader input , String baseUri ) { return parse ( input , baseUri , new Parser ( this ) ) ; }
Document parse ( String input , String baseUri ) { return parse ( new StringReader ( input ) , baseUri , new Parser ( this ) ) ; } @Override protected boolean process ( Token token ) { switch ( token . type ) { case StartTag :
insert ( token . asStartTag () ) ; break; case EndTag : popStackToClose ( token . asEndTag () ) ; break; case Comment : insert ( token . asComment () ) ; break; case Character : insert ( token . asCharacter () ) ; break; case Doctype :
insert ( token . asDoctype () ) ; break; case EOF : break; default: Validate . fail ( lr_1 + token . type ) ; } return true ; } private void insertNode ( Node node ) { currentElement () . appendChild ( node ) ; }
Element insert ( Token . StartTag startTag ) { Tag tag = Tag . valueOf ( startTag . name () , settings ) ; if ( startTag . attributes != null ) startTag . attributes . deduplicate ( settings ) ;
Element el = new Element ( tag , null , settings . normalizeAttributes ( startTag . attributes ) ) ; insertNode ( el ) ; if ( startTag . isSelfClosing () ) { if ( ! tag . isKnownTag () ) tag . setSelfClosing () ; } else {
stack . add ( el ) ; } return el ; } void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData () ) ; Node insert = comment ; if ( commentToken . bogus && comment . isXmlDeclaration () ) {
XmlDeclaration decl = comment . asXmlDeclaration () ; if ( decl != null ) insert = decl ; } insertNode ( insert ) ; } void insert ( Token . Character token ) { final String data = token . getData () ;
insertNode ( token . isCData () ? new CDataNode ( data ) : new TextNode ( data ) ) ; } void insert ( Token . Doctype d ) {
DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName () ) , d . getPublicIdentifier () , d . getSystemIdentifier () ) ; doctypeNode . setPubSysKey ( d . getPubSysKey () ) ; insertNode ( doctypeNode ) ; }
private void popStackToClose ( Token . EndTag endTag ) { String elName = settings . normalizeTag ( endTag . tagName ) ; Element firstFound = null ; for ( int pos = stack . size () - 1 ; pos >= 0 ; pos -- ) {
Element next = stack . get ( pos ) ; if ( next . nodeName () . equals ( elName ) ) { firstFound = next ; break; } } if ( firstFound == null ) return;
for ( int pos = stack . size () - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next == firstFound ) break; } }
List < Node > parseFragment ( String inputFragment , String baseUri , Parser parser ) { initialiseParse ( new StringReader ( inputFragment ) , baseUri , parser ) ; runParser () ; return doc . childNodes () ; }
List < Node > parseFragment ( String inputFragment , Element context , String baseUri , Parser parser ) { return parseFragment ( inputFragment , baseUri , parser ) ; }
