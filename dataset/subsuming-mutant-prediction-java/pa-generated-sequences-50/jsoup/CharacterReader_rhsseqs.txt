reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[N] }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; MST[InlineConstantMutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seek == c ) MST[rv.UOI3Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[NegateConditionalsMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR5Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[rv.ROR1Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[S] return lr_3 ;
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR3Mutator]MSP[N]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR3Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[NonVoidMethodCallMutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[InlineConstantMutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[InlineConstantMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI2Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] if ( count < 1 ) return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[N] bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI3Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[ReturnValsMutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[N] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[MathMutator]MSP[N] } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR1Mutator]MSP[N] int read = 0 ;
return val ; MST[ReturnValsMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { MST[rv.UOI3Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI2Mutator]MSP[N]
return val ; MST[rv.UOI4Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufPos = endPos ; MST[rv.UOI1Mutator]MSP[N] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[S]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR2Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR1Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR4Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR1Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
if ( seek == c ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI2Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[N] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
bufPos += seq . length () ; MST[NonVoidMethodCallMutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR1Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI4Mutator]MSP[N] }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI1Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[NegateConditionalsMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[N] } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) MST[rv.ROR1Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI2Mutator]MSP[S] int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[N] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[NegateConditionalsMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; MST[PrimitiveReturnsMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR3Mutator]MSP[N] } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NonVoidMethodCallMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR3Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; MST[rv.CRCR6Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR4Mutator]MSP[S]
String cached = stringCache [ index ] ; MST[rv.ABSMutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[ReturnValsMutator]MSP[N] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[N] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.ABSMutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[N] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI2Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR6Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[S] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return lr_3 ;
bufPos += seq . length () ; MST[rv.UOI3Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[InlineConstantMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR4Mutator]MSP[S] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI1Mutator]MSP[N] final char [] val = charBuf ;
int hash = 0 ; MST[rv.CRCR6Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI1Mutator]MSP[S] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[N] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[N] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[InlineConstantMutator]MSP[N] }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] stringCache [ index ] = cached ; } else {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.ABSMutator]MSP[S] final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR4Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ReturnValsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR5Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR1Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[InlineConstantMutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[InlineConstantMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR5Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N]
if ( upScan != upTarget ) MST[rv.ROR4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
bufPos = endPos ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[S] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( seek == c ) MST[NegateConditionalsMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[NegateConditionalsMutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[ArgumentPropagationMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI2Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seek == c ) return true ; MST[ReturnValsMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[InlineConstantMutator]MSP[N] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR3Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR3Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI2Mutator]MSP[N] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR5Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR6Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[N] return i - bufPos ; } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[NegateConditionalsMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.ABSMutator]MSP[N] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[N]
int hash = 0 ; MST[rv.CRCR5Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR3Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR5Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[experimental.RemoveIncrementsMutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI2Mutator]MSP[S] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[S]
if ( upScan != upTarget ) MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI1Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[InlineConstantMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[N] bufPos ++ ;
return rangeEquals ( charBuf , start , count , cached ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NonVoidMethodCallMutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[S]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[InlineConstantMutator]MSP[S] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[InlineConstantMutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI4Mutator]MSP[S] final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[S] } } return cached ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufPos = endPos ; MST[rv.UOI2Mutator]MSP[N] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR5Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.UOI4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR4Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos += seq . length () ; return true ; MST[InlineConstantMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[N] } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI4Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[experimental.RemoveIncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S] for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR5Mutator]MSP[N] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[N] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR5Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[S] } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR4Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[N] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI1Mutator]MSP[N] break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[N]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR1Mutator]MSP[N]
return val ; MST[rv.UOI3Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ABSMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR1Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[N] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[S]
if ( seek == c ) MST[rv.UOI3Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR4Mutator]MSP[N] }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[N]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[InlineConstantMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[S] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isEmptyNoBufferUp () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[N]
if ( seek == c ) return true ; MST[rv.CRCR2Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR6Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[N] return lr_3 ;
while ( read <= minReadAheadLen ) { MST[rv.ROR1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI3Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { MST[ConditionalsBoundaryMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR1Mutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR2Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[S] return lr_3 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR2Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.ABSMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR3Mutator]MSP[N] char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR3Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI3Mutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI1Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] } else {
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR4Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI1Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.ABSMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; read += thisRead ; }
private void bufferUp () { MST[rv.CRCR3Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[InlineConstantMutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR3Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ;
if ( seek == c ) return true ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR3Mutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI3Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while ( read <= minReadAheadLen ) { MST[NegateConditionalsMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
bufSplitPoint = 0 ; MST[rv.CRCR6Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[MathMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI1Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR5Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[S] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.ABSMutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { MST[rv.UOI3Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[N]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI4Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD1Mutator]MSP[N] } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR1Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR2Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR4Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private void bufferUp () { if ( readFully ) MST[NegateConditionalsMutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR3Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[N] break OUTER; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOD2Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[N] } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR5Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR1Mutator]MSP[N] while ( count -- != 0 ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR2Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[NegateConditionalsMutator]MSP[N] break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[N] return consumed ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR5Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[NonVoidMethodCallMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[S] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[InlineConstantMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR2Mutator]MSP[N] }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI4Mutator]MSP[N]
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI2Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR5Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] stringCache [ index ] = cached ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ;
String cached = stringCache [ index ] ; MST[rv.UOI2Mutator]MSP[S] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[MathMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) MST[rv.ROR5Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.ABSMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN2Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[MathMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR6Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seek == c ) MST[rv.ROR4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI1Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { MST[rv.ROR4Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.ABSMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR4Mutator]MSP[N] } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR1Mutator]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NegateConditionalsMutator]MSP[S]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.ABSMutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR3Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOR2Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD2Mutator]MSP[N] } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NonVoidMethodCallMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR1Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR2Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[S] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.ABSMutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR6Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[N]
String cached = stringCache [ index ] ; MST[rv.UOI3Mutator]MSP[S] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[S] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[N] break OUTER; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR1Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[N] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI3Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR5Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR2Mutator]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI4Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[NegateConditionalsMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[N] return consumed ;
return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR4Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[InlineConstantMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR1Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[N]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break OUTER; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR4Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR6Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[N]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[IncrementsMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; MST[VoidMethodCallMutator]MSP[N] if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR5Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR3Mutator]MSP[N]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR6Mutator]MSP[N] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR4Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR3Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR5Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[experimental.MemberVariableMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR5Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[IncrementsMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI2Mutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR5Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[S] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NonVoidMethodCallMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
bufPos += seq . length () ; return true ; MST[rv.CRCR4Mutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR6Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[NonVoidMethodCallMutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NegateConditionalsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ;
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR4Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.ABSMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NegateConditionalsMutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.UOI1Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return false ; MST[ReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[InlineConstantMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI2Mutator]MSP[N] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[N] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI3Mutator]MSP[N] final char [] val = charBuf ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[MathMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR5Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[ReturnValsMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR5Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[N] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[ReturnValsMutator]MSP[S] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR5Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR4Mutator]MSP[N] break OUTER; }
if ( seek == c ) MST[rv.ROR3Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI4Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[ReturnValsMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( seek == c ) MST[rv.UOI2Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.ROR5Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR1Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR2Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR1Mutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[N] } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI1Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR4Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; MST[rv.UOI2Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; return consumed ; MST[ReturnValsMutator]MSP[S] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR2Mutator]MSP[N] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] bufPos ++ ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[N] return consumed ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI2Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[NegateConditionalsMutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[N]
private void bufferUp () { MST[rv.CRCR2Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[S] return lr_3 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI1Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[N] return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR3Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.ABSMutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR3Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[N] return lr_3 ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI3Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[N] } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR3Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI4Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[experimental.MemberVariableMutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
bufPos += seq . length () ; MST[experimental.MemberVariableMutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR5Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[EmptyObjectReturnValsMutator]MSP[N] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ABSMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
bufPos = endPos ; MST[rv.UOI3Mutator]MSP[S] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[S]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[S] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; MST[InlineConstantMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[S] else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
int hash = 0 ; int offset = start ; MST[rv.UOI3Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[InlineConstantMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[N] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[ReturnValsMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[EmptyObjectReturnValsMutator]MSP[N] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR3Mutator]MSP[N]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR4Mutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NegateConditionalsMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD1Mutator]MSP[N] } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[InlineConstantMutator]MSP[N] while ( count -- != 0 ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[ReturnValsMutator]MSP[N] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { MST[NegateConditionalsMutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) MST[rv.UOI4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI3Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ConditionalsBoundaryMutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD1Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR2Mutator]MSP[N]
if ( seek == c ) MST[rv.ROR5Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR6Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR1Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[N] } } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[N] } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI4Mutator]MSP[S] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[NegateConditionalsMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[InlineConstantMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[InlineConstantMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI3Mutator]MSP[N]
bufPos += seq . length () ; return true ; MST[ReturnValsMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[S] else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR3Mutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR5Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[InlineConstantMutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI4Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR2Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[MathMutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.ABSMutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[S] return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[ReturnValsMutator]MSP[N] }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) MST[rv.ROR3Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.ROR2Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI2Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[ReturnValsMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufPos += seq . length () ; return true ; MST[rv.CRCR5Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[S]
return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[N] while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[S] } return - 1 ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[S]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; MST[rv.ABSMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[IncrementsMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ; else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[MathMutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[N] bufPos ++ ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[S] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR2Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.ABSMutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[S]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[N] if ( count < 1 ) return lr_3 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return lr_3 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[InlineConstantMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[IncrementsMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR6Mutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR5Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR3Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[N] } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR2Mutator]MSP[N] } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[N] } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR4Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[PrimitiveReturnsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufPos += seq . length () ; MST[rv.UOI2Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI2Mutator]MSP[N] final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
bufPos += seq . length () ; MST[rv.AOD2Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[ArgumentPropagationMutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[S] } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR4Mutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR1Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR1Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR3Mutator]MSP[N] break OUTER; }
pos ++ ; MST[IncrementsMutator]MSP[N] } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) MST[rv.ROR3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR3Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[S] return consumed ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD1Mutator]MSP[N]
if ( seek == c ) MST[rv.UOI1Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR2Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[N] bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[experimental.RemoveIncrementsMutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[N]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int start = bufPos ; while ( bufPos < bufLength ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR6Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos += seq . length () ; MST[rv.UOI4Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[N] } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR3Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[S] if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
private void bufferUp () { MST[rv.CRCR1Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[NegateConditionalsMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NegateConditionalsMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR1Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI3Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR5Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI1Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR5Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[experimental.MemberVariableMutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.ABSMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD1Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[InlineConstantMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[S] for ( char seek : seq ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR3Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; MST[rv.ABSMutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR5Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR6Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR3Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR2Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[N] return consumed ; } else {
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; MST[rv.UOI2Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI2Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.ABSMutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR5Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR3Mutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[S] if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR4Mutator]MSP[N] } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[IncrementsMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufPos += seq . length () ; MST[MathMutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR5Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI1Mutator]MSP[N] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR1Mutator]MSP[N] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String cached = stringCache [ index ] ; if ( cached == null ) { MST[NegateConditionalsMutator]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR1Mutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { MST[rv.CRCR4Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[NegateConditionalsMutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI3Mutator]MSP[N] break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[N] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.ABSMutator]MSP[N] final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[N] bufPos ++ ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR2Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR5Mutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI4Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR2Mutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.UOI4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[S] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI3Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ABSMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[ConditionalsBoundaryMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[S]
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
case TokeniserState . nullChar : break OUTER; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToEnd () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[S] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR5Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N]
return false ; MST[rv.CRCR3Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR3Mutator]MSP[S] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR1Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI1Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
bufPos += seq . length () ; MST[rv.AOR3Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR5Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR1Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR5Mutator]MSP[S]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR5Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[VoidMethodCallMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[S] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI1Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI4Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR4Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) return true ; MST[InlineConstantMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ReturnValsMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[ReturnValsMutator]MSP[N] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR4Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR2Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[N] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI3Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[NegateConditionalsMutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[NegateConditionalsMutator]MSP[N] return i - bufPos ; } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[IncrementsMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI1Mutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { MST[ConditionalsBoundaryMutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[N] return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR2Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[N] }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[S] return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[S] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR5Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; } else {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR1Mutator]MSP[N] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[N] }
bufPos += seq . length () ; return true ; MST[rv.CRCR2Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[S] } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S]
bufSplitPoint = 0 ; MST[rv.CRCR5Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[N] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD1Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( seek == c ) MST[rv.UOI1Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[N] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI1Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR6Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI3Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( startChar != charBuf [ offset ] )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOD2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; MST[rv.ABSMutator]MSP[S] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; MST[experimental.MemberVariableMutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR4Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[S] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD2Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI4Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[NegateConditionalsMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { MST[rv.CRCR3Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[N] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[S]
if ( upScan != upTarget ) return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI2Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[ReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR3Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR4Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.ROR5Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[ReturnValsMutator]MSP[N] } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; } return false ; MST[InlineConstantMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI4Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[NegateConditionalsMutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[NonVoidMethodCallMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[S] while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[N] break OUTER; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[N] } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[N]
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR6Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { MST[rv.CRCR6Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[ConditionalsBoundaryMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR4Mutator]MSP[N] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[NegateConditionalsMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR6Mutator]MSP[N]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI4Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD2Mutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR3Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; MST[rv.CRCR1Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI3Mutator]MSP[S] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[N] return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR6Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return false ; MST[rv.CRCR5Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return lr_3 ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[N] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos += seq . length () ; MST[rv.AOR1Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR3Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR3Mutator]MSP[N] int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR1Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[S] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI1Mutator]MSP[S] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[InlineConstantMutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.ABSMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI1Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR3Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR6Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI1Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[ConditionalsBoundaryMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( startChar != charBuf [ offset ] )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR3Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] if ( matches ( seq ) ) {
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[MathMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { MST[rv.ABSMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR3Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR1Mutator]MSP[N] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.ABSMutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[S] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[N] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR1Mutator]MSP[N]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR2Mutator]MSP[N] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI2Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR6Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[ConditionalsBoundaryMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR1Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( upScan != upTarget ) return false ; } return true ; MST[ReturnValsMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[N]
if ( seek == c ) return true ; MST[rv.CRCR6Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI4Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[N] bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
bufPos += seq . length () ; return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR1Mutator]MSP[N] } return - 1 ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR5Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[S] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR4Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
private void bufferUp () { if ( readFully ) MST[rv.ROR2Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI4Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI4Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; MST[InlineConstantMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR5Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD2Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[InlineConstantMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[N] bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR5Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[S] } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[ReturnValsMutator]MSP[N] } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[S] else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[S] } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[N] return consumed ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR6Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NonVoidMethodCallMutator]MSP[N] char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[ReturnValsMutator]MSP[N] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR6Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI2Mutator]MSP[S] int i = start ; int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.CRCR2Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[MathMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR5Mutator]MSP[N] while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR4Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[InlineConstantMutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[N] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[S] while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR4Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI4Mutator]MSP[N] break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[ReturnValsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[MathMutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[N] char c = charBuf [ bufPos ] ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[experimental.MemberVariableMutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[InlineConstantMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOD1Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[N] } return - 1 ; }
bufPos += seq . length () ; MST[rv.ABSMutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR6Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[N] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return false ; MST[rv.CRCR1Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
pos ++ ; } bufPos = pos ; MST[experimental.MemberVariableMutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR5Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[MathMutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ABSMutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI2Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[N] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
pos ++ ; } bufPos = pos ; MST[rv.UOI1Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR3Mutator]MSP[N]
while ( read <= minReadAheadLen ) { MST[rv.CRCR1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[InlineConstantMutator]MSP[N] int read = 0 ;
if ( upScan != upTarget ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[ConditionalsBoundaryMutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.ROR5Mutator]MSP[N] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[InlineConstantMutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { MST[rv.CRCR5Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[N] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR1Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( startChar != charBuf [ offset ] )
unmark () ; MST[VoidMethodCallMutator]MSP[N] } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR4Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI2Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ;
if ( upScan != upTarget ) return false ; MST[ReturnValsMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI4Mutator]MSP[S] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR4Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ABSMutator]MSP[S]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR2Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return consumeToEnd () ; MST[ReturnValsMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NegateConditionalsMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { MST[rv.CRCR4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR1Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI2Mutator]MSP[S]
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR6Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { MST[rv.ROR2Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; MST[VoidMethodCallMutator]MSP[S] bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI3Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[S]
if ( seek == c ) return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[S] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[N] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; MST[InlineConstantMutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
pos ++ ; } bufPos = pos ; MST[rv.UOI4Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NonVoidMethodCallMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI3Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD1Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI2Mutator]MSP[N] break OUTER; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[InlineConstantMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ABSMutator]MSP[N] return lr_3 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[InlineConstantMutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[MathMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[experimental.MemberVariableMutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[N] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[N] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR5Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[ReturnValsMutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; MST[rv.CRCR3Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos += offset ; return consumed ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[N]
if ( seek == c ) MST[rv.UOI2Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; MST[rv.CRCR3Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR4Mutator]MSP[S] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) return true ; } return false ; MST[ReturnValsMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N]
bufSplitPoint = 0 ; MST[rv.CRCR1Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[S] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR3Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[ReturnValsMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR4Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI4Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[S] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; MST[rv.UOI4Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[MathMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[N] return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
while ( read <= minReadAheadLen ) { MST[InlineConstantMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[N] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI3Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; MST[InlineConstantMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI1Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI2Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[rv.CRCR5Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.AOR4Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR6Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR5Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[S] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[MathMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return val ; MST[rv.UOI1Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[MathMutator]MSP[N] }
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.ABSMutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; MST[rv.UOI1Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI2Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR1Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NonVoidMethodCallMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.ABSMutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI4Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI1Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR1Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[N] } } return - 1 ; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[S] } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[ConditionalsBoundaryMutator]MSP[N]
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR5Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[NegateConditionalsMutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR3Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[N] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR1Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR2Mutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[InlineConstantMutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[S] while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; MST[VoidMethodCallMutator]MSP[N] char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR4Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[S] stringCache [ index ] = cached ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI1Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[N] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[N] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[rv.ROR1Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[S] bufPos ++ ; else break; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR4Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[S] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3 ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ABSMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
private void bufferUp () { if ( readFully ) MST[rv.ROR4Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR6Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI3Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NonVoidMethodCallMutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[ReturnValsMutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NegateConditionalsMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR5Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR6Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seek == c ) return true ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR6Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[InlineConstantMutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[S] while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD2Mutator]MSP[N] } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI1Mutator]MSP[N] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR2Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.ABSMutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[MathMutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[N]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[N] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
String cached = stringCache [ index ] ; if ( cached == null ) { MST[rv.ROR5Mutator]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR3Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
