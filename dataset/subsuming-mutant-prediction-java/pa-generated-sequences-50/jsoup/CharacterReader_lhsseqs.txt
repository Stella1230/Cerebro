reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[] }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; MST[InlineConstantMutator]MSP[] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seek == c ) MST[rv.UOI3Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR2Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[NegateConditionalsMutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR5Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[rv.ROR1Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[] return lr_3 ;
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR3Mutator]MSP[]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR3Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR4Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[] return consumed ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[NonVoidMethodCallMutator]MSP[] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR4Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[InlineConstantMutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[InlineConstantMutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR2Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI2Mutator]MSP[] final int remaining = bufLength ; final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[] if ( count < 1 ) return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[] bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI3Mutator]MSP[] reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[ReturnValsMutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR3Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD1Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR1Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[MathMutator]MSP[] } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR1Mutator]MSP[] int read = 0 ;
return val ; MST[ReturnValsMutator]MSP[] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { MST[rv.UOI3Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR3Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR1Mutator]MSP[] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI2Mutator]MSP[]
return val ; MST[rv.UOI4Mutator]MSP[] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufPos = endPos ; MST[rv.UOI1Mutator]MSP[] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR2Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR1Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD1Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR4Mutator]MSP[]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR1Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] }
if ( seek == c ) MST[rv.ABSMutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR1Mutator]MSP[] return i - bufPos ; } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI2Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR2Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[]
bufPos += seq . length () ; MST[NonVoidMethodCallMutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR1Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD2Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI4Mutator]MSP[] }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI1Mutator]MSP[] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[NegateConditionalsMutator]MSP[] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[] } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR4Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) MST[rv.ROR1Mutator]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI2Mutator]MSP[] int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR4Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[NegateConditionalsMutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; MST[PrimitiveReturnsMutator]MSP[] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR3Mutator]MSP[] } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR4Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NonVoidMethodCallMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[EmptyObjectReturnValsMutator]MSP[] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR3Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; MST[rv.CRCR6Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR4Mutator]MSP[]
String cached = stringCache [ index ] ; MST[rv.ABSMutator]MSP[] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR2Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[ReturnValsMutator]MSP[] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[] if ( count < 1 ) return lr_3 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.ABSMutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI2Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR6Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[] return lr_3 ;
bufPos += seq . length () ; MST[rv.UOI3Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[] bufPos += offset ; return consumed ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[InlineConstantMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR5Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR4Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI1Mutator]MSP[] final char [] val = charBuf ;
int hash = 0 ; MST[rv.CRCR6Mutator]MSP[] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR4Mutator]MSP[] return i - bufPos ; } return - 1 ; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI1Mutator]MSP[] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[] } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD2Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[InlineConstantMutator]MSP[] }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[] stringCache [ index ] = cached ; } else {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR4Mutator]MSP[] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.ABSMutator]MSP[] final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[] return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR4Mutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ReturnValsMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR5Mutator]MSP[]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR1Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[InlineConstantMutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[InlineConstantMutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR5Mutator]MSP[] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[]
if ( upScan != upTarget ) MST[rv.ROR4Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[]
bufPos = endPos ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( seek == c ) MST[NegateConditionalsMutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[NegateConditionalsMutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR3Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[ArgumentPropagationMutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI2Mutator]MSP[] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seek == c ) return true ; MST[ReturnValsMutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[] return consumed ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR1Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[InlineConstantMutator]MSP[] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR3Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR3Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI2Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[] return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR5Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR3Mutator]MSP[] bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR6Mutator]MSP[] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[] return i - bufPos ; } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[NegateConditionalsMutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.ABSMutator]MSP[] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[]
int hash = 0 ; MST[rv.CRCR5Mutator]MSP[] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR3Mutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[] stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[] return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR5Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[experimental.RemoveIncrementsMutator]MSP[]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR1Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI2Mutator]MSP[] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; }
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[]
if ( upScan != upTarget ) MST[rv.ROR2Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI1Mutator]MSP[] int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[InlineConstantMutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[] bufPos ++ ;
return rangeEquals ( charBuf , start , count , cached ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NonVoidMethodCallMutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[InlineConstantMutator]MSP[] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[InlineConstantMutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[] return consumed ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI4Mutator]MSP[] final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[] } } return cached ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR2Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufPos = endPos ; MST[rv.UOI2Mutator]MSP[] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR2Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR5Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.UOI4Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR4Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos += seq . length () ; return true ; MST[InlineConstantMutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR4Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[] } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI4Mutator]MSP[] reader . mark ( maxBufferLen ) ; int read = 0 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[experimental.RemoveIncrementsMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR3Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[] for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[] return i - bufPos ; } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR5Mutator]MSP[] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR5Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[] } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR4Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI1Mutator]MSP[] break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[] if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[BooleanTrueReturnValsMutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR1Mutator]MSP[]
return val ; MST[rv.UOI3Mutator]MSP[] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ABSMutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR1Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[]
if ( seek == c ) MST[rv.UOI3Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR4Mutator]MSP[] }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD2Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[InlineConstantMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } private boolean isEmptyNoBufferUp () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[]
if ( seek == c ) return true ; MST[rv.CRCR2Mutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR6Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[] return lr_3 ;
while ( read <= minReadAheadLen ) { MST[rv.ROR1Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI3Mutator]MSP[] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { MST[ConditionalsBoundaryMutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR1Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR2Mutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR1Mutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR2Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[] return lr_3 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR2Mutator]MSP[] return i - bufPos ; } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.ABSMutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR3Mutator]MSP[] char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR3Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI3Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR3Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI1Mutator]MSP[] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR4Mutator]MSP[] }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[] char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[] } else {
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR4Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[] bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI1Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.ABSMutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] break; read += thisRead ; }
private void bufferUp () { MST[rv.CRCR3Mutator]MSP[] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[InlineConstantMutator]MSP[] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[NonVoidMethodCallMutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR3Mutator]MSP[] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) MST[rv.ABSMutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR2Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR2Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[] bufPos += offset ; return consumed ;
if ( seek == c ) return true ; } return false ; MST[rv.CRCR1Mutator]MSP[] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR3Mutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI3Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while ( read <= minReadAheadLen ) { MST[NegateConditionalsMutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] }
bufSplitPoint = 0 ; MST[rv.CRCR6Mutator]MSP[] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[MathMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI1Mutator]MSP[]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR5Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD1Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.ABSMutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { MST[rv.UOI3Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[] if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI4Mutator]MSP[] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD1Mutator]MSP[] } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR1Mutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR2Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR4Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private void bufferUp () { if ( readFully ) MST[NegateConditionalsMutator]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR3Mutator]MSP[] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[] break OUTER; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOD2Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[] } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR5Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR1Mutator]MSP[] while ( count -- != 0 ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[] if ( startChar != charBuf [ offset ] )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR5Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR2Mutator]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[NegateConditionalsMutator]MSP[] break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[] return consumed ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[] if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR5Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[NonVoidMethodCallMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI2Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[InlineConstantMutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR2Mutator]MSP[] }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI4Mutator]MSP[]
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR1Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI2Mutator]MSP[] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR5Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[] stringCache [ index ] = cached ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[] return consumed ;
String cached = stringCache [ index ] ; MST[rv.UOI2Mutator]MSP[] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { MST[MathMutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) MST[rv.ROR5Mutator]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.ABSMutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN2Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[MathMutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR6Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seek == c ) MST[rv.ROR4Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI1Mutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { MST[rv.ROR4Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.ABSMutator]MSP[] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR4Mutator]MSP[] } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR1Mutator]MSP[]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NegateConditionalsMutator]MSP[]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.ABSMutator]MSP[] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR3Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR3Mutator]MSP[] return i - bufPos ; } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOR2Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD2Mutator]MSP[] } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NonVoidMethodCallMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR3Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR1Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR2Mutator]MSP[]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[] for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR4Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.ABSMutator]MSP[] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR6Mutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; MST[rv.CRCR6Mutator]MSP[] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[]
String cached = stringCache [ index ] ; MST[rv.UOI3Mutator]MSP[] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR2Mutator]MSP[]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[] bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[] break OUTER; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR1Mutator]MSP[] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI3Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR5Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR2Mutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI4Mutator]MSP[] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR1Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR3Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[NegateConditionalsMutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[] return consumed ;
return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR4Mutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[NegateConditionalsMutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[InlineConstantMutator]MSP[] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR1Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR4Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR4Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break OUTER; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR4Mutator]MSP[]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR6Mutator]MSP[] if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[NonVoidMethodCallMutator]MSP[] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[IncrementsMutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI4Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[]
reader . reset () ; MST[VoidMethodCallMutator]MSP[] if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR5Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR3Mutator]MSP[]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR6Mutator]MSP[] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR4Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR3Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR3Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR5Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[experimental.MemberVariableMutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR4Mutator]MSP[] bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR5Mutator]MSP[] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[IncrementsMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI2Mutator]MSP[]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR5Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NonVoidMethodCallMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI1Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
bufPos += seq . length () ; return true ; MST[rv.CRCR4Mutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR6Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[NonVoidMethodCallMutator]MSP[]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NegateConditionalsMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[] bufPos += offset ; return consumed ;
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[] return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR4Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.ABSMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NegateConditionalsMutator]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.UOI1Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return false ; MST[ReturnValsMutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[InlineConstantMutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI2Mutator]MSP[] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI3Mutator]MSP[] final char [] val = charBuf ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[MathMutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR5Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[ReturnValsMutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR5Mutator]MSP[] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[]
return rangeEquals ( charBuf , start , count , cached ) ; MST[ReturnValsMutator]MSP[] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR5Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR4Mutator]MSP[] break OUTER; }
if ( seek == c ) MST[rv.ROR3Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI4Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[ReturnValsMutator]MSP[] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( seek == c ) MST[rv.UOI2Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; MST[NonVoidMethodCallMutator]MSP[] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; MST[VoidMethodCallMutator]MSP[] return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR3Mutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.ROR5Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR1Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR2Mutator]MSP[]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR1Mutator]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[] } private boolean isEmptyNoBufferUp () {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[] if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[] } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI1Mutator]MSP[] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR1Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR4Mutator]MSP[]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; MST[rv.UOI2Mutator]MSP[] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; return consumed ; MST[ReturnValsMutator]MSP[] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR2Mutator]MSP[] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[] bufPos ++ ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[] return consumed ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI2Mutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[NegateConditionalsMutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR4Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR4Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[]
private void bufferUp () { MST[rv.CRCR2Mutator]MSP[] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR5Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[] return lr_3 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR4Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI1Mutator]MSP[] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[] return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR3Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[BooleanTrueReturnValsMutator]MSP[] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.ABSMutator]MSP[] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[InlineConstantMutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR4Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR3Mutator]MSP[] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[] return lr_3 ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI3Mutator]MSP[] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[] } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR1Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR3Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI4Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN1Mutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[experimental.MemberVariableMutator]MSP[] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[] char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
bufPos += seq . length () ; MST[experimental.MemberVariableMutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR5Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[EmptyObjectReturnValsMutator]MSP[] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[] } final int index = hash & stringCache . length - 1 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ABSMutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
bufPos = endPos ; MST[rv.UOI3Mutator]MSP[] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; MST[InlineConstantMutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[] else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[BooleanTrueReturnValsMutator]MSP[] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[]
int hash = 0 ; int offset = start ; MST[rv.UOI3Mutator]MSP[] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[InlineConstantMutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[ReturnValsMutator]MSP[] } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[EmptyObjectReturnValsMutator]MSP[] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR2Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR3Mutator]MSP[]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR4Mutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NegateConditionalsMutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD1Mutator]MSP[] } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR4Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[InlineConstantMutator]MSP[] while ( count -- != 0 ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[ReturnValsMutator]MSP[] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI3Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[] return consumed ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[] }
reader . reset () ; if ( read > 0 ) { MST[NegateConditionalsMutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) MST[rv.UOI4Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI3Mutator]MSP[] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR2Mutator]MSP[] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ConditionalsBoundaryMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD1Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR2Mutator]MSP[]
if ( seek == c ) MST[rv.ROR5Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; MST[VoidMethodCallMutator]MSP[] return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR6Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR1Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[] } } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR3Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[] } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI4Mutator]MSP[] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD1Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI1Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[NegateConditionalsMutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[InlineConstantMutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[InlineConstantMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR2Mutator]MSP[] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI3Mutator]MSP[]
bufPos += seq . length () ; return true ; MST[ReturnValsMutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[] else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR3Mutator]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR5Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR5Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI3Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[InlineConstantMutator]MSP[] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD1Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NegateConditionalsMutator]MSP[] char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI4Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR2Mutator]MSP[] if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[MathMutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.ABSMutator]MSP[] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[] return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[ReturnValsMutator]MSP[] }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[] return consumed ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) MST[rv.ROR3Mutator]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[] bufPos += offset ; return consumed ; } else {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.ROR2Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI2Mutator]MSP[] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR3Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR4Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[ReturnValsMutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR5Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufPos += seq . length () ; return true ; MST[rv.CRCR5Mutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[]
return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[] while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[] } return - 1 ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR2Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[] if ( count < 1 ) return lr_3 ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; MST[rv.ABSMutator]MSP[] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR1Mutator]MSP[]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[IncrementsMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[] bufPos ++ ; else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[MathMutator]MSP[]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[] bufPos ++ ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR5Mutator]MSP[] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR2Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[] bufPos += offset ; return consumed ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI4Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[] char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.ABSMutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[] if ( count < 1 ) return lr_3 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[] return lr_3 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[InlineConstantMutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[IncrementsMutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR6Mutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR3Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR3Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[] for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR5Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR2Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR3Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[] } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR2Mutator]MSP[] } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[] } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR4Mutator]MSP[] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[PrimitiveReturnsMutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufPos += seq . length () ; MST[rv.UOI2Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI4Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI2Mutator]MSP[] final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
bufPos += seq . length () ; MST[rv.AOD2Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[ArgumentPropagationMutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[] } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR4Mutator]MSP[] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR5Mutator]MSP[] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR1Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[] char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR1Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[] bufPos += offset ; return consumed ; } else {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR3Mutator]MSP[] break OUTER; }
pos ++ ; MST[IncrementsMutator]MSP[] } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR3Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) MST[rv.ROR3Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR3Mutator]MSP[]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[] if ( startChar != charBuf [ offset ] )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[] return consumed ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR2Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD1Mutator]MSP[]
if ( seek == c ) MST[rv.UOI1Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR2Mutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI4Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[PrimitiveReturnsMutator]MSP[] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[] bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[experimental.RemoveIncrementsMutator]MSP[] } final int index = hash & stringCache . length - 1 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[] int start = bufPos ; while ( bufPos < bufLength ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; MST[VoidMethodCallMutator]MSP[] char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR6Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos += seq . length () ; MST[rv.UOI4Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[] } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[PrimitiveReturnsMutator]MSP[] } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR3Mutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[] if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[] char c = charBuf [ bufPos ] ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
private void bufferUp () { MST[rv.CRCR1Mutator]MSP[] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[NegateConditionalsMutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NegateConditionalsMutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR1Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI3Mutator]MSP[] int j = 0 ; while ( count -- != 0 ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR5Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI1Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR5Mutator]MSP[] } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[experimental.MemberVariableMutator]MSP[] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.ABSMutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[rv.CRCR4Mutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR2Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[] if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD1Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[InlineConstantMutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR3Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[] for ( char seek : seq ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR3Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; MST[rv.ABSMutator]MSP[] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR5Mutator]MSP[] return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI1Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR6Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR2Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[PrimitiveReturnsMutator]MSP[] }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR3Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR2Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[] return consumed ; } else {
return false ; MST[BooleanTrueReturnValsMutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[] } final int index = hash & stringCache . length - 1 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR6Mutator]MSP[] while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; MST[rv.UOI2Mutator]MSP[] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI2Mutator]MSP[] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[] if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[] } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[] return consumed ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI2Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.ABSMutator]MSP[] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[] stringCache [ index ] = cached ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[] else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR5Mutator]MSP[]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR4Mutator]MSP[] char c = charBuf [ bufPos ] ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR3Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR3Mutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[] return i - bufPos ; } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[] return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[] else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[] if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR4Mutator]MSP[] } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[IncrementsMutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR2Mutator]MSP[] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; MST[rv.CRCR1Mutator]MSP[] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR2Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufPos += seq . length () ; MST[MathMutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI1Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR5Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI1Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR2Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR1Mutator]MSP[] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[]
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR2Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String cached = stringCache [ index ] ; if ( cached == null ) { MST[NegateConditionalsMutator]MSP[] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR1Mutator]MSP[] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { MST[rv.CRCR4Mutator]MSP[] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[NegateConditionalsMutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI3Mutator]MSP[] break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[] bufPos += offset ; return consumed ; } else {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.ABSMutator]MSP[] final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[] bufPos ++ ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR2Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR5Mutator]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI4Mutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR2Mutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI2Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR3Mutator]MSP[] while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR3Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.UOI4Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI3Mutator]MSP[] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ABSMutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[NonVoidMethodCallMutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD2Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR3Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[] stringCache [ index ] = cached ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[ConditionalsBoundaryMutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[]
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[] return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR5Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR1Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
case TokeniserState . nullChar : break OUTER; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToEnd () { bufferUp () ; MST[VoidMethodCallMutator]MSP[]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR5Mutator]MSP[] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI4Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR5Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR5Mutator]MSP[]
return false ; MST[rv.CRCR3Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR3Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[PrimitiveReturnsMutator]MSP[] } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR1Mutator]MSP[] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI1Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
bufPos += seq . length () ; MST[rv.AOR3Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR5Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR1Mutator]MSP[] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[] bufPos += offset ; return consumed ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD2Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR5Mutator]MSP[]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR5Mutator]MSP[] if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[VoidMethodCallMutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[] bufPos += offset ; return consumed ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR5Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI1Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI4Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI2Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR5Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR4Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[] if ( startChar != charBuf [ offset ] )
if ( seek == c ) return true ; MST[InlineConstantMutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ReturnValsMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[ReturnValsMutator]MSP[] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR4Mutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR2Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI3Mutator]MSP[] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[NegateConditionalsMutator]MSP[] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[NegateConditionalsMutator]MSP[] return i - bufPos ; } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[IncrementsMutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI1Mutator]MSP[] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { MST[ConditionalsBoundaryMutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR5Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[] return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR2Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[] }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[] return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR5Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[] if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[] return consumed ; } else {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR1Mutator]MSP[] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[] }
bufPos += seq . length () ; return true ; MST[rv.CRCR2Mutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR3Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[] } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[]
bufSplitPoint = 0 ; MST[rv.CRCR5Mutator]MSP[] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR2Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD1Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( seek == c ) MST[rv.UOI1Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR2Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI1Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ReturnValsMutator]MSP[] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR6Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI3Mutator]MSP[] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[] if ( startChar != charBuf [ offset ] )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOD2Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; MST[rv.ABSMutator]MSP[] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR3Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[] else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; }
bufSplitPoint = 0 ; MST[experimental.MemberVariableMutator]MSP[] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR4Mutator]MSP[]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD2Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR2Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI4Mutator]MSP[] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[NegateConditionalsMutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { MST[rv.CRCR3Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR3Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[]
if ( upScan != upTarget ) return false ; MST[rv.CRCR3Mutator]MSP[] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI2Mutator]MSP[] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI1Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR6Mutator]MSP[] bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[ReturnValsMutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR3Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR4Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR4Mutator]MSP[] if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.ROR5Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[] } private boolean isEmptyNoBufferUp () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[ReturnValsMutator]MSP[] } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[] return lr_3 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; } return false ; MST[InlineConstantMutator]MSP[] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[] stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD2Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI4Mutator]MSP[]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI3Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR2Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[NegateConditionalsMutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { MST[NonVoidMethodCallMutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[] while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[] break OUTER; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[] } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[]
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR6Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { MST[rv.CRCR6Mutator]MSP[] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[ConditionalsBoundaryMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR4Mutator]MSP[] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR4Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[NegateConditionalsMutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR6Mutator]MSP[]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI4Mutator]MSP[] final int remaining = bufLength ; final char [] val = charBuf ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR3Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD2Mutator]MSP[]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[] else break; }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR3Mutator]MSP[] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[]
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR1Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; MST[rv.CRCR1Mutator]MSP[] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI3Mutator]MSP[] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[] return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR4Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR6Mutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR6Mutator]MSP[] }
return false ; MST[rv.CRCR5Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return lr_3 ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos += seq . length () ; MST[rv.AOR1Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI3Mutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR3Mutator]MSP[] }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR3Mutator]MSP[] int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR1Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR1Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[] return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI1Mutator]MSP[] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[InlineConstantMutator]MSP[] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.ABSMutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI1Mutator]MSP[]
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR3Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR2Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR6Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[] bufPos ++ ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[] stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI1Mutator]MSP[] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[ConditionalsBoundaryMutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD2Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI3Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[BooleanFalseReturnValsMutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[] if ( startChar != charBuf [ offset ] )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR3Mutator]MSP[] if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[] if ( matches ( seq ) ) {
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[MathMutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { MST[rv.ABSMutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR3Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR1Mutator]MSP[] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[] bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD1Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.ABSMutator]MSP[] reader . mark ( maxBufferLen ) ; int read = 0 ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR1Mutator]MSP[]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR2Mutator]MSP[] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR1Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI2Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR6Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[ConditionalsBoundaryMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR1Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( upScan != upTarget ) return false ; } return true ; MST[ReturnValsMutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[]
if ( seek == c ) return true ; MST[rv.CRCR6Mutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI4Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI2Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[] bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
bufPos += seq . length () ; return true ; MST[BooleanFalseReturnValsMutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR6Mutator]MSP[] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR1Mutator]MSP[] } return - 1 ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR5Mutator]MSP[] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR5Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR4Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR3Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[ConditionalsBoundaryMutator]MSP[] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR4Mutator]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
private void bufferUp () { if ( readFully ) MST[rv.ROR2Mutator]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI3Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR2Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI4Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR4Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI4Mutator]MSP[] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR1Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[] for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; MST[InlineConstantMutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR5Mutator]MSP[] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD2Mutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR3Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[InlineConstantMutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[IncrementsMutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[] bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR5Mutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[] } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[EmptyObjectReturnValsMutator]MSP[] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[ReturnValsMutator]MSP[] } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD2Mutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[] else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR4Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[] } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[] return consumed ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR3Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR6Mutator]MSP[] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR2Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NonVoidMethodCallMutator]MSP[] char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[ReturnValsMutator]MSP[] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR6Mutator]MSP[] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI2Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[] if ( startChar != charBuf [ offset ] )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[IncrementsMutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.CRCR2Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[ConditionalsBoundaryMutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[MathMutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR2Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR5Mutator]MSP[] while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[] else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[] int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR4Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR1Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR1Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[InlineConstantMutator]MSP[] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR4Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR1Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI1Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI4Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[] while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR4Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI4Mutator]MSP[] break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[ReturnValsMutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[MathMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[] char c = charBuf [ bufPos ] ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[experimental.MemberVariableMutator]MSP[] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[InlineConstantMutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOD1Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[] } return - 1 ; }
bufPos += seq . length () ; MST[rv.ABSMutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR2Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR6Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[BooleanTrueReturnValsMutator]MSP[] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI2Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR3Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return false ; MST[rv.CRCR1Mutator]MSP[] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
pos ++ ; } bufPos = pos ; MST[experimental.MemberVariableMutator]MSP[] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR5Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[MathMutator]MSP[]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isEmptyNoBufferUp () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ABSMutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI2Mutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[InlineConstantMutator]MSP[] return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[] if ( startChar != charBuf [ offset ] )
pos ++ ; } bufPos = pos ; MST[rv.UOI1Mutator]MSP[] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR3Mutator]MSP[]
while ( read <= minReadAheadLen ) { MST[rv.CRCR1Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[InlineConstantMutator]MSP[] int read = 0 ;
if ( upScan != upTarget ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[] return consumed ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR1Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[ConditionalsBoundaryMutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[] return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR1Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.ROR5Mutator]MSP[] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[InlineConstantMutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { MST[rv.CRCR5Mutator]MSP[] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR2Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR4Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[] char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR1Mutator]MSP[] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( startChar != charBuf [ offset ] )
unmark () ; MST[VoidMethodCallMutator]MSP[] } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR4Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI2Mutator]MSP[]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[] bufPos += offset ; return consumed ;
if ( upScan != upTarget ) return false ; MST[ReturnValsMutator]MSP[] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR4Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI4Mutator]MSP[] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR4Mutator]MSP[]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[] for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ABSMutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR2Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return consumeToEnd () ; MST[ReturnValsMutator]MSP[] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NegateConditionalsMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { MST[rv.CRCR4Mutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR1Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI2Mutator]MSP[]
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR2Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR6Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { MST[rv.ROR2Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; MST[VoidMethodCallMutator]MSP[] bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI3Mutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI4Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[]
if ( seek == c ) return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; MST[InlineConstantMutator]MSP[] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
pos ++ ; } bufPos = pos ; MST[rv.UOI4Mutator]MSP[] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NonVoidMethodCallMutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[] char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI3Mutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD1Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI2Mutator]MSP[] break OUTER; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[] stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR3Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[InlineConstantMutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ABSMutator]MSP[] return lr_3 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[InlineConstantMutator]MSP[] } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[NegateConditionalsMutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[MathMutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[experimental.MemberVariableMutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR1Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR5Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[ReturnValsMutator]MSP[] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR1Mutator]MSP[] bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[] return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bufPos ++ ; else break; }
int hash = 0 ; MST[rv.CRCR3Mutator]MSP[] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[] bufPos += offset ; return consumed ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[] } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[] if ( startChar != charBuf [ offset ] )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[]
if ( seek == c ) MST[rv.UOI2Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR1Mutator]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; MST[rv.CRCR3Mutator]MSP[] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI2Mutator]MSP[] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR4Mutator]MSP[] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) return true ; } return false ; MST[ReturnValsMutator]MSP[] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[]
bufSplitPoint = 0 ; MST[rv.CRCR1Mutator]MSP[] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR3Mutator]MSP[] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[] bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR2Mutator]MSP[] char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[ReturnValsMutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR4Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI4Mutator]MSP[] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; MST[rv.UOI4Mutator]MSP[] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[MathMutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[] return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[] if ( count < 1 ) return lr_3 ;
while ( read <= minReadAheadLen ) { MST[InlineConstantMutator]MSP[] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR6Mutator]MSP[] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI3Mutator]MSP[] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; MST[InlineConstantMutator]MSP[] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI1Mutator]MSP[] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI2Mutator]MSP[] return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[rv.CRCR5Mutator]MSP[] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.AOR4Mutator]MSP[] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR6Mutator]MSP[] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR6Mutator]MSP[] } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR5Mutator]MSP[] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[MathMutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[BooleanFalseReturnValsMutator]MSP[] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI3Mutator]MSP[] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR2Mutator]MSP[] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return val ; MST[rv.UOI1Mutator]MSP[] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[] return i - bufPos ; } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[MathMutator]MSP[] }
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.ABSMutator]MSP[] int j = 0 ; while ( count -- != 0 ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; MST[rv.UOI1Mutator]MSP[] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI2Mutator]MSP[] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR1Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NonVoidMethodCallMutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.ABSMutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI4Mutator]MSP[] int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI1Mutator]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR5Mutator]MSP[] char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR4Mutator]MSP[] return offset - bufPos ; } } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR1Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[] } } return - 1 ; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[] } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[ConditionalsBoundaryMutator]MSP[]
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[] bufPos ++ ; else break; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI1Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR5Mutator]MSP[] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[NegateConditionalsMutator]MSP[] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[] } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR3Mutator]MSP[]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR1Mutator]MSP[] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR2Mutator]MSP[] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[InlineConstantMutator]MSP[] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[PrimitiveReturnsMutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[] while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD1Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; MST[VoidMethodCallMutator]MSP[] char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR4Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[] if ( offset < bufLength && last <= bufLength ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[] stringCache [ index ] = cached ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR4Mutator]MSP[] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI1Mutator]MSP[] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[rv.ROR1Mutator]MSP[] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[] bufPos ++ ; else break; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR4Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[] int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[] bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD2Mutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR4Mutator]MSP[] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[] return lr_3 ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ABSMutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[] stringCache [ index ] = cached ; } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[] char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
private void bufferUp () { if ( readFully ) MST[rv.ROR4Mutator]MSP[] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR6Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR2Mutator]MSP[] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI3Mutator]MSP[] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NonVoidMethodCallMutator]MSP[]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[NegateConditionalsMutator]MSP[]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[ReturnValsMutator]MSP[] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[] return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NegateConditionalsMutator]MSP[] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR5Mutator]MSP[]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR6Mutator]MSP[] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seek == c ) return true ; } return false ; MST[rv.CRCR3Mutator]MSP[] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR6Mutator]MSP[] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI2Mutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[InlineConstantMutator]MSP[] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[] while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD2Mutator]MSP[] } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI1Mutator]MSP[] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR2Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.ABSMutator]MSP[]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR1Mutator]MSP[] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[MathMutator]MSP[] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN3Mutator]MSP[]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[] bufPos += offset ; return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR1Mutator]MSP[] }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[] return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR3Mutator]MSP[] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
String cached = stringCache [ index ] ; if ( cached == null ) { MST[rv.ROR5Mutator]MSP[] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR3Mutator]MSP[] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[] } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
