final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[] }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( ch ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[] } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[] }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[InlineConstantMutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR5Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[] }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR2Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[] } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR5Mutator]MSP[] {
final String value = t . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR4Mutator]MSP[] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[experimental.MemberVariableMutator]MSP[] currentOption = null ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[] break; } } else {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR3Mutator]MSP[] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
final int pos = t . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[] {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final String value = t . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR3Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR4Mutator]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[] break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR4Mutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[ReturnValsMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR2Mutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NegateConditionalsMutator]MSP[] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.ABSMutator]MSP[] if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[] } private boolean isLongOption ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR6Mutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[ConditionalsBoundaryMutator]MSP[] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; MST[VoidMethodCallMutator]MSP[] } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR2Mutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[] if ( opt . hasArg () ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR1Mutator]MSP[] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[] || lr_3 . equalsIgnoreCase ( value )
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI4Mutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[EmptyObjectReturnValsMutator]MSP[] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[InlineConstantMutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[] {
return false ; MST[rv.CRCR1Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI4Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[] break; } } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return false ; MST[rv.CRCR6Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR4Mutator]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[] {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR5Mutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[]
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String value = t . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR2Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR5Mutator]MSP[] } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR4Mutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NullReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[] { skipParsing = true ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[ConditionalsBoundaryMutator]MSP[] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[ConditionalsBoundaryMutator]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR3Mutator]MSP[] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isLongOption ( final String token ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( options . hasShortOption ( optName ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
} else if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
} else if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[ReturnValsMutator]MSP[] } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[] break; } } else {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[] { return true ; }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR2Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR4Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[EmptyObjectReturnValsMutator]MSP[] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR5Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR5Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR6Mutator]MSP[] break; } } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR2Mutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[] } private boolean isLongOption ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } private boolean isLongOption ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR3Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[ReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[] }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR4Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR5Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR2Mutator]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[] {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( allowPartialMatching ) MST[NegateConditionalsMutator]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[] if ( arguments != null ) {
handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI3Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[InlineConstantMutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR1Mutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[] } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR5Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[] }
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR5Mutator]MSP[] currentOption = null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR1Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD2Mutator]MSP[] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[] }
} else if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[VoidMethodCallMutator]MSP[] } }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { currentOption = option ; } else {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR3Mutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[] if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[experimental.NakedReceiverMutator]MSP[] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR3Mutator]MSP[] {
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD1Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NegateConditionalsMutator]MSP[] if ( options . hasShortOption ( optName ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR5Mutator]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[] } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[IncrementsMutator]MSP[] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[InlineConstantMutator]MSP[] if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR5Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { return true ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR3Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[] {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[] { return;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NonVoidMethodCallMutator]MSP[] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( options . getOptionGroup ( option ) != null ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR5Mutator]MSP[] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR1Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI3Mutator]MSP[] skipParsing = false ; currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[]
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NegateConditionalsMutator]MSP[] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI3Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ABSMutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR4Mutator]MSP[] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NegateConditionalsMutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NonVoidMethodCallMutator]MSP[] { currentOption = option ; } else {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; MST[VoidMethodCallMutator]MSP[] currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR2Mutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR4Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[VoidMethodCallMutator]MSP[]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] final boolean selected = group != null && group . getSelected () != null ;
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR1Mutator]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR3Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; MST[NonVoidMethodCallMutator]MSP[] updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI2Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
return true ; MST[rv.CRCR6Mutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR3Mutator]MSP[] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR6Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] handleOption ( options . getOption ( key ) ) ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[rv.ROR5Mutator]MSP[] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[]
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[ReturnValsMutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[ReturnValsMutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR1Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; MST[NonVoidMethodCallMutator]MSP[] if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[] } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[] }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[] handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[] break; } } else {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR6Mutator]MSP[] if ( options . hasLongOption ( token ) ) {
} else if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR5Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR5Mutator]MSP[] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD2Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR6Mutator]MSP[] } private void handleUnknownToken ( final String token ) throws ParseException {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[InlineConstantMutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR2Mutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[] {
else { final String opt = getLongPrefix ( t ) ; MST[NonVoidMethodCallMutator]MSP[] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[]
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
} else if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR2Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR2Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR4Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR4Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR4Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR4Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR4Mutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR3Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[]
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[] currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[NegateConditionalsMutator]MSP[] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NonVoidMethodCallMutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[]
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NonVoidMethodCallMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[MathMutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[] {
currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[]
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
return false ; MST[rv.CRCR3Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ReturnValsMutator]MSP[] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; MST[experimental.MemberVariableMutator]MSP[] this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[] } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ABSMutator]MSP[] if ( options . hasShortOption ( optName ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } else { handleLongOptionWithEqual ( token ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[] { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR2Mutator]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR4Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { currentOption = option ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[] } } else if ( isJavaProperty ( opt ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[]
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR2Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[] {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR4Mutator]MSP[] { currentOption = option ; } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[experimental.NakedReceiverMutator]MSP[] break; } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; MST[rv.CRCR5Mutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt == null ) MST[NegateConditionalsMutator]MSP[] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
handleOption ( options . getOption ( ch ) ) ; MST[VoidMethodCallMutator]MSP[] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) MST[rv.UOI1Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[]
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[] break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR3Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( option . acceptsArg () )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[] } else { handleUnknownToken ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; MST[NonVoidMethodCallMutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI4Mutator]MSP[] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ConditionalsBoundaryMutator]MSP[] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[InlineConstantMutator]MSP[] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean isLongOption ( final String token ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR1Mutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[] { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NonVoidMethodCallMutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR5Mutator]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI2Mutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[] } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI2Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR1Mutator]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[ConstructorCallMutator]MSP[] if ( options . hasLongOption ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[] } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ConditionalsBoundaryMutator]MSP[] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[VoidMethodCallMutator]MSP[] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
} else if ( pos == - 1 ) MST[rv.ABSMutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[] if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[] break; } } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[] {
Option option = options . getOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[] matches . add ( option . getLongOpt () ) ; } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[] final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR3Mutator]MSP[] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR5Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[] {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[] } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean isLongOption ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NegateConditionalsMutator]MSP[] {
final String value = t . substring ( pos + 1 ) ; MST[MathMutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[] {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[] final Option opt = options . getOption ( option ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR1Mutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[InlineConstantMutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI4Mutator]MSP[] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; MST[InlineConstantMutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR5Mutator]MSP[] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR2Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( options . hasShortOption ( optName ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[] break; } } }
cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[] } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR5Mutator]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[InlineConstantMutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR1Mutator]MSP[] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR5Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[] || lr_3 . equalsIgnoreCase ( value )
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) MST[rv.ROR2Mutator]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; MST[ConstructorCallMutator]MSP[] } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String prefix = t . substring ( 0 , i ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NegateConditionalsMutator]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[InlineConstantMutator]MSP[] currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI1Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
{ handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR6Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[] break; } } }
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[ArgumentPropagationMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR3Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[InlineConstantMutator]MSP[] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR3Mutator]MSP[] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NonVoidMethodCallMutator]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR1Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; MST[rv.CRCR3Mutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR2Mutator]MSP[] { currentOption = option ; } else {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[] { skipParsing = true ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR3Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[InlineConstantMutator]MSP[] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ReturnValsMutator]MSP[] } private boolean isLongOption ( final String token ) {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[NegateConditionalsMutator]MSP[] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR3Mutator]MSP[] currentOption = null ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[] } cmd = new CommandLine () ; if ( arguments != null ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR2Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[] if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[rv.ROR5Mutator]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR2Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[] break; } } else {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR1Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR1Mutator]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR2Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR1Mutator]MSP[] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[] { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[] }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR4Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[] option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[] }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[ArgumentPropagationMutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { skipParsing = true ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR3Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NonVoidMethodCallMutator]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[] break; } } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[] } else { handleUnknownToken ( token ) ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR4Mutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR4Mutator]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return true ; MST[InlineConstantMutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; MST[VoidMethodCallMutator]MSP[] if ( option . hasArg () ) { currentOption = option ; } else {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[InlineConstantMutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; } } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[]
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[] break; } } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { return true ; }
} else if ( pos == - 1 ) MST[rv.UOI3Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR6Mutator]MSP[] currentOption = null ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NonVoidMethodCallMutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] {
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR2Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR3Mutator]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR6Mutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[] }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI4Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR2Mutator]MSP[] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[]
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[InlineConstantMutator]MSP[] } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NonVoidMethodCallMutator]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[] }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI1Mutator]MSP[] skipParsing = false ; currentOption = null ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR5Mutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[] }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isLongOption ( final String token ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR4Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR1Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[ConditionalsBoundaryMutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI2Mutator]MSP[] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[InlineConstantMutator]MSP[] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NegateConditionalsMutator]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR5Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR3Mutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[ReturnValsMutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[] break; } } else {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR4Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[] currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[] checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR2Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NegateConditionalsMutator]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NonVoidMethodCallMutator]MSP[] if ( options . hasShortOption ( optName ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI4Mutator]MSP[] skipParsing = false ; currentOption = null ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR4Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[ConditionalsBoundaryMutator]MSP[] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR2Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] if ( option != null && option . acceptsArg () ) {
return true ; MST[rv.CRCR2Mutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR3Mutator]MSP[] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[VoidMethodCallMutator]MSP[] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; MST[ConstructorCallMutator]MSP[] } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR6Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR4Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR1Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[] } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR4Mutator]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[] }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[]
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI1Mutator]MSP[] if ( options . hasOption ( ch ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NegateConditionalsMutator]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR5Mutator]MSP[] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; MST[ConstructorCallMutator]MSP[] } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR3Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR4Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR3Mutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI1Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[] } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR1Mutator]MSP[] } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( options . hasShortOption ( optName ) ) {
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR3Mutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[] break; } } else {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[] } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[] {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR1Mutator]MSP[] currentOption = null ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR3Mutator]MSP[] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[experimental.MemberVariableMutator]MSP[] skipParsing = false ; currentOption = null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR1Mutator]MSP[] {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; MST[VoidMethodCallMutator]MSP[] } } private List < String > getMatchingLongOptions ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR6Mutator]MSP[] {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] || lr_3 . equalsIgnoreCase ( value )
return true ; MST[ReturnValsMutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI4Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR3Mutator]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR4Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NegateConditionalsMutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[] || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[] {
return false ; MST[ReturnValsMutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI3Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[ReturnValsMutator]MSP[] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ABSMutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD1Mutator]MSP[] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[] { return true ; }
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } } private boolean isArgument ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleOption ( options . getOption ( opt ) ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR5Mutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; MST[rv.ABSMutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR4Mutator]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[] }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR1Mutator]MSP[] } private void handleUnknownToken ( final String token ) throws ParseException {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[VoidMethodCallMutator]MSP[] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[]
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[] return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
return false ; MST[rv.CRCR5Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR3Mutator]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[ReturnValsMutator]MSP[] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean isLongOption ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( options . getOptionGroup ( option ) != null ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR4Mutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR2Mutator]MSP[] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[] {
if ( opt == null ) MST[rv.ROR5Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR5Mutator]MSP[] { currentOption = option ; } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR3Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[InlineConstantMutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR2Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[InlineConstantMutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR2Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[] }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; MST[NonVoidMethodCallMutator]MSP[] return true ; } catch ( final NumberFormatException e ) { return false ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR5Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[]
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { skipParsing = true ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR2Mutator]MSP[] if ( options . hasLongOption ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[ArgumentPropagationMutator]MSP[] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; MST[VoidMethodCallMutator]MSP[] } } } else { final String opt = t . substring ( 0 , pos ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR2Mutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[InlineConstantMutator]MSP[] } private void handleUnknownToken ( final String token ) throws ParseException {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR3Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR1Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[]
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR2Mutator]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[] }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[] } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR2Mutator]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NegateConditionalsMutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NegateConditionalsMutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR6Mutator]MSP[] } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[ReturnValsMutator]MSP[] } private boolean isJavaProperty ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR3Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[NonVoidMethodCallMutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[ReturnValsMutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[] if ( options . hasShortOption ( optName ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; MST[experimental.MemberVariableMutator]MSP[] if ( skipParsing ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR6Mutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[InlineConstantMutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR4Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR6Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[] { skipParsing = true ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI2Mutator]MSP[] skipParsing = false ; currentOption = null ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return true ; MST[rv.CRCR4Mutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NonVoidMethodCallMutator]MSP[] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[] }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return true ; }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) MST[rv.ROR3Mutator]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[] break; } } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[MathMutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[InlineConstantMutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[] break; } } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI2Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[] }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR3Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[]
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean isLongOption ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.ABSMutator]MSP[] skipParsing = false ; currentOption = null ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR3Mutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NegateConditionalsMutator]MSP[] { currentOption = option ; } else {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR3Mutator]MSP[] } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[] }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR1Mutator]MSP[] { currentOption = option ; } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[ReturnValsMutator]MSP[] } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR1Mutator]MSP[] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR4Mutator]MSP[] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR1Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[]
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[] }
} else if ( pos == - 1 ) MST[rv.UOI4Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR4Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR4Mutator]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR4Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR4Mutator]MSP[] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR2Mutator]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[] }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR5Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR2Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[] } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[] { return;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI3Mutator]MSP[] if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR3Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR4Mutator]MSP[] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR2Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[] }
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} else if ( pos == - 1 ) MST[rv.UOI2Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR3Mutator]MSP[] { currentOption = option ; } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR3Mutator]MSP[] } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[] break; } } else {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; MST[ArgumentPropagationMutator]MSP[] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleLongOptionWithoutEqual ( token ) ; }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] handleOption ( options . getOption ( key ) ) ; } }
handleShortAndLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[] } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; MST[experimental.MemberVariableMutator]MSP[] } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR5Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleOption ( options . getOption ( opt ) ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR2Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR1Mutator]MSP[] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[] {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR2Mutator]MSP[] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NonVoidMethodCallMutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR4Mutator]MSP[] break; } } }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[] final Option opt = options . getOption ( option ) ;
return true ; MST[BooleanFalseReturnValsMutator]MSP[] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[rv.ROR1Mutator]MSP[] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI1Mutator]MSP[] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[VoidMethodCallMutator]MSP[] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[] break; } } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR1Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[]
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[] }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NegateConditionalsMutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; MST[ConstructorCallMutator]MSP[] } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NonVoidMethodCallMutator]MSP[] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean isLongOption ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[] } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR1Mutator]MSP[] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[] currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR6Mutator]MSP[] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; MST[VoidMethodCallMutator]MSP[] cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR2Mutator]MSP[] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[] { handleOption ( options . getOption ( opt ) ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[] final String opt = token . substring ( 0 , pos ) ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[] if ( arguments != null ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[] if ( options . hasShortOption ( optName ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[MathMutator]MSP[] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String value = t . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; MST[ConstructorCallMutator]MSP[] } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR1Mutator]MSP[] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[] break; } } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR1Mutator]MSP[] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[] { currentOption = null ; } } private boolean isArgument ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[] {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[EmptyObjectReturnValsMutator]MSP[] } private boolean isJavaProperty ( final String token ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[] }
} else if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR5Mutator]MSP[] if ( options . hasLongOption ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR5Mutator]MSP[] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ABSMutator]MSP[] {
