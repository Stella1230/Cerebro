final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR2Mutator]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR3Mutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[] cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[] {
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[] { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.ABSMutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ABSMutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[] }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[] if ( arguments == null ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[] if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[] { final String str = iter . next () ;
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[] }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[]
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { try { opt . addValueForProcessing ( value ) ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI1Mutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI1Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI2Mutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI2Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[] } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[] { try { opt . addValueForProcessing ( value ) ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; MST[ReturnValsMutator]MSP[] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI3Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[] { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[] {
{ final String t = iterator . next () ; MST[NonVoidMethodCallMutator]MSP[] if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[]
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; MST[ConstructorCallMutator]MSP[] } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[] }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
protected void setOptions ( final Options options ) { this . options = options ; MST[experimental.MemberVariableMutator]MSP[] this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[] { final String str = iter . next () ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR3Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[] { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
getRequiredOptions () . remove ( group ) ; } group . setSelected ( opt ) ; MST[VoidMethodCallMutator]MSP[] } }
final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[] { eatTheRest = true ; } else {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[] } group . setSelected ( opt ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[] {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[ReturnValsMutator]MSP[] } protected List getRequiredOptions () { return requiredOptions ; }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR1Mutator]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; MST[VoidMethodCallMutator]MSP[] } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[ArgumentPropagationMutator]MSP[] } catch ( final RuntimeException exp ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[] return cmd ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR4Mutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[] {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[] if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[] cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
arguments = new String [ 0 ] ; MST[InlineConstantMutator]MSP[] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[] }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[] } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[]
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NegateConditionalsMutator]MSP[] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR1Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ABSMutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; MST[VoidMethodCallMutator]MSP[] cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[] } group . setSelected ( opt ) ; } }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[] { continue; } cmd . addOption ( opt ) ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI3Mutator]MSP[] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[] } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[rv.ROR5Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[] {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) MST[NonVoidMethodCallMutator]MSP[] { opt . clearValues () ; }
processOption ( t , iterator ) ; MST[VoidMethodCallMutator]MSP[] } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI4Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ABSMutator]MSP[] { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI4Mutator]MSP[] { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NullReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[] {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] if ( group . isRequired () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; MST[ConstructorCallMutator]MSP[] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[ReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR5Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( iterator . hasNext () )
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[] if ( arguments == null ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; MST[NonVoidMethodCallMutator]MSP[] break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR4Mutator]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[] checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR1Mutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR5Mutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[] {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[] { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[] { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[]
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[] { continue; } cmd . addOption ( opt ) ;
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; MST[EmptyObjectReturnValsMutator]MSP[] }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] if ( group . isRequired () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR2Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
arguments = new String [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[VoidMethodCallMutator]MSP[] } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[rv.ROR5Mutator]MSP[] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[] { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[] { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[] { try { opt . addValueForProcessing ( value ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR4Mutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[]
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NonVoidMethodCallMutator]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[] boolean eatTheRest = false ; if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NonVoidMethodCallMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI1Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[NegateConditionalsMutator]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI2Mutator]MSP[] { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[] {
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) { opt . clearValues () ; MST[VoidMethodCallMutator]MSP[] }
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NegateConditionalsMutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR6Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; MST[VoidMethodCallMutator]MSP[] } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[] }
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[] if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[NegateConditionalsMutator]MSP[] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[] }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[] { final String str = iter . next () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[] }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI4Mutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI4Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[] { final String str = iter . next () ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[] }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR1Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR3Mutator]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR5Mutator]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[NegateConditionalsMutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR2Mutator]MSP[] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[NullReturnValsMutator]MSP[] } protected List getRequiredOptions () { return requiredOptions ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[InlineConstantMutator]MSP[] if ( arguments == null ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[] { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR1Mutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR3Mutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[]
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[]
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[] }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[] } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; MST[NonVoidMethodCallMutator]MSP[] break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR5Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[] { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[rv.ROR5Mutator]MSP[] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[InlineConstantMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR3Mutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[] boolean eatTheRest = false ; if ( arguments == null ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[ArgumentPropagationMutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[] {
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[] if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI3Mutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI2Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { try { opt . addValueForProcessing ( value ) ; }
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { while ( iterator . hasNext () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI3Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[] } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[] } }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[]
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[] if ( arguments == null ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[] { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NegateConditionalsMutator]MSP[] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR4Mutator]MSP[] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI1Mutator]MSP[] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[] {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR2Mutator]MSP[] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[]
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[] { continue; } cmd . addOption ( opt ) ;
