else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[N] {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { final List < String > values = option . getValuesList () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[S] } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[ArgumentPropagationMutator]MSP[N]
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { final List < String > values = option . getValuesList () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[N] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR3Mutator]MSP[N] }
return answer ; MST[NullReturnValsMutator]MSP[N] } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] {
return getOptionValue ( String . valueOf ( opt ) ) ; } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N] for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[ReturnValsMutator]MSP[N] } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI1Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[ArgumentPropagationMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[N] {
else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[N] for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } else if ( values . size () == 1 ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NegateConditionalsMutator]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; MST[ReturnValsMutator]MSP[S] } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return answer ; } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final Option option : options ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[S] } public String getOptionValue ( final char opt , final String defaultValue ) {
else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[N] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; MST[ReturnValsMutator]MSP[S] } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] }
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; MST[NegateConditionalsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[EmptyObjectReturnValsMutator]MSP[N] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[ReturnValsMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[rv.ROR5Mutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; MST[ReturnValsMutator]MSP[N] } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public Object getOptionObject ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( opt . equals ( option . getOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NullReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR1Mutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[N] {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } else if ( values . size () == 1 ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return processed . toArray ( optionsArray ) ; MST[ArgumentPropagationMutator]MSP[S] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[N] {
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[ReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[S] } } return null ; } public String [] getOptionValues ( final char opt ) {
return answer ; } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
return answer ; } public List < String > getArgList () { return args ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt ) {
else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR4Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
public Iterator < Option > iterator () { return options . iterator () ; } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ; MST[NonVoidMethodCallMutator]MSP[N]
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; }
if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return answer ; MST[ReturnValsMutator]MSP[N] } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[N]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI4Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NullReturnValsMutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI2Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ArgumentPropagationMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NullReturnValsMutator]MSP[N] } catch ( final ParseException pe ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[N] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[N] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[ConstructorCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[S] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[VoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[S] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( values . size () == 1 ) {
return answer ; } public List < String > getArgList () { return args ; MST[ReturnValsMutator]MSP[N] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ParseException pe ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NullReturnValsMutator]MSP[S] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR4Mutator]MSP[N] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.ABSMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NullReturnValsMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] }
public Iterator < Option > iterator () { return options . iterator () ; MST[ReturnValsMutator]MSP[S] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; MST[NonVoidMethodCallMutator]MSP[N] args . toArray ( answer ) ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
public boolean hasOption ( final Option opt ) MST[ConstructorCallMutator]MSP[N] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[N] {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[InlineConstantMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[S] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[N] if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) { final List < String > values = option . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[N]
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ReturnValsMutator]MSP[N] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR2Mutator]MSP[N] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR5Mutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI3Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final char opt , final String defaultValue ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[S] for ( final Option option : options ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[N] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[N] {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.ROR5Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final String [] values = getOptionValues ( option ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[ReturnValsMutator]MSP[N] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[S] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[NegateConditionalsMutator]MSP[N] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { final List < String > values = option . getValuesList () ;
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; MST[VoidMethodCallMutator]MSP[N] return this ; }
public CommandLine build () { return commandLine ; MST[ReturnValsMutator]MSP[N] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[ReturnValsMutator]MSP[S] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[N] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[ReturnValsMutator]MSP[S] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
public CommandLine build () { return commandLine ; MST[NullReturnValsMutator]MSP[N] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[ConstructorCallMutator]MSP[N] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
