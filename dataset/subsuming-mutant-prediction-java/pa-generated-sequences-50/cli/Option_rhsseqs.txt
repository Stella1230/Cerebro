return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[NegateConditionalsMutator]MSP[S] } public String [] getValues () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[InlineConstantMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[NegateConditionalsMutator]MSP[S] {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[ReturnValsMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR3Mutator]MSP[N] { final char sep = getValueSeparator () ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[S] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.ABSMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; MST[NonVoidMethodCallMutator]MSP[S] return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[S] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI3Mutator]MSP[S] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI4Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[InlineConstantMutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR2Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI2Mutator]MSP[N] }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[N] option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public String [] getValues () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[InlineConstantMutator]MSP[N]
return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] {
return result ; MST[ReturnValsMutator]MSP[S] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
buf . append ( lr_7 ) . append ( type ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
int index = value . indexOf ( sep ) ; MST[ArgumentPropagationMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI1Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
return hasNoValues () ? null : values . get ( index ) ; MST[ReturnValsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI4Mutator]MSP[N]
return hasNoValues () ? null : values . get ( index ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[rv.ROR5Mutator]MSP[S] } public String [] getValues () {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return values . isEmpty () ; MST[ReturnValsMutator]MSP[N] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR5Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; MST[ConditionalsBoundaryMutator]MSP[S] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[VoidMethodCallMutator]MSP[N]
value = value . substring ( index + 1 ) ; MST[rv.UOI1Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR4Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR3Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[NonVoidMethodCallMutator]MSP[N] { final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR3Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return values . isEmpty () ; } return acceptsArg () ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; MST[experimental.MemberVariableMutator]MSP[N] } public String getArgName () { return argName ; } public boolean hasArgName ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[BooleanTrueReturnValsMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR3Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR4Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR2Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_4 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI3Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
if ( hasArgs () ) MST[rv.ROR3Mutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[S] return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . get ( index ) ; MST[NegateConditionalsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR6Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[InlineConstantMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR3Mutator]MSP[S] {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[NonVoidMethodCallMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[ReturnValsMutator]MSP[N] }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; MST[ConstructorCallMutator]MSP[N] return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[InlineConstantMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR5Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NullReturnValsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD1Mutator]MSP[S]
if ( this == o ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; MST[ReturnValsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI1Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR2Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
{ return argName != null && argName . length () > 0 ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR2Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[S] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; MST[VoidMethodCallMutator]MSP[N] } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR3Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ReturnValsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; MST[rv.UOI4Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return false ; } return true ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final char sep = getValueSeparator () ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[experimental.MemberVariableMutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; MST[rv.AOD2Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[NonVoidMethodCallMutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NegateConditionalsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI4Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
public int getId () { return getKey () . charAt ( 0 ) ; MST[ReturnValsMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[NegateConditionalsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD1Mutator]MSP[S]
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ABSMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[rv.CRCR5Mutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR1Mutator]MSP[N] { final char sep = getValueSeparator () ;
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI4Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR5Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; MST[NonVoidMethodCallMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR6Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.ABSMutator]MSP[N]
{ return argName != null && argName . length () > 0 ; MST[rv.ROR2Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return values . isEmpty () ; } return acceptsArg () ; MST[ReturnValsMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[rv.ROR5Mutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR5Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR2Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[rv.ROR4Mutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[S] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI4Mutator]MSP[N] }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final Option option = ( Option ) o ;
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[ReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[S] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return longOpt != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.ABSMutator]MSP[N]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI3Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return hasNoValues () ? null : values . get ( index ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[NegateConditionalsMutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; MST[ReturnValsMutator]MSP[N] } public Object getType () { return type ; } @Deprecated
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ABSMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOD2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[NegateConditionalsMutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI1Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR2Mutator]MSP[S] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR3Mutator]MSP[S]
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR2Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR4Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
if ( hasArgs () ) MST[NonVoidMethodCallMutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI4Mutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR5Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR5Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
buf . append ( lr_7 ) . append ( type ) ; MST[experimental.NakedReceiverMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[NonVoidMethodCallMutator]MSP[S] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.ROR5Mutator]MSP[N]
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI1Mutator]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[NegateConditionalsMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI3Mutator]MSP[N]
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[experimental.NakedReceiverMutator]MSP[S] if ( type != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( type != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR3Mutator]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR1Mutator]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[ConditionalsBoundaryMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public int getArgs () { return numberOfArgs ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
return values . isEmpty () ; } return acceptsArg () ; MST[BooleanFalseReturnValsMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; MST[experimental.MemberVariableMutator]MSP[N] } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; MST[ReturnValsMutator]MSP[N] } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR5Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return result ; MST[PrimitiveReturnsMutator]MSP[S] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI4Mutator]MSP[S] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ReturnValsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[S] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
buf . append ( lr_7 ) . append ( type ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return false ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return longOpt != null ; MST[rv.CRCR2Mutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR1Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR6Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[BooleanTrueReturnValsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[ReturnValsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ABSMutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI3Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR1Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; MST[ReturnValsMutator]MSP[N] } @Deprecated
public int getId () { return getKey () . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[InlineConstantMutator]MSP[N]
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[ReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[S] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
int index = value . indexOf ( sep ) ; MST[rv.UOI2Mutator]MSP[S] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR2Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] {
return values . isEmpty () ; } return acceptsArg () ; MST[NonVoidMethodCallMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; MST[ReturnValsMutator]MSP[N] } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired ()
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[NullReturnValsMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
value = value . substring ( index + 1 ) ; MST[rv.UOI2Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; MST[EmptyObjectReturnValsMutator]MSP[S] } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( this == o ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR5Mutator]MSP[S] {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[ReturnValsMutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI2Mutator]MSP[N] }
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; MST[VoidMethodCallMutator]MSP[N] } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[experimental.MemberVariableMutator]MSP[N] }
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.ABSMutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[MathMutator]MSP[N]
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR4Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR3Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI4Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[S] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[ReturnValsMutator]MSP[N] } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR4Mutator]MSP[S] {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[rv.ROR5Mutator]MSP[S] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.ABSMutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR1Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void clearValues () { values . clear () ; } @Deprecated public boolean addValue ( final String value ) { throw new UnsupportedOperationException ( lr_10 MST[ConstructorCallMutator]MSP[S] + lr_11 ) ; } boolean acceptsArg () {
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; MST[experimental.MemberVariableMutator]MSP[S] } public String getLongOpt () { return longOpt ; }
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[InlineConstantMutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR4Mutator]MSP[N] {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI2Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[InlineConstantMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR3Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR4Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR1Mutator]MSP[N]
if ( this == o ) { return true ; MST[ReturnValsMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Object getType () { return type ; } @Deprecated
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[InlineConstantMutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[ReturnValsMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[NonVoidMethodCallMutator]MSP[S]
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR1Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
if ( this == o ) MST[rv.ROR5Mutator]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[BooleanTrueReturnValsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
{ return required ; MST[ReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD2Mutator]MSP[S]
if ( this == o ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[InlineConstantMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[NegateConditionalsMutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder type ( final Class < ? > type ) { this . type = type ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[PrimitiveReturnsMutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.ABSMutator]MSP[N] }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR3Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI1Mutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
throw new RuntimeException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI4Mutator]MSP[S] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[S] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[rv.CRCR5Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( this == o ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
value = value . substring ( index + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; MST[experimental.NakedReceiverMutator]MSP[N] option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[NegateConditionalsMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR4Mutator]MSP[N]
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean hasArgName ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI3Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[ReturnValsMutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR1Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
value = value . substring ( index + 1 ) ; MST[rv.ABSMutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR4Mutator]MSP[N]
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR1Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[S] return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; MST[rv.CRCR1Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR5Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[experimental.NakedReceiverMutator]MSP[S] } buf . append ( lr_4 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR1Mutator]MSP[S]
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[ReturnValsMutator]MSP[S] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( this == o ) { return true ; MST[InlineConstantMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) MST[NegateConditionalsMutator]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return values . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI3Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final Option option = ( Option ) o ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR4Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[ConditionalsBoundaryMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ConditionalsBoundaryMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD2Mutator]MSP[S]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR4Mutator]MSP[N] { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
int index = value . indexOf ( sep ) ; MST[rv.ABSMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return false ; MST[InlineConstantMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[InlineConstantMutator]MSP[S] {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR3Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] {
if ( this == o ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI1Mutator]MSP[S] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[InlineConstantMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR5Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR4Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return values . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR1Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR4Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void clearValues () { values . clear () ; MST[VoidMethodCallMutator]MSP[S] } @Deprecated public boolean addValue ( final String value ) { throw new UnsupportedOperationException ( lr_10 + lr_11 ) ; } boolean acceptsArg () {
{ return argName != null && argName . length () > 0 ; MST[InlineConstantMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI3Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ABSMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR2Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR4Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[NegateConditionalsMutator]MSP[S] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[ConditionalsBoundaryMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI2Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR5Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[rv.CRCR4Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[N] } buf . append ( lr_4 ) ;
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[InlineConstantMutator]MSP[N] } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public Builder required () { return required ( true ) ; MST[InlineConstantMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOD1Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[ArgumentPropagationMutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI2Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[InlineConstantMutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR1Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } final Option option = ( Option ) o ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR2Mutator]MSP[S]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR3Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR1Mutator]MSP[N]
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[NullReturnValsMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR5Mutator]MSP[N] { final char sep = getValueSeparator () ;
return false ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR6Mutator]MSP[S] {
return values . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( type != null ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[ReturnValsMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI1Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR3Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder hasArg () { return hasArg ( true ) ; }
value = value . substring ( index + 1 ) ; MST[rv.UOI3Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[NegateConditionalsMutator]MSP[N] { final char sep = getValueSeparator () ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return longOpt != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR6Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR6Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR5Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[rv.ROR5Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI2Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.ABSMutator]MSP[N] return this ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[InlineConstantMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return required ; MST[BooleanTrueReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR4Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
{ return argName != null && argName . length () > 0 ; MST[InlineConstantMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR1Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return result ; MST[rv.ABSMutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; MST[PrimitiveReturnsMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ConditionalsBoundaryMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[ConstructorCallMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
if ( opt == null && longOpt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR2Mutator]MSP[N] { final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public String toString () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; MST[rv.UOI3Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[EmptyObjectReturnValsMutator]MSP[S] } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; MST[VoidMethodCallMutator]MSP[N] } private void add ( final String value ) { if ( ! acceptsArg () ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[ReturnValsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[MathMutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder type ( final Class < ? > type ) { this . type = type ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI3Mutator]MSP[N] }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.ABSMutator]MSP[S] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR2Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR3Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) MST[rv.ROR5Mutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; MST[ReturnValsMutator]MSP[N] }
return longOpt != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR6Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI1Mutator]MSP[S] }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder desc ( final String description ) { this . description = description ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder longOpt ( final String longOpt ) {
if ( hasArgs () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; MST[ReturnValsMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR2Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; MST[rv.CRCR6Mutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI3Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR1Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; MST[rv.UOI1Mutator]MSP[S] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[NegateConditionalsMutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
buf . append ( lr_7 ) . append ( type ) ; MST[experimental.NakedReceiverMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[ReturnValsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; MST[NullReturnValsMutator]MSP[N] } @Deprecated
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; MST[NullReturnValsMutator]MSP[N] } catch ( final CloneNotSupportedException cnse ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return longOpt != null ; MST[InlineConstantMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI4Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.ROR5Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; MST[InlineConstantMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR6Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR2Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI3Mutator]MSP[N] }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR4Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; MST[experimental.MemberVariableMutator]MSP[N] return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[MathMutator]MSP[N]
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( type != null ) {
if ( hasArgs () ) { buf . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI2Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[ReturnValsMutator]MSP[N] } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[S] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[rv.ROR1Mutator]MSP[S] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; MST[ReturnValsMutator]MSP[N] } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR1Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR1Mutator]MSP[N]
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI3Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ABSMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return required ; MST[BooleanFalseReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[NullReturnValsMutator]MSP[N] }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ; MST[experimental.MemberVariableMutator]MSP[S]
return this ; MST[NullReturnValsMutator]MSP[N] } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR2Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR6Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR3Mutator]MSP[N] }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.ABSMutator]MSP[S] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder required () { return required ( true ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder argName ( final String argName ) { this . argName = argName ; MST[experimental.MemberVariableMutator]MSP[S] return this ; } public Builder desc ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[NullReturnValsMutator]MSP[S] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[InlineConstantMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder required () { return required ( true ) ; MST[rv.CRCR2Mutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI4Mutator]MSP[N] return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[NegateConditionalsMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder desc ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR6Mutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR5Mutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR4Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Option build () {
return this ; MST[ReturnValsMutator]MSP[N] } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI3Mutator]MSP[N] return this ; }
public Builder required () { return required ( true ) ; MST[rv.CRCR3Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[NullReturnValsMutator]MSP[N] }
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; MST[ConstructorCallMutator]MSP[S] } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI1Mutator]MSP[N] return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[InlineConstantMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder required () { return required ( true ) ; MST[ReturnValsMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR5Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder desc ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
if ( opt == null && longOpt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[ConstructorCallMutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR4Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR5Mutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; MST[NullReturnValsMutator]MSP[S] } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder desc ( final String description ) { this . description = description ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder longOpt ( final String longOpt ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[experimental.MemberVariableMutator]MSP[S] return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; MST[ReturnValsMutator]MSP[S] } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder required () { return required ( true ) ; MST[experimental.NakedReceiverMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[ReturnValsMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; MST[NullReturnValsMutator]MSP[N] }
public Builder required () { return required ( true ) ; MST[NullReturnValsMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[ReturnValsMutator]MSP[N] }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI2Mutator]MSP[N] return this ; }
if ( opt == null && longOpt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
this . longOpt = longOpt ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder desc ( final String description ) { this . description = description ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder longOpt ( final String longOpt ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
