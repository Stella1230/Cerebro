else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[] {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { final List < String > values = option . getValuesList () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[] } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[] } public String getOptionValue ( final char opt ) {
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[ArgumentPropagationMutator]MSP[]
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { final List < String > values = option . getValuesList () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[] { final List < String > values = option . getValuesList () ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[] }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR3Mutator]MSP[] }
return answer ; MST[NullReturnValsMutator]MSP[] } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[] {
return getOptionValue ( String . valueOf ( opt ) ) ; } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[] for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[ReturnValsMutator]MSP[] } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI1Mutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[ArgumentPropagationMutator]MSP[] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[] {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[] {
else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[] for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] } else if ( values . size () == 1 ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NegateConditionalsMutator]MSP[] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; MST[ReturnValsMutator]MSP[] } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[ReturnValsMutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return answer ; } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] for ( final Option option : options ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[rv.ROR5Mutator]MSP[] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] } public String getOptionValue ( final char opt , final String defaultValue ) {
else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public boolean hasOption ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[] {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; MST[ReturnValsMutator]MSP[] } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[] }
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[] {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; MST[NegateConditionalsMutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[EmptyObjectReturnValsMutator]MSP[] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[ReturnValsMutator]MSP[] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[] } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[rv.ROR5Mutator]MSP[] }
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[] } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; MST[ReturnValsMutator]MSP[] } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[] { final List < String > values = option . getValuesList () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[] } public Object getOptionObject ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR1Mutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[] } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( opt . equals ( option . getOpt () ) ) MST[NegateConditionalsMutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { final List < String > values = option . getValuesList () ;
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[] { final List < String > values = option . getValuesList () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NullReturnValsMutator]MSP[] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR1Mutator]MSP[] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[] {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[ReturnValsMutator]MSP[] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[] } else if ( values . size () == 1 ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return processed . toArray ( optionsArray ) ; MST[ArgumentPropagationMutator]MSP[] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[] {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[] {
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[ReturnValsMutator]MSP[] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[] } public String getOptionValue ( final char opt , final String defaultValue ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[] } } return null ; } public String [] getOptionValues ( final char opt ) {
return answer ; } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[] } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[NegateConditionalsMutator]MSP[] { return null ; } final String [] values = getOptionValues ( option ) ;
return answer ; } public List < String > getArgList () { return args ; MST[EmptyObjectReturnValsMutator]MSP[] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public String getOptionValue ( final char opt ) {
else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR4Mutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[] if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { final List < String > values = option . getValuesList () ;
public Iterator < Option > iterator () { return options . iterator () ; } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ; MST[NonVoidMethodCallMutator]MSP[]
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return null ; }
if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return answer ; MST[ReturnValsMutator]MSP[] } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[] {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI4Mutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NullReturnValsMutator]MSP[] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI2Mutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ArgumentPropagationMutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NullReturnValsMutator]MSP[] } catch ( final ParseException pe ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NonVoidMethodCallMutator]MSP[] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[ConstructorCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[] } public Object getOptionObject ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public Object getOptionObject ( final char opt ) {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[VoidMethodCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean hasOption ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[] } else if ( values . size () == 1 ) {
return answer ; } public List < String > getArgList () { return args ; MST[ReturnValsMutator]MSP[] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final ParseException pe ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NullReturnValsMutator]MSP[] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR4Mutator]MSP[] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[rv.ROR5Mutator]MSP[] { return null ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[NegateConditionalsMutator]MSP[] { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.ABSMutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[] { final List < String > values = option . getValuesList () ;
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[] return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR2Mutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NullReturnValsMutator]MSP[] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[NonVoidMethodCallMutator]MSP[]
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[] }
public Iterator < Option > iterator () { return options . iterator () ; MST[ReturnValsMutator]MSP[] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ArgumentPropagationMutator]MSP[] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; MST[NonVoidMethodCallMutator]MSP[] args . toArray ( answer ) ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[] {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
public boolean hasOption ( final Option opt ) MST[ConstructorCallMutator]MSP[] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[] {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[InlineConstantMutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[] {
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[rv.ROR5Mutator]MSP[] { return null ; } final String [] values = getOptionValues ( option ) ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[] if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR3Mutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR5Mutator]MSP[] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[] } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) { final List < String > values = option . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[]
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NonVoidMethodCallMutator]MSP[] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[] } public boolean hasOption ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[] { final List < String > values = option . getValuesList () ;
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[NegateConditionalsMutator]MSP[] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ReturnValsMutator]MSP[] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR2Mutator]MSP[] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR5Mutator]MSP[] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI3Mutator]MSP[] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[EmptyObjectReturnValsMutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getOptionValue ( final char opt , final String defaultValue ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[] for ( final Option option : options ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[] {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[] {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.ROR5Mutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[] } final String [] values = getOptionValues ( option ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[ReturnValsMutator]MSP[] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[NegateConditionalsMutator]MSP[] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[] { final List < String > values = option . getValuesList () ;
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; MST[VoidMethodCallMutator]MSP[] return this ; }
public CommandLine build () { return commandLine ; MST[ReturnValsMutator]MSP[] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[] return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[NullReturnValsMutator]MSP[] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[ReturnValsMutator]MSP[] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[ReturnValsMutator]MSP[] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[NullReturnValsMutator]MSP[] }
public CommandLine build () { return commandLine ; MST[NullReturnValsMutator]MSP[] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[ConstructorCallMutator]MSP[] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
