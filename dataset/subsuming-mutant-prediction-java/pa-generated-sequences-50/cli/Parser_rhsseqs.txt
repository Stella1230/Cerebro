final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR2Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[N] { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.ABSMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N] if ( arguments == null ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N] if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { final String str = iter . next () ;
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[S] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N]
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[S] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI1Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI2Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[S] } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; MST[ReturnValsMutator]MSP[N] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI3Mutator]MSP[S] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] {
{ final String t = iterator . next () ; MST[NonVoidMethodCallMutator]MSP[N] if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N]
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; MST[ConstructorCallMutator]MSP[S] } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
protected void setOptions ( final Options options ) { this . options = options ; MST[experimental.MemberVariableMutator]MSP[N] this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { final String str = iter . next () ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[S] { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
getRequiredOptions () . remove ( group ) ; } group . setSelected ( opt ) ; MST[VoidMethodCallMutator]MSP[N] } }
final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[S] { eatTheRest = true ; } else {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } group . setSelected ( opt ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[S] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[N] {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[ReturnValsMutator]MSP[N] } protected List getRequiredOptions () { return requiredOptions ; }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[N] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR1Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; MST[VoidMethodCallMutator]MSP[N] } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[ArgumentPropagationMutator]MSP[S] } catch ( final RuntimeException exp ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[S] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[N] return cmd ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
arguments = new String [ 0 ] ; MST[InlineConstantMutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[N] }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[S] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N]
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NegateConditionalsMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ABSMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; MST[VoidMethodCallMutator]MSP[N] cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } group . setSelected ( opt ) ; } }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI3Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[S] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[S] } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) MST[NonVoidMethodCallMutator]MSP[N] { opt . clearValues () ; }
processOption ( t , iterator ) ; MST[VoidMethodCallMutator]MSP[N] } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[S] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ABSMutator]MSP[N] { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI4Mutator]MSP[N] { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[N] {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; MST[ConstructorCallMutator]MSP[S] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[S] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[S] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[S] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[S] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iterator . hasNext () )
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N] if ( arguments == null ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; MST[NonVoidMethodCallMutator]MSP[S] break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR4Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[N] checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[S] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[S] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[N] {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[N] { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; MST[EmptyObjectReturnValsMutator]MSP[N] }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
arguments = new String [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[VoidMethodCallMutator]MSP[N] } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[rv.ROR5Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[S] { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR4Mutator]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N]
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NonVoidMethodCallMutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[S] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[N] boolean eatTheRest = false ; if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[NegateConditionalsMutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[S] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI2Mutator]MSP[N] { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] {
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) { opt . clearValues () ; MST[VoidMethodCallMutator]MSP[N] }
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; MST[VoidMethodCallMutator]MSP[N] } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[N] }
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[S] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { final String str = iter . next () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[S] }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI4Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { final String str = iter . next () ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[N] }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[S] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR3Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR5Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[NullReturnValsMutator]MSP[N] } protected List getRequiredOptions () { return requiredOptions ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[InlineConstantMutator]MSP[N] if ( arguments == null ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR1Mutator]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N]
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N]
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[N] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; MST[NonVoidMethodCallMutator]MSP[N] break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[S] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[rv.ROR5Mutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[N] boolean eatTheRest = false ; if ( arguments == null ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[ArgumentPropagationMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[S] {
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[N] if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI3Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[S] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { while ( iterator . hasNext () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[N] } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N]
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N] if ( arguments == null ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[S] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NegateConditionalsMutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR4Mutator]MSP[S] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI1Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[S] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[N] {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N]
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
