matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[VoidMethodCallMutator]MSP[] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR4Mutator]MSP[] {
{ addOption ( opt , null , false , description ) ; MST[InlineConstantMutator]MSP[] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[] option . setRequired ( true ) ; addOption ( option ) ;
return this ; MST[NullReturnValsMutator]MSP[] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public List getRequiredOptions () {
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[] }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR1Mutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[] } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[EmptyObjectReturnValsMutator]MSP[] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[] }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[NonVoidMethodCallMutator]MSP[] } public List getRequiredOptions () {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[]
{ if ( requiredOpts . contains ( key ) ) MST[NegateConditionalsMutator]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR5Mutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ArgumentPropagationMutator]MSP[] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.ABSMutator]MSP[] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR3Mutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[ReturnValsMutator]MSP[] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR1Mutator]MSP[] addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[]
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.ABSMutator]MSP[] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[] }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR5Mutator]MSP[] addOption ( option ) ;
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[EmptyObjectReturnValsMutator]MSP[] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[experimental.NakedReceiverMutator]MSP[] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR1Mutator]MSP[] { return shortOpts . get ( opt ) ; }
public Options addOptionGroup ( final OptionGroup group ) MST[ConstructorCallMutator]MSP[] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( opt . isRequired () )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[ReturnValsMutator]MSP[] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NegateConditionalsMutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI3Mutator]MSP[] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NonVoidMethodCallMutator]MSP[] { return shortOpts . get ( opt ) ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] final List < String > matchingOpts = new ArrayList < String > () ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[]
optionGroups . put ( option . getKey () , group ) ; MST[ArgumentPropagationMutator]MSP[] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR2Mutator]MSP[] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR3Mutator]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[] }
return shortOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR6Mutator]MSP[] addOption ( option ) ;
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[] }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[] final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ReturnValsMutator]MSP[] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR3Mutator]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR5Mutator]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR4Mutator]MSP[] { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR2Mutator]MSP[] { return shortOpts . get ( opt ) ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[]
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ReturnValsMutator]MSP[] } public List getRequiredOptions () {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR6Mutator]MSP[] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[InlineConstantMutator]MSP[] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[ConstructorCallMutator]MSP[] option . setRequired ( true ) ; addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[NonVoidMethodCallMutator]MSP[] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI4Mutator]MSP[] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NegateConditionalsMutator]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NullReturnValsMutator]MSP[] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NegateConditionalsMutator]MSP[] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[ReturnValsMutator]MSP[] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[] }
return longOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[] }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI1Mutator]MSP[] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[] return buf . toString () ; }
buf . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR1Mutator]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; MST[NonVoidMethodCallMutator]MSP[] if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ReturnValsMutator]MSP[] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[] }
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addOptionGroup ( final OptionGroup group ) MST[experimental.MemberVariableMutator]MSP[] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ addOption ( opt , null , false , description ) ; MST[experimental.NakedReceiverMutator]MSP[] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
{ addOption ( opt , null , false , description ) ; return this ; MST[NullReturnValsMutator]MSP[] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR1Mutator]MSP[] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.ABSMutator]MSP[] return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR5Mutator]MSP[] {
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR3Mutator]MSP[] {
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ; MST[ConstructorCallMutator]MSP[]
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[NonVoidMethodCallMutator]MSP[] return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR2Mutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) MST[NonVoidMethodCallMutator]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) MST[NonVoidMethodCallMutator]MSP[] { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[] }
return shortOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; return this ; MST[ReturnValsMutator]MSP[] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[ArgumentPropagationMutator]MSP[] return this ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[]
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR2Mutator]MSP[] }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR4Mutator]MSP[] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[NullReturnValsMutator]MSP[] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR3Mutator]MSP[] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR4Mutator]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR2Mutator]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR1Mutator]MSP[] {
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[InlineConstantMutator]MSP[] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR5Mutator]MSP[] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[] }
return this ; MST[ReturnValsMutator]MSP[] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ConstructorCallMutator]MSP[] } public Options addOption ( final String opt , final String description )
buf . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[NonVoidMethodCallMutator]MSP[] } public Options addOption ( final String opt , final String description )
return Collections . unmodifiableList ( requiredOpts ) ; MST[ReturnValsMutator]MSP[] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[ArgumentPropagationMutator]MSP[] } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR1Mutator]MSP[] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[]
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[EmptyObjectReturnValsMutator]MSP[] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ReturnValsMutator]MSP[] } public Options addOption ( final String opt , final String description )
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR4Mutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[NullReturnValsMutator]MSP[] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR3Mutator]MSP[] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
return longOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[] return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NegateConditionalsMutator]MSP[] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NonVoidMethodCallMutator]MSP[] {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR2Mutator]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; MST[NonVoidMethodCallMutator]MSP[] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( lr_3 ) ; return buf . toString () ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR1Mutator]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR4Mutator]MSP[] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR5Mutator]MSP[] { return shortOpts . get ( opt ) ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI2Mutator]MSP[] return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NonVoidMethodCallMutator]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[] }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[NullReturnValsMutator]MSP[] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( lr_3 ) ; return buf . toString () ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[ReturnValsMutator]MSP[] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[NonVoidMethodCallMutator]MSP[] return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[] return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ConstructorCallMutator]MSP[] } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[ReturnValsMutator]MSP[] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[ArgumentPropagationMutator]MSP[] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[NullReturnValsMutator]MSP[] }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR3Mutator]MSP[] addOption ( option ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR6Mutator]MSP[] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[]
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[]
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[experimental.NakedReceiverMutator]MSP[] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[VoidMethodCallMutator]MSP[] addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR3Mutator]MSP[] { return shortOpts . get ( opt ) ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( opt . isRequired () )
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
return Collections . unmodifiableList ( requiredOpts ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[ConstructorCallMutator]MSP[] return this ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[ReturnValsMutator]MSP[] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR4Mutator]MSP[] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR5Mutator]MSP[] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR5Mutator]MSP[] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR2Mutator]MSP[] {
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[NonVoidMethodCallMutator]MSP[] return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) MST[NonVoidMethodCallMutator]MSP[] { if ( longOpt . startsWith ( opt ) ) {
