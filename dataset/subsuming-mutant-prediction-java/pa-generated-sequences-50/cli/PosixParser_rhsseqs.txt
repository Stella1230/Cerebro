tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[MathMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR5Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[ConstructorCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[NegateConditionalsMutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR4Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR5Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[S]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } gobble ( iter ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOD2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[ConstructorCallMutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[MathMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( pos != - 1 ) MST[InlineConstantMutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR4Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NegateConditionalsMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
if ( pos != - 1 ) MST[rv.CRCR1Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] break;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR2Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] { eatTheRest = true ; }
private void init () { eatTheRest = false ; MST[experimental.MemberVariableMutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ;
if ( pos != - 1 ) MST[rv.UOI2Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ; MST[experimental.MemberVariableMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } gobble ( iter ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR1Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.CRCR6Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } }
} } else if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI3Mutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[S]
else if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ReturnValsMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { while ( iter . hasNext () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR3Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[N] { while ( iter . hasNext () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } gobble ( iter ) ; }
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[NegateConditionalsMutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOD2Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( pos != - 1 ) MST[rv.UOI4Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] break;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR4Mutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR1Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
} } else if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR3Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR3Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR4Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; MST[experimental.MemberVariableMutator]MSP[N] if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ;
if ( pos != - 1 ) MST[rv.ABSMutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N]
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR4Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR3Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } gobble ( iter ) ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N]
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; MST[VoidMethodCallMutator]MSP[N] this . options = options ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI1Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) MST[rv.CRCR5Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR6Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[experimental.MemberVariableMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[InlineConstantMutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) MST[rv.UOI3Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR3Mutator]MSP[N] {
if ( options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] { eatTheRest = true ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI4Mutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { while ( iter . hasNext () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR2Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] break;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[S]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[InlineConstantMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR3Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR6Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR2Mutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR2Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
else if ( matchingOpts . size () > 1 ) MST[rv.ROR3Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[NonVoidMethodCallMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( pos != - 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR5Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.ROR1Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[S] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
} } else if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NonVoidMethodCallMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOD1Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { while ( iter . hasNext () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { while ( iter . hasNext () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( pos != - 1 ) MST[rv.CRCR4Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NullReturnValsMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[S]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOD1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[S] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR3Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[InlineConstantMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ;
else if ( matchingOpts . size () > 1 ) MST[InlineConstantMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { while ( iter . hasNext () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR2Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ;
if ( options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR2Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[ConditionalsBoundaryMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[InlineConstantMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR4Mutator]MSP[S] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR2Mutator]MSP[N] {
} } else if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR2Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; MST[experimental.MemberVariableMutator]MSP[S] } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR6Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR2Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
private void init () { eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void init () { eatTheRest = false ; MST[InlineConstantMutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } gobble ( iter ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[experimental.MemberVariableMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[VoidMethodCallMutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[S] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI1Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) MST[ConditionalsBoundaryMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR5Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) MST[NonVoidMethodCallMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[S]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
private void init () { eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR4Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.ROR4Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ;
} } else if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[N] break;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; MST[ConstructorCallMutator]MSP[N] } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR4Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR5Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR1Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR2Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR6Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; MST[ConstructorCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR1Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.ABSMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI3Mutator]MSP[S] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[InlineConstantMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[NonVoidMethodCallMutator]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; MST[VoidMethodCallMutator]MSP[N] }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ABSMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR3Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR3Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] break;
private void init () { eatTheRest = false ; tokens . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break;
if ( options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { while ( iter . hasNext () ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
} } else if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR5Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR6Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[experimental.MemberVariableMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR5Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR5Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.CRCR2Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI2Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
if ( pos != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] break;
tokens . add ( lr_1 + ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR4Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR1Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
else if ( matchingOpts . size () > 1 ) MST[rv.ROR5Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] break;
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR1Mutator]MSP[N] {
if ( pos != - 1 ) MST[rv.UOI1Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] break;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
else if ( matchingOpts . size () > 1 ) MST[NegateConditionalsMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR5Mutator]MSP[N] {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.ABSMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR4Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
private void init () { eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
private void init () { eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ;
{ tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ;
