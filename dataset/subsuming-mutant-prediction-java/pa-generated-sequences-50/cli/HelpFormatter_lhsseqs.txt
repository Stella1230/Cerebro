renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI1Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR5Mutator]MSP[]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR3Mutator]MSP[] { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[] { return pos + 1 ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR5Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[NegateConditionalsMutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } } return sb ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( lr_5 ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR6Mutator]MSP[]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR2Mutator]MSP[] { appendOption ( buff , it . next () , true ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI4Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOD1Mutator]MSP[] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR5Mutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasLongOpt () ) MST[NonVoidMethodCallMutator]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[PrimitiveReturnsMutator]MSP[] }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR3Mutator]MSP[] { buff . append ( lr_5 ) ; } }
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR6Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI3Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[MathMutator]MSP[] return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[] { return pos + 1 ; }
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; MST[EmptyObjectReturnValsMutator]MSP[] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR3Mutator]MSP[] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR6Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; MST[NonVoidMethodCallMutator]MSP[] appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
if ( argName != null && argName . length () == 0 ) MST[rv.ROR3Mutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } } prefixList . add ( optBuf ) ; MST[NonVoidMethodCallMutator]MSP[]
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR5Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR3Mutator]MSP[] if ( option . getDescription () != null ) {
if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR2Mutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR2Mutator]MSP[]
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } } prefixList . add ( optBuf ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR5Mutator]MSP[] {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI4Mutator]MSP[] {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[] } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ABSMutator]MSP[] { buff . append ( lr_5 ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; MST[IncrementsMutator]MSP[]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR4Mutator]MSP[] { -- pos ;
if ( option . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ABSMutator]MSP[] { sb . append ( rtrim ( text ) ) ;
} return s . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR4Mutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[InlineConstantMutator]MSP[] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[]
} return s . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[ArgumentPropagationMutator]MSP[] } }
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; MST[ReturnValsMutator]MSP[] }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR2Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.ABSMutator]MSP[] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[] } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[] { final char c = text . charAt ( pos ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[InlineConstantMutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR1Mutator]MSP[] { buff . append ( lr_5 ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( option . getOpt () != null ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[] }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR4Mutator]MSP[]
if ( argName != null && argName . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
} return s . substring ( 0 , pos ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( ! group . isRequired () ) MST[rv.ROR1Mutator]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { sb . append ( text ) ; return sb ; }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI2Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR5Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI3Mutator]MSP[] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[] { final char c = text . charAt ( pos ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI3Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasLongOpt () ) MST[rv.ROR3Mutator]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI1Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[MathMutator]MSP[] { final char c = text . charAt ( pos ) ;
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR3Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[NonVoidMethodCallMutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI4Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.ABSMutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
catch ( final IOException e ) { } return sb ; MST[ReturnValsMutator]MSP[] } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.ABSMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI4Mutator]MSP[] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR2Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ABSMutator]MSP[] }
if ( argName != null && argName . length () == 0 ) MST[rv.ROR5Mutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR4Mutator]MSP[] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[InlineConstantMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[NonVoidMethodCallMutator]MSP[] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( ! group . isRequired () ) MST[rv.ROR4Mutator]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI1Mutator]MSP[] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NegateConditionalsMutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( getOptionComparator () != null ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI2Mutator]MSP[] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR5Mutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR1Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[MathMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[InlineConstantMutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI1Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR3Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR1Mutator]MSP[] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[ConditionalsBoundaryMutator]MSP[] { -- pos ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[]
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[InlineConstantMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR1Mutator]MSP[] }
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[rv.ROR5Mutator]MSP[] } } prefixList . add ( optBuf ) ;
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR2Mutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR3Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI1Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } } prefixList . add ( optBuf ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR4Mutator]MSP[] { buff . append ( lr_5 ) ; } }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI3Mutator]MSP[] } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI1Mutator]MSP[] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI2Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI3Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI1Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI2Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ABSMutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[NegateConditionalsMutator]MSP[] {
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[] { final char c = text . charAt ( pos ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[ConstructorCallMutator]MSP[] if ( optBuf . length () < max ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; MST[VoidMethodCallMutator]MSP[] } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI2Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR2Mutator]MSP[] { final String argName = option . getArgName () ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[InlineConstantMutator]MSP[] }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI2Mutator]MSP[] { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[InlineConstantMutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOD2Mutator]MSP[] { -- pos ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] {
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
if ( s == null || s . length () == 0 ) MST[rv.ROR1Mutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR6Mutator]MSP[] { -- pos ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR2Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[EmptyObjectReturnValsMutator]MSP[] } protected String rtrim ( final String s ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) MST[rv.AOD1Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR2Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR5Mutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[IncrementsMutator]MSP[] if ( optBuf . length () < max ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR5Mutator]MSP[] } final String padding = createPadding ( nextLineTabStop ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR3Mutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR1Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[NonVoidMethodCallMutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[NonVoidMethodCallMutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI3Mutator]MSP[] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI3Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI2Mutator]MSP[] } }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.ABSMutator]MSP[]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOD1Mutator]MSP[] { final char c = text . charAt ( pos ) ;
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; MST[EmptyObjectReturnValsMutator]MSP[] } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; }
} return s . substring ( 0 , pos ) ; MST[ReturnValsMutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI4Mutator]MSP[] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOD1Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[]
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR4Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI4Mutator]MSP[] } public int getLeftPadding () { return defaultLeftPad ; }
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR4Mutator]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI1Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI3Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[] { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR2Mutator]MSP[] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.ABSMutator]MSP[] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[NegateConditionalsMutator]MSP[] { final char c = text . charAt ( pos ) ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.ABSMutator]MSP[] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[] { final char c = text . charAt ( pos ) ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR5Mutator]MSP[] }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR1Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[] { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI1Mutator]MSP[] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.ABSMutator]MSP[] } }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR3Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR4Mutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[] } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI3Mutator]MSP[] if ( optBuf . length () < max ) {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.ABSMutator]MSP[] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR1Mutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( s == null || s . length () == 0 ) { return s ; MST[ReturnValsMutator]MSP[] } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOD2Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR5Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[NonVoidMethodCallMutator]MSP[] {
if ( startPos + width >= text . length () ) MST[rv.UOI3Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[]
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[ConditionalsBoundaryMutator]MSP[] {
if ( startPos + width >= text . length () ) MST[rv.ROR1Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI1Mutator]MSP[] } }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR5Mutator]MSP[] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } prefixList . add ( optBuf ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI3Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[] { final char c = text . charAt ( pos ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI4Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; MST[ReturnValsMutator]MSP[] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[NonVoidMethodCallMutator]MSP[]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.ABSMutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR2Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[] { -- pos ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.ABSMutator]MSP[] return pos == text . length () ? - 1 : pos ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI3Mutator]MSP[] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.ABSMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR1Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR2Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR5Mutator]MSP[] } }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI4Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[] { sb . append ( text ) ; return sb ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[NonVoidMethodCallMutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR3Mutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.ABSMutator]MSP[] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[InlineConstantMutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ABSMutator]MSP[] }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.ABSMutator]MSP[] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR1Mutator]MSP[] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI2Mutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[NonVoidMethodCallMutator]MSP[] {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[NonVoidMethodCallMutator]MSP[]
max = optBuf . length () > max ? optBuf . length () : max ; MST[ConditionalsBoundaryMutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR3Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI1Mutator]MSP[] } public int getLeftPadding () { return defaultLeftPad ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; MST[NullReturnValsMutator]MSP[] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[] { -- pos ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR5Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR1Mutator]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR2Mutator]MSP[] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; MST[ConstructorCallMutator]MSP[] String line ; boolean firstLine = true ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } } prefixList . add ( optBuf ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI2Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) MST[rv.ROR4Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[ConditionalsBoundaryMutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI1Mutator]MSP[] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[experimental.MemberVariableMutator]MSP[] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( s == null || s . length () == 0 ) { return s ; MST[EmptyObjectReturnValsMutator]MSP[] } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR1Mutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[NonVoidMethodCallMutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR4Mutator]MSP[] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; MST[NullReturnValsMutator]MSP[] }
if ( startPos + width >= text . length () ) MST[MathMutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI4Mutator]MSP[] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[] { return pos + 1 ; }
} return s . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI4Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR3Mutator]MSP[]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[VoidMethodCallMutator]MSP[] } else { printUsage ( pw , width , cmdLineSyntax ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[NegateConditionalsMutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR4Mutator]MSP[] }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[ConstructorCallMutator]MSP[] } protected String rtrim ( final String s ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR5Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[] {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR3Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[experimental.NakedReceiverMutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[InlineConstantMutator]MSP[]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI2Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR2Mutator]MSP[] } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR3Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[] }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[experimental.MemberVariableMutator]MSP[] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[ArgumentPropagationMutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; MST[experimental.NakedReceiverMutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI2Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR4Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.ABSMutator]MSP[] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI2Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR3Mutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } } return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR4Mutator]MSP[] }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; MST[VoidMethodCallMutator]MSP[] } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[NonVoidMethodCallMutator]MSP[] { final String argName = option . getArgName () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NegateConditionalsMutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI3Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { -- pos ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[NonVoidMethodCallMutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI3Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI1Mutator]MSP[] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI2Mutator]MSP[] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI2Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR2Mutator]MSP[]
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[InlineConstantMutator]MSP[] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[] }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI1Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI4Mutator]MSP[] } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR1Mutator]MSP[]
} return s . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.UOI4Mutator]MSP[]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { -- pos ;
if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( ! group . isRequired () ) MST[NegateConditionalsMutator]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR1Mutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( it . hasNext () ) {
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI2Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[rv.ROR5Mutator]MSP[] {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[experimental.NakedReceiverMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI4Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[ConditionalsBoundaryMutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR2Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.ABSMutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[InlineConstantMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR2Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[] {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[NonVoidMethodCallMutator]MSP[] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI4Mutator]MSP[] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI2Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR4Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR2Mutator]MSP[]
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[NegateConditionalsMutator]MSP[] { buff . append ( lr_5 ) ; } }
if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR3Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD2Mutator]MSP[] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR6Mutator]MSP[] }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( optBuf . length () < max ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR3Mutator]MSP[] } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR3Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR3Mutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
} return s . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.UOI1Mutator]MSP[] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR2Mutator]MSP[] if ( option . getDescription () != null ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ABSMutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR3Mutator]MSP[] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[ReturnValsMutator]MSP[] }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR6Mutator]MSP[] } final String padding = createPadding ( nextLineTabStop ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI1Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI3Mutator]MSP[] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[NegateConditionalsMutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[NonVoidMethodCallMutator]MSP[] {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR1Mutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { return pos + 1 ; }
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI1Mutator]MSP[] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[experimental.MemberVariableMutator]MSP[] } public int getLeftPadding () { return defaultLeftPad ; }
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI4Mutator]MSP[] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI3Mutator]MSP[] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.ABSMutator]MSP[] } printOptions ( pw , width , options , leftPad , descPad ) ;
printWrapped ( pw , width , 0 , text ) ; MST[InlineConstantMutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[InlineConstantMutator]MSP[]
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[ReturnValsMutator]MSP[] }
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI1Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI1Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[] { -- pos ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR4Mutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ABSMutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.UOI1Mutator]MSP[] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI4Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR6Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR4Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOD2Mutator]MSP[] if ( option . getDescription () != null ) {
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; MST[EmptyObjectReturnValsMutator]MSP[] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR3Mutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[] } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[] {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { appendOption ( buff , it . next () , true ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR2Mutator]MSP[]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI4Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR5Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[] }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI4Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR3Mutator]MSP[] { final String argName = option . getArgName () ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[]
buff . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOD1Mutator]MSP[] { -- pos ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI3Mutator]MSP[] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI4Mutator]MSP[] { -- pos ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ABSMutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ABSMutator]MSP[] { sb . append ( text ) ; return sb ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[VoidMethodCallMutator]MSP[] } printOptions ( pw , width , options , leftPad , descPad ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } } prefixList . add ( optBuf ) ;
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI1Mutator]MSP[] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR6Mutator]MSP[]
} return s . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI2Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI4Mutator]MSP[] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.UOI4Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI3Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR2Mutator]MSP[] }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR1Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR6Mutator]MSP[] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR5Mutator]MSP[] { buff . append ( lr_5 ) ; } }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( ! group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; MST[VoidMethodCallMutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[VoidMethodCallMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI3Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; MST[NonVoidMethodCallMutator]MSP[] while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR1Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR5Mutator]MSP[]
while ( ( line = in . readLine () ) != null ) MST[NegateConditionalsMutator]MSP[] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[MathMutator]MSP[] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI4Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( startPos + width >= text . length () ) MST[rv.ROR2Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR3Mutator]MSP[] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR5Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( ! group . isRequired () ) MST[rv.ROR5Mutator]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI2Mutator]MSP[] {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[] { buff . append ( lr_5 ) ; } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR4Mutator]MSP[] { buff . append ( lr_5 ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
while ( ( line = in . readLine () ) != null ) MST[rv.ROR5Mutator]MSP[] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[VoidMethodCallMutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( startPos + width >= text . length () ) MST[NegateConditionalsMutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[ConditionalsBoundaryMutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
while ( ( line = in . readLine () ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } } prefixList . add ( optBuf ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.ABSMutator]MSP[] } else { printUsage ( pw , width , cmdLineSyntax ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.ABSMutator]MSP[] } }
if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI4Mutator]MSP[] } printOptions ( pw , width , options , leftPad , descPad ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI2Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[] { sb . append ( rtrim ( text ) ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.UOI2Mutator]MSP[] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[] { sb . append ( text ) ; return sb ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI1Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[] }
} if ( header != null && header . trim () . length () > 0 ) MST[experimental.NakedReceiverMutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[NegateConditionalsMutator]MSP[] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI2Mutator]MSP[] } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR2Mutator]MSP[]
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI3Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR3Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI2Mutator]MSP[] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[PrimitiveReturnsMutator]MSP[] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[PrimitiveReturnsMutator]MSP[] }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI1Mutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI3Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( option . hasLongOpt () ) MST[rv.ROR1Mutator]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR2Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI3Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ; MST[NonVoidMethodCallMutator]MSP[]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[] { -- pos ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.ABSMutator]MSP[] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR4Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NegateConditionalsMutator]MSP[]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI4Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI1Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI4Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[] { -- pos ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ABSMutator]MSP[] {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOD2Mutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.ABSMutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR6Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI1Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[] { sb . append ( text ) ; return sb ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ABSMutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( startPos + width >= text . length () ) MST[rv.UOI3Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR5Mutator]MSP[] { -- pos ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[] } public String getOptPrefix () { return defaultOptPrefix ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[]
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI2Mutator]MSP[] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
} return s . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ABSMutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[] } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR3Mutator]MSP[] {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } }
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[]
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI1Mutator]MSP[] } printOptions ( pw , width , options , leftPad , descPad ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[] }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[]
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR5Mutator]MSP[]
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI1Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR3Mutator]MSP[] { appendOption ( buff , it . next () , true ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI3Mutator]MSP[]
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[VoidMethodCallMutator]MSP[] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR6Mutator]MSP[]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.ABSMutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[ConstructorCallMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI2Mutator]MSP[] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR4Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI1Mutator]MSP[] } }
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR3Mutator]MSP[]
if ( ! group . isRequired () ) MST[rv.ROR2Mutator]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[ConstructorCallMutator]MSP[] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR5Mutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR6Mutator]MSP[] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI4Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI1Mutator]MSP[] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR4Mutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR5Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR3Mutator]MSP[] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[InlineConstantMutator]MSP[] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[] }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR5Mutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) MST[rv.ROR4Mutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[rv.ROR5Mutator]MSP[]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NegateConditionalsMutator]MSP[] { -- pos ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final String argName = option . getArgName () ;
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; MST[EmptyObjectReturnValsMutator]MSP[] } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[NegateConditionalsMutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOD1Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI4Mutator]MSP[] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI1Mutator]MSP[] if ( option . getDescription () != null ) {
if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[] { return pos + 1 ; }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; MST[ConstructorCallMutator]MSP[] String line ; boolean firstLine = true ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR5Mutator]MSP[] }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[] {
if ( startPos + width >= text . length () ) MST[rv.AOR1Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR1Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( startPos + width >= text . length () ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasLongOpt () ) MST[rv.ROR4Mutator]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( ! processedGroups . contains ( group ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ABSMutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; MST[ReturnValsMutator]MSP[] } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[ArgumentPropagationMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( startPos + width >= text . length () ) MST[rv.ROR5Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.ABSMutator]MSP[] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } prefixList . add ( optBuf ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR4Mutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[ArgumentPropagationMutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[MathMutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR2Mutator]MSP[] { -- pos ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR2Mutator]MSP[] { buff . append ( lr_5 ) ; } }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[NegateConditionalsMutator]MSP[] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[ConditionalsBoundaryMutator]MSP[] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.UOI2Mutator]MSP[] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[] { -- pos ;
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI1Mutator]MSP[] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR4Mutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR3Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[ArgumentPropagationMutator]MSP[]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI2Mutator]MSP[] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI3Mutator]MSP[] { -- pos ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR6Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR1Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.ABSMutator]MSP[] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR4Mutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI1Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR4Mutator]MSP[] { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) MST[rv.ROR3Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR3Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[MathMutator]MSP[] { -- pos ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[] {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[ConditionalsBoundaryMutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI4Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[InlineConstantMutator]MSP[] } final String padding = createPadding ( nextLineTabStop ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR4Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI4Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR2Mutator]MSP[]
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI2Mutator]MSP[] if ( option . getDescription () != null ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI1Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR3Mutator]MSP[] }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR6Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR5Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI1Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; MST[ReturnValsMutator]MSP[] }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR4Mutator]MSP[] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI2Mutator]MSP[] } public int getLeftPadding () { return defaultLeftPad ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR3Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI3Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR3Mutator]MSP[] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR5Mutator]MSP[] }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.AOR1Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; MST[ConstructorCallMutator]MSP[] final List < Option > optList = options . helpOptions () ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR1Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI4Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; MST[ReturnValsMutator]MSP[] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR4Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI1Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR1Mutator]MSP[]
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[] }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI4Mutator]MSP[] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR1Mutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[InlineConstantMutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[] } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR2Mutator]MSP[] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR3Mutator]MSP[]
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI1Mutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR4Mutator]MSP[] { -- pos ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR1Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ABSMutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI4Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR1Mutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[experimental.NakedReceiverMutator]MSP[]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; MST[VoidMethodCallMutator]MSP[] } if ( it . hasNext () ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI3Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.ABSMutator]MSP[] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI1Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ; MST[NonVoidMethodCallMutator]MSP[]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR1Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR2Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR5Mutator]MSP[]
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR2Mutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR4Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void printHelp ( final int width , final String cmdLineSyntax , final String header , final Options options , final String footer , final boolean autoUsage ) { final PrintWriter pw = new PrintWriter ( System . out ) ; MST[ConstructorCallMutator]MSP[]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] } } return sb ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( startPos + width >= text . length () ) MST[rv.AOR4Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR4Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR6Mutator]MSP[] } }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI4Mutator]MSP[] if ( optBuf . length () < max ) {
if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[]
optBuf . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.ABSMutator]MSP[] } public int getLeftPadding () { return defaultLeftPad ; }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ; MST[ConstructorCallMutator]MSP[]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR3Mutator]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
catch ( final IOException e ) { } return sb ; MST[NullReturnValsMutator]MSP[] } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOD1Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; MST[NonVoidMethodCallMutator]MSP[] final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[NegateConditionalsMutator]MSP[] { buff . append ( lr_5 ) ; } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI4Mutator]MSP[] } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI2Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[] { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI4Mutator]MSP[] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.ABSMutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR1Mutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI4Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ROR5Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.ABSMutator]MSP[] if ( option . getDescription () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI4Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR6Mutator]MSP[] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOD1Mutator]MSP[]
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR2Mutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI3Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR4Mutator]MSP[]
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI3Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.ABSMutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR1Mutator]MSP[] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR3Mutator]MSP[]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR4Mutator]MSP[] { appendOption ( buff , it . next () , true ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR3Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( argName != null && argName . length () == 0 ) MST[NegateConditionalsMutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI2Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR3Mutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[]
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[InlineConstantMutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } prefixList . add ( optBuf ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI4Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR1Mutator]MSP[] { buff . append ( lr_5 ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[] }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR6Mutator]MSP[]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI2Mutator]MSP[] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[MathMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; MST[experimental.NakedReceiverMutator]MSP[] return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { sb . append ( rtrim ( text ) ) ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NegateConditionalsMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI4Mutator]MSP[]
if ( option . hasLongOpt () ) MST[rv.ROR5Mutator]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR1Mutator]MSP[] }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR5Mutator]MSP[]
if ( pos != - 1 && pos <= width ) MST[ConditionalsBoundaryMutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI3Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( ! group . isRequired () ) MST[rv.ROR3Mutator]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI1Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[ReturnValsMutator]MSP[] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR5Mutator]MSP[] }
} if ( header != null && header . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI2Mutator]MSP[] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR6Mutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[] { return pos + 1 ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[]
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI2Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI4Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[rv.ROR5Mutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR1Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[InlineConstantMutator]MSP[]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[] { appendOption ( buff , it . next () , true ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( s == null || s . length () == 0 ) MST[rv.ROR5Mutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[] { final char c = text . charAt ( pos ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
final String lpad = createPadding ( leftPad ) ; MST[NonVoidMethodCallMutator]MSP[] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR4Mutator]MSP[] } final String padding = createPadding ( nextLineTabStop ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR3Mutator]MSP[] { buff . append ( lr_5 ) ; } }
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI4Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( argName != null && argName . length () == 0 ) MST[rv.ROR5Mutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR1Mutator]MSP[] { final String argName = option . getArgName () ;
if ( ! processedGroups . contains ( group ) ) MST[NonVoidMethodCallMutator]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI3Mutator]MSP[] { buff . append ( lr_5 ) ; } }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[]
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[] }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[experimental.RemoveIncrementsMutator]MSP[] if ( optBuf . length () < max ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI1Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[InlineConstantMutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR3Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR3Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR2Mutator]MSP[] { -- pos ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI3Mutator]MSP[] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI3Mutator]MSP[] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[]
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR4Mutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; pw . flush () ; MST[VoidMethodCallMutator]MSP[] } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[ArgumentPropagationMutator]MSP[]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR4Mutator]MSP[]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { appendOption ( buff , it . next () , true ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] }
if ( startPos + width >= text . length () ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR1Mutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[NonVoidMethodCallMutator]MSP[] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
final StringBuffer sb = new StringBuffer () ; MST[ConstructorCallMutator]MSP[] renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR3Mutator]MSP[] { -- pos ;
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ; MST[rv.ABSMutator]MSP[]
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[] { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI1Mutator]MSP[] if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI4Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[] }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; MST[ConstructorCallMutator]MSP[] if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR3Mutator]MSP[]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR4Mutator]MSP[] { -- pos ;
if ( s == null || s . length () == 0 ) MST[NegateConditionalsMutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[ReturnValsMutator]MSP[] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.ABSMutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI1Mutator]MSP[] } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI2Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( pos != - 1 && pos <= width ) MST[NegateConditionalsMutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.UOI1Mutator]MSP[] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[InlineConstantMutator]MSP[] } }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI3Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR5Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR3Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; MST[ReturnValsMutator]MSP[] } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; }
} return s . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI3Mutator]MSP[] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR3Mutator]MSP[] } }
public void setArgName ( final String name ) { this . defaultArgName = name ; MST[experimental.MemberVariableMutator]MSP[] } public String getArgName () { return defaultArgName ; } public Comparator < Option > getOptionComparator () { return optionComparator ; } public void setOptionComparator ( final Comparator < Option > comparator ) {
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } } prefixList . add ( optBuf ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI1Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR5Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI1Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR1Mutator]MSP[] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[] { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ROR2Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR3Mutator]MSP[] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; MST[ReturnValsMutator]MSP[] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI3Mutator]MSP[] } }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI3Mutator]MSP[] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[] { sb . append ( text ) ; return sb ; }
if ( option . hasLongOpt () ) MST[NegateConditionalsMutator]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
this . optionComparator = comparator ; MST[experimental.MemberVariableMutator]MSP[] } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; }
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; } public Comparator < Option > getOptionComparator () { return optionComparator ; MST[NullReturnValsMutator]MSP[] } public void setOptionComparator ( final Comparator < Option > comparator ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[] }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[InlineConstantMutator]MSP[] }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR1Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[VoidMethodCallMutator]MSP[] }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[InlineConstantMutator]MSP[] { sb . append ( text ) ; return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI2Mutator]MSP[] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR3Mutator]MSP[] }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR1Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( startPos + width >= text . length () ) MST[NonVoidMethodCallMutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[MathMutator]MSP[]
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.UOI3Mutator]MSP[]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI3Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[VoidMethodCallMutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( optBuf . length () < max ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI1Mutator]MSP[] if ( optBuf . length () < max ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI3Mutator]MSP[] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR1Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.ABSMutator]MSP[] if ( option . getDescription () != null ) {
while ( ( line = in . readLine () ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[] } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI4Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR6Mutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[] }
if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI2Mutator]MSP[] } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[NegateConditionalsMutator]MSP[] {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI2Mutator]MSP[] if ( option . getDescription () != null ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI3Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; MST[NonVoidMethodCallMutator]MSP[] if ( group != null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR1Mutator]MSP[] {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[] }
printWrapped ( pw , width , 0 , text ) ; MST[rv.ABSMutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR2Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; MST[ConstructorCallMutator]MSP[] if ( getOptionComparator () != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) MST[rv.ROR3Mutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR1Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
return sb ; MST[NullReturnValsMutator]MSP[] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI2Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { sb . append ( rtrim ( text ) ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NegateConditionalsMutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[] { -- pos ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI3Mutator]MSP[] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( footer != null && footer . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ABSMutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.ABSMutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[rv.ROR5Mutator]MSP[] {
if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI3Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR6Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( startPos + width >= text . length () ) MST[rv.AOR2Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[NegateConditionalsMutator]MSP[] {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI2Mutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR1Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD1Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NegateConditionalsMutator]MSP[] { -- pos ;
if ( footer != null && footer . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[experimental.NakedReceiverMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI2Mutator]MSP[] if ( optBuf . length () < max ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI2Mutator]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR5Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[] { return pos + 1 ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.ABSMutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR2Mutator]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI3Mutator]MSP[] } }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI1Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR2Mutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR5Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI3Mutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR6Mutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( s == null || s . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI2Mutator]MSP[]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.ABSMutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR6Mutator]MSP[]
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI2Mutator]MSP[] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[] { return pos + 1 ; }
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR1Mutator]MSP[] { appendOption ( buff , it . next () , true ) ;
if ( startPos + width >= text . length () ) MST[rv.ABSMutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; MST[experimental.MemberVariableMutator]MSP[] } public String getLongOptSeparator () { return longOptSeparator ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR1Mutator]MSP[]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR2Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI3Mutator]MSP[] {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR3Mutator]MSP[] return new String ( padding ) ; } protected String rtrim ( final String s ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR4Mutator]MSP[]
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[rv.ROR5Mutator]MSP[] {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI1Mutator]MSP[] { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOD2Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[NegateConditionalsMutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR2Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[] { return pos + 1 ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( option . getOpt () != null ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR5Mutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[InlineConstantMutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR1Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR1Mutator]MSP[] }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.ABSMutator]MSP[] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR4Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI4Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.ABSMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI1Mutator]MSP[] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[]
optBuf . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
} return s . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[] { sb . append ( text ) ; return sb ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR5Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[InlineConstantMutator]MSP[] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR1Mutator]MSP[] } }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.UOI3Mutator]MSP[] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR3Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR3Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI1Mutator]MSP[] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR4Mutator]MSP[] if ( option . getDescription () != null ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR4Mutator]MSP[] {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI2Mutator]MSP[] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
} return s . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( option . hasLongOpt () ) MST[rv.ROR2Mutator]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI3Mutator]MSP[] } public int getLeftPadding () { return defaultLeftPad ; }
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[VoidMethodCallMutator]MSP[]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR3Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.ABSMutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[] { appendOption ( buff , it . next () , true ) ;
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR1Mutator]MSP[] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI2Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI4Mutator]MSP[] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI4Mutator]MSP[] }
if ( s == null || s . length () == 0 ) MST[rv.ROR5Mutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( ! processedGroups . contains ( group ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR3Mutator]MSP[] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR4Mutator]MSP[]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[InlineConstantMutator]MSP[]
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.ABSMutator]MSP[] if ( optBuf . length () < max ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[VoidMethodCallMutator]MSP[] }
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; MST[ReturnValsMutator]MSP[] } public Comparator < Option > getOptionComparator () { return optionComparator ; } public void setOptionComparator ( final Comparator < Option > comparator ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[ConstructorCallMutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR5Mutator]MSP[] { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; MST[experimental.MemberVariableMutator]MSP[] } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR2Mutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( s == null || s . length () == 0 ) MST[NegateConditionalsMutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[NonVoidMethodCallMutator]MSP[] } }
} if ( header != null && header . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( startPos + width >= text . length () ) MST[rv.AOD2Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[NonVoidMethodCallMutator]MSP[]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR5Mutator]MSP[] { buff . append ( lr_5 ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI2Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[rv.ROR5Mutator]MSP[] {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI3Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI4Mutator]MSP[] { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI1Mutator]MSP[] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] { buff . append ( lr_5 ) ; } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! processedGroups . contains ( group ) ) MST[NegateConditionalsMutator]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; MST[experimental.NakedReceiverMutator]MSP[] final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[]
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI2Mutator]MSP[] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[ReturnValsMutator]MSP[] } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI1Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[NonVoidMethodCallMutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NegateConditionalsMutator]MSP[]
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR4Mutator]MSP[]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.ABSMutator]MSP[] return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) MST[rv.UOI2Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[] } } prefixList . add ( optBuf ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI1Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI3Mutator]MSP[] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.AOR3Mutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
printWrapped ( pw , width , 0 , text ) ; MST[VoidMethodCallMutator]MSP[] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( option . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[] } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR1Mutator]MSP[] { final char c = text . charAt ( pos ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NegateConditionalsMutator]MSP[] } } prefixList . add ( optBuf ) ;
while ( ( line = in . readLine () ) != null ) MST[NonVoidMethodCallMutator]MSP[] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI3Mutator]MSP[] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[ConditionalsBoundaryMutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[NegateConditionalsMutator]MSP[] { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[] { return pos + 1 ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR2Mutator]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( ! required ) { buff . append ( lr_5 ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; MST[NonVoidMethodCallMutator]MSP[] return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI4Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[] {
if ( argName != null && argName . length () == 0 ) MST[NegateConditionalsMutator]MSP[] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI1Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( s == null || s . length () == 0 ) MST[rv.ROR2Mutator]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[ArgumentPropagationMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR2Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[IncrementsMutator]MSP[] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[VoidMethodCallMutator]MSP[]
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[ArgumentPropagationMutator]MSP[] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[] }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR3Mutator]MSP[]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[]
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI2Mutator]MSP[] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI2Mutator]MSP[] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI3Mutator]MSP[] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { final char c = text . charAt ( pos ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR4Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR2Mutator]MSP[]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR5Mutator]MSP[] { appendOption ( buff , it . next () , true ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI3Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOD2Mutator]MSP[] { final char c = text . charAt ( pos ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR1Mutator]MSP[]
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD1Mutator]MSP[] }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR2Mutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[NegateConditionalsMutator]MSP[] { final String argName = option . getArgName () ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[] { Collections . sort ( optList , getOptionComparator () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[ArgumentPropagationMutator]MSP[] } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI2Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[] {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR5Mutator]MSP[] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( startPos + width >= text . length () ) MST[ConditionalsBoundaryMutator]MSP[] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI2Mutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI4Mutator]MSP[] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI3Mutator]MSP[] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[] { sb . append ( text ) ; return sb ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR4Mutator]MSP[] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[InlineConstantMutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR4Mutator]MSP[] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI4Mutator]MSP[] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
} return s . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR2Mutator]MSP[] { buff . append ( lr_5 ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR3Mutator]MSP[] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[]
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; } public Comparator < Option > getOptionComparator () { return optionComparator ; MST[ReturnValsMutator]MSP[] } public void setOptionComparator ( final Comparator < Option > comparator ) {
} return s . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[NegateConditionalsMutator]MSP[] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR6Mutator]MSP[] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR5Mutator]MSP[] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR4Mutator]MSP[] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR2Mutator]MSP[] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; MST[EmptyObjectReturnValsMutator]MSP[] } public Comparator < Option > getOptionComparator () { return optionComparator ; } public void setOptionComparator ( final Comparator < Option > comparator ) {
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[] }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.ABSMutator]MSP[]
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[MathMutator]MSP[] if ( option . getDescription () != null ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[] } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI3Mutator]MSP[] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
public void setWidth ( final int width ) MST[experimental.MemberVariableMutator]MSP[] { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR2Mutator]MSP[] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI4Mutator]MSP[] }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR1Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[] { sb . append ( text ) ; return sb ; }
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ; MST[ConstructorCallMutator]MSP[]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NegateConditionalsMutator]MSP[] { appendOption ( buff , it . next () , true ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[] { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR5Mutator]MSP[] { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI4Mutator]MSP[] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI1Mutator]MSP[] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR1Mutator]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.AOD2Mutator]MSP[] return pos == text . length () ? - 1 : pos ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOD2Mutator]MSP[] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; MST[ConstructorCallMutator]MSP[] if ( option . getOpt () == null ) {
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[ReturnValsMutator]MSP[] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[PrimitiveReturnsMutator]MSP[] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] }
