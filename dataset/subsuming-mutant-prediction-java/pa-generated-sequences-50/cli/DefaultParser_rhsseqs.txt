final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( ch ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[InlineConstantMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR5Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[N] } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[experimental.MemberVariableMutator]MSP[S] currentOption = null ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[S] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[S] break; } } else {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR3Mutator]MSP[N] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[S] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final int pos = t . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final String value = t . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR3Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[S] break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR4Mutator]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[ReturnValsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NegateConditionalsMutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[S] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[S] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR6Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[ConditionalsBoundaryMutator]MSP[N] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; MST[VoidMethodCallMutator]MSP[N] } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR2Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt . hasArg () ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR1Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[InlineConstantMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] {
return false ; MST[rv.CRCR1Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[S] break; } } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return false ; MST[rv.CRCR6Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR4Mutator]MSP[S] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[S] {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR5Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String value = t . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { skipParsing = true ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[ConditionalsBoundaryMutator]MSP[S] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[ConditionalsBoundaryMutator]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options . hasShortOption ( optName ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
} else if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
} else if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[ReturnValsMutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[S] break; } } else {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { return true ; }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR2Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[EmptyObjectReturnValsMutator]MSP[S] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR5Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR6Mutator]MSP[N] break; } } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR2Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } private boolean isLongOption ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[N] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[S] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( allowPartialMatching ) MST[NegateConditionalsMutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[N] if ( arguments != null ) {
handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[S] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[InlineConstantMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR1Mutator]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR5Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[S] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR5Mutator]MSP[N] currentOption = null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR1Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD2Mutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[VoidMethodCallMutator]MSP[N] } }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = option ; } else {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR3Mutator]MSP[N] {
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NegateConditionalsMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR5Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[IncrementsMutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[N]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[S] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR3Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( options . getOptionGroup ( option ) != null ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR5Mutator]MSP[S] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI3Mutator]MSP[N] skipParsing = false ; currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N]
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NegateConditionalsMutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI3Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ABSMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR4Mutator]MSP[S] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption = option ; } else {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[VoidMethodCallMutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[N] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] final boolean selected = group != null && group . getSelected () != null ;
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; MST[NonVoidMethodCallMutator]MSP[N] updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
return true ; MST[rv.CRCR6Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR3Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[rv.ROR5Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N]
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[ReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[ReturnValsMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[N] } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[N] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[S] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[N] }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[N] handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[S] break; } } else {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
} else if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR5Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR5Mutator]MSP[S] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[S]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[InlineConstantMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[S]
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
} else if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR4Mutator]MSP[S] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR4Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N]
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[S] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[NegateConditionalsMutator]MSP[N] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N]
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[MathMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
currentOption = null ; MST[experimental.MemberVariableMutator]MSP[S] } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
return false ; MST[rv.CRCR3Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ReturnValsMutator]MSP[N] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; MST[experimental.MemberVariableMutator]MSP[N] this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[S] } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleLongOptionWithEqual ( token ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[S] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[S] { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR2Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = option ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[S] } } else if ( isJavaProperty ( opt ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N]
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { currentOption = option ; } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; MST[rv.CRCR5Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[S] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
handleOption ( options . getOption ( ch ) ) ; MST[VoidMethodCallMutator]MSP[N] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) MST[rv.UOI1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[S]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[N] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ConditionalsBoundaryMutator]MSP[N] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[InlineConstantMutator]MSP[N] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[S] { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NonVoidMethodCallMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI2Mutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[ConstructorCallMutator]MSP[S] if ( options . hasLongOption ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[VoidMethodCallMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[N] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
} else if ( pos == - 1 ) MST[rv.ABSMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[N] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[N] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[S] break; } } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[N] {
Option option = options . getOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] matches . add ( option . getLongOpt () ) ; } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[S] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR3Mutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[N] {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[S] } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NegateConditionalsMutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[MathMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[S] {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR1Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[InlineConstantMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI4Mutator]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; MST[InlineConstantMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[S] break; } } }
cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR5Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[InlineConstantMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR1Mutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) MST[rv.ROR2Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; MST[ConstructorCallMutator]MSP[N] } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String prefix = t . substring ( 0 , i ) ; MST[experimental.NakedReceiverMutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[S] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[InlineConstantMutator]MSP[N] currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR6Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[S] break; } } }
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[ArgumentPropagationMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR3Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[InlineConstantMutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR3Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; MST[rv.CRCR3Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { currentOption = option ; } else {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { skipParsing = true ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR3Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[InlineConstantMutator]MSP[S] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ReturnValsMutator]MSP[N] } private boolean isLongOption ( final String token ) {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[NegateConditionalsMutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR3Mutator]MSP[N] currentOption = null ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[N] } cmd = new CommandLine () ; if ( arguments != null ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[N] if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[rv.ROR5Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[S] break; } } else {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[N] { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[N] option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[N] }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[ArgumentPropagationMutator]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { skipParsing = true ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NonVoidMethodCallMutator]MSP[S] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[S]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[N] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[N] break; } } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR4Mutator]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[S] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return true ; MST[InlineConstantMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; MST[VoidMethodCallMutator]MSP[N] if ( option . hasArg () ) { currentOption = option ; } else {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[InlineConstantMutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] break; } } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N]
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[N] break; } } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[S] { return true ; }
} else if ( pos == - 1 ) MST[rv.UOI3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR6Mutator]MSP[N] currentOption = null ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR2Mutator]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[N] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR6Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[N] }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR2Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N]
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[S] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[InlineConstantMutator]MSP[N] } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI1Mutator]MSP[N] skipParsing = false ; currentOption = null ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR5Mutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[ConditionalsBoundaryMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI2Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[InlineConstantMutator]MSP[N] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[ReturnValsMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break; } } else {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[N] checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NegateConditionalsMutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[N] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI4Mutator]MSP[N] skipParsing = false ; currentOption = null ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR4Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[ConditionalsBoundaryMutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( option != null && option . acceptsArg () ) {
return true ; MST[rv.CRCR2Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR3Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; MST[ConstructorCallMutator]MSP[S] } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR6Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[N] } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR4Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[N] }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S]
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NegateConditionalsMutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR5Mutator]MSP[S] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; MST[ConstructorCallMutator]MSP[S] } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[N] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[S] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR3Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[S]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[N] } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { handleLongOptionWithoutEqual ( token ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasShortOption ( optName ) ) {
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[S] break; } } else {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR1Mutator]MSP[N] currentOption = null ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[experimental.MemberVariableMutator]MSP[N] skipParsing = false ; currentOption = null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR1Mutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; MST[VoidMethodCallMutator]MSP[N] } } private List < String > getMatchingLongOptions ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR6Mutator]MSP[S] {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] || lr_3 . equalsIgnoreCase ( value )
return true ; MST[ReturnValsMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI4Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
return false ; MST[ReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[ReturnValsMutator]MSP[S] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[N] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD1Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[S] { return true ; }
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } } private boolean isArgument ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR5Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR4Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[N] }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[N] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[VoidMethodCallMutator]MSP[S] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[N] return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
return false ; MST[rv.CRCR5Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR3Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[ReturnValsMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( options . getOptionGroup ( option ) != null ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR2Mutator]MSP[N] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = option ; } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[InlineConstantMutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR2Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[S]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } catch ( final NumberFormatException e ) { return false ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[N] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S]
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[S] { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { skipParsing = true ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } } else { final String opt = t . substring ( 0 , pos ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[InlineConstantMutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR3Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N]
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR2Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[N]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NegateConditionalsMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[ReturnValsMutator]MSP[N] } private boolean isJavaProperty ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[S]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[ReturnValsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; MST[experimental.MemberVariableMutator]MSP[N] if ( skipParsing ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[InlineConstantMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[S]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[S]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { skipParsing = true ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI2Mutator]MSP[N] skipParsing = false ; currentOption = null ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return true ; MST[rv.CRCR4Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[S] }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return true ; }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) MST[rv.ROR3Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[N] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[N] break; } } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[MathMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[InlineConstantMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[N] break; } } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[S] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N]
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.ABSMutator]MSP[N] skipParsing = false ; currentOption = null ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = option ; } else {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR3Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { currentOption = option ; } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[ReturnValsMutator]MSP[N] } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR4Mutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR1Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N]
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.UOI4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR4Mutator]MSP[S] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR4Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[S]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[N] } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[S] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} else if ( pos == - 1 ) MST[rv.UOI2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { currentOption = option ; } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[S] break; } } else {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
handleShortAndLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; MST[experimental.MemberVariableMutator]MSP[N] } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[N] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[S] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR5Mutator]MSP[S] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR1Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[S] {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR2Mutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[S] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NonVoidMethodCallMutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR4Mutator]MSP[N] break; } } }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ;
return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[rv.ROR1Mutator]MSP[S] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[VoidMethodCallMutator]MSP[N] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[S] break; } } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[S]
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR1Mutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[S] currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[S] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; MST[VoidMethodCallMutator]MSP[N] cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR2Mutator]MSP[N] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[N] if ( arguments != null ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[MathMutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String value = t . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[N] break; } } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[N] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[N]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[N] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } private boolean isJavaProperty ( final String token ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ABSMutator]MSP[S] {
