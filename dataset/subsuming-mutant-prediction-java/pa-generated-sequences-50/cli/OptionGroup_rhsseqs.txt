return optionMap . values () ; MST[ReturnValsMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > getNames () { return optionMap . keySet () ; MST[NonVoidMethodCallMutator]MSP[N] } public Collection < Option > getOptions () {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] } public boolean isRequired ()
buff . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[S] } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
{ return required ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR5Mutator]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > getNames () { return optionMap . keySet () ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Collection < Option > getOptions () {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( iter . hasNext () ) {
selected = option . getKey () ; MST[experimental.MemberVariableMutator]MSP[N] } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] while ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buff . toString () ; }
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_3 ) ;
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NonVoidMethodCallMutator]MSP[S] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; MST[ReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N]
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[ReturnValsMutator]MSP[N] }
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NegateConditionalsMutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR2Mutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] } public boolean isRequired ()
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; MST[ReturnValsMutator]MSP[S] } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } buff . append ( lr_6 ) ; return buff . toString () ; }
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
selected = option . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } buff . append ( lr_6 ) ; return buff . toString () ; }
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR5Mutator]MSP[N] {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[S] } public boolean isRequired ()
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR3Mutator]MSP[N] {
return optionMap . values () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NonVoidMethodCallMutator]MSP[S] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; MST[ConstructorCallMutator]MSP[S] } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR1Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buff . toString () ; }
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[ArgumentPropagationMutator]MSP[N] return this ; } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
{ return required ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
{ return required ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR4Mutator]MSP[S] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; MST[experimental.MemberVariableMutator]MSP[S] return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
return optionMap . values () ; MST[NonVoidMethodCallMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[S] } public boolean isRequired ()
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NegateConditionalsMutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > getNames () { return optionMap . keySet () ; MST[ReturnValsMutator]MSP[N] } public Collection < Option > getOptions () {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
