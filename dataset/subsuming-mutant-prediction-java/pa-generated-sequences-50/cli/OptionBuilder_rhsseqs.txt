public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[ReturnValsMutator]MSP[N] }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; MST[VoidMethodCallMutator]MSP[S] option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[InlineConstantMutator]MSP[S]
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ; MST[VoidMethodCallMutator]MSP[S]
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[ReturnValsMutator]MSP[S] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI3Mutator]MSP[N] return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[InlineConstantMutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.ABSMutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; MST[VoidMethodCallMutator]MSP[N] option . setArgName ( argName ) ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ; MST[ConstructorCallMutator]MSP[N]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI3Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
finally { OptionBuilder . reset () ; } return option ; MST[ReturnValsMutator]MSP[N] }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI2Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR5Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
finally { OptionBuilder . reset () ; MST[VoidMethodCallMutator]MSP[N] } return option ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[NullReturnValsMutator]MSP[S] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR6Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; MST[VoidMethodCallMutator]MSP[N] option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[NullReturnValsMutator]MSP[S] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR2Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI4Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { OptionBuilder . reset () ;
finally { OptionBuilder . reset () ; } return option ; MST[NullReturnValsMutator]MSP[N] }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR6Mutator]MSP[S]
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR4Mutator]MSP[N]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR5Mutator]MSP[S]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR3Mutator]MSP[N]
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[NegateConditionalsMutator]MSP[N] { OptionBuilder . reset () ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[VoidMethodCallMutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR3Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR5Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.ABSMutator]MSP[S] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[NegateConditionalsMutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ABSMutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[InlineConstantMutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI1Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI4Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[rv.ROR5Mutator]MSP[N] { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; MST[VoidMethodCallMutator]MSP[S] option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.ABSMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[NonVoidMethodCallMutator]MSP[N] }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; MST[VoidMethodCallMutator]MSP[S] option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR6Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR4Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR2Mutator]MSP[S]
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
