matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[VoidMethodCallMutator]MSP[S] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
{ addOption ( opt , null , false , description ) ; MST[InlineConstantMutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[S] option . setRequired ( true ) ; addOption ( option ) ;
return this ; MST[NullReturnValsMutator]MSP[S] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public List getRequiredOptions () {
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR1Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[S] } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[N] }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List getRequiredOptions () {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N]
{ if ( requiredOpts . contains ( key ) ) MST[NegateConditionalsMutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR5Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ArgumentPropagationMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.ABSMutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR3Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[ReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR1Mutator]MSP[N] addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[S]
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.ABSMutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[N] }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR5Mutator]MSP[N] addOption ( option ) ;
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR1Mutator]MSP[S] { return shortOpts . get ( opt ) ; }
public Options addOptionGroup ( final OptionGroup group ) MST[ConstructorCallMutator]MSP[N] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( opt . isRequired () )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[ReturnValsMutator]MSP[S] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NegateConditionalsMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI3Mutator]MSP[N] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return shortOpts . get ( opt ) ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < String > matchingOpts = new ArrayList < String > () ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N]
optionGroups . put ( option . getKey () , group ) ; MST[ArgumentPropagationMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR2Mutator]MSP[S] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR3Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR6Mutator]MSP[S] addOption ( option ) ;
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[S] final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[N] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR3Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR5Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR4Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR2Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[S]
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ReturnValsMutator]MSP[N] } public List getRequiredOptions () {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR6Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[InlineConstantMutator]MSP[S] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[ConstructorCallMutator]MSP[S] option . setRequired ( true ) ; addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI4Mutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NegateConditionalsMutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NullReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NegateConditionalsMutator]MSP[N] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[ReturnValsMutator]MSP[N] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[N] }
return longOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[S] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[N] }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI1Mutator]MSP[N] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buf . toString () ; }
buf . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR1Mutator]MSP[S] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ReturnValsMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[N] }
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addOptionGroup ( final OptionGroup group ) MST[experimental.MemberVariableMutator]MSP[N] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ addOption ( opt , null , false , description ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
{ addOption ( opt , null , false , description ) ; return this ; MST[NullReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR1Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[S] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.ABSMutator]MSP[N] return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR3Mutator]MSP[N] {
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N]
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR2Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) MST[NonVoidMethodCallMutator]MSP[S] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) MST[NonVoidMethodCallMutator]MSP[N] { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[S] }
return shortOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; return this ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[ArgumentPropagationMutator]MSP[N] return this ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N]
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR2Mutator]MSP[N] }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR4Mutator]MSP[N] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR3Mutator]MSP[N] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR4Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR2Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR1Mutator]MSP[S] {
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[InlineConstantMutator]MSP[N] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR5Mutator]MSP[S] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[N] }
return this ; MST[ReturnValsMutator]MSP[S] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ConstructorCallMutator]MSP[N] } public Options addOption ( final String opt , final String description )
buf . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Options addOption ( final String opt , final String description )
return Collections . unmodifiableList ( requiredOpts ) ; MST[ReturnValsMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[ArgumentPropagationMutator]MSP[N] } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR1Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[S]
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final String description )
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR4Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR3Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return longOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[S] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[N] return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NegateConditionalsMutator]MSP[N] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR2Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( lr_3 ) ; return buf . toString () ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR1Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR4Mutator]MSP[S] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR5Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI2Mutator]MSP[N] return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NonVoidMethodCallMutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[N] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_3 ) ; return buf . toString () ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[N] return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ConstructorCallMutator]MSP[N] } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[ReturnValsMutator]MSP[S] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[ArgumentPropagationMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR3Mutator]MSP[N] addOption ( option ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR6Mutator]MSP[N] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S]
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[VoidMethodCallMutator]MSP[N] addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR3Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( opt . isRequired () )
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
return Collections . unmodifiableList ( requiredOpts ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[ConstructorCallMutator]MSP[N] return this ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[ReturnValsMutator]MSP[S] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR4Mutator]MSP[N] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR5Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR5Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) MST[NonVoidMethodCallMutator]MSP[N] { if ( longOpt . startsWith ( opt ) ) {
