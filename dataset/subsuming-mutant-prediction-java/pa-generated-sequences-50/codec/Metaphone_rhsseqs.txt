public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[InlineConstantMutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR3Mutator]MSP[S] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[NonVoidMethodCallMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI3Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR2Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] break; } code . append ( symb ) ; break; case 'C' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N]
code . append ( 'H' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI3Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ABSMutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[InlineConstantMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; MST[ReturnValsMutator]MSP[N] } if ( txtLength == 1 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI1Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[NegateConditionalsMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_8 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI3Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR1Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR6Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'K' : if ( n > 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR5Mutator]MSP[N]
return n + 1 == wdsz ; MST[NegateConditionalsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[rv.AOD1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ABSMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR1Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR4Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N]
} else { code . append ( 'T' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[ConditionalsBoundaryMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR4Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ABSMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return code . toString () ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR4Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ABSMutator]MSP[N] if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && MST[rv.ROR1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
return n + 1 == wdsz ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI3Mutator]MSP[N] }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: local . append ( inwd ) ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR4Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR1Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR2Mutator]MSP[S] break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR2Mutator]MSP[S] break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[IncrementsMutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI4Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI3Mutator]MSP[N] } return matches ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR4Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[ReturnValsMutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR2Mutator]MSP[S]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
isNextChar ( local , n , 'H' ) && MST[rv.CRCR2Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S]
if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI4Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[InlineConstantMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[experimental.NakedReceiverMutator]MSP[N] case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] code . append ( 'J' ) ; n += 2 ;
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOD2Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && MST[rv.AOR3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI2Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR1Mutator]MSP[S] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR1Mutator]MSP[N] } return matches ; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR4Mutator]MSP[S] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR5Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR1Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI4Mutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[MathMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR6Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[NegateConditionalsMutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[MathMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR4Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.ROR2Mutator]MSP[S] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.UOI2Mutator]MSP[S] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[NegateConditionalsMutator]MSP[N]
return n + 1 == wdsz ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.CRCR5Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[NegateConditionalsMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR4Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR6Mutator]MSP[N] case 'W' : case 'Y' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR5Mutator]MSP[N] break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR5Mutator]MSP[N] break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[NonVoidMethodCallMutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI3Mutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR2Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR1Mutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR1Mutator]MSP[N] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR2Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR4Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[InlineConstantMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; MST[InlineConstantMutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.ABSMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[NonVoidMethodCallMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[MathMutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
public String metaphone ( final String txt ) { MST[rv.CRCR2Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI3Mutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR4Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
return n + 1 == wdsz ; MST[rv.ROR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR5Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'D' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI3Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} return matches ; MST[rv.UOI3Mutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD2Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR1Mutator]MSP[N]
code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR1Mutator]MSP[S] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[InlineConstantMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI1Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[InlineConstantMutator]MSP[S]
boolean matches = false ; if( index > 0 && MST[rv.ABSMutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI4Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR4Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NonVoidMethodCallMutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR5Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[N] if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR2Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR4Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[S] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.CRCR4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR1Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR3Mutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] break; }
if ( regionMatch ( local , n , lr_8 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[N] } @Override
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ABSMutator]MSP[N] break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR3Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR1Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI2Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'T' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'K' : if ( n > 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[InlineConstantMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR3Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ABSMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[ConditionalsBoundaryMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR2Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[S] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR1Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
isNextChar ( local , n , 'H' ) && MST[rv.ROR4Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[InlineConstantMutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ABSMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.AOR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[experimental.NakedReceiverMutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NegateConditionalsMutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR1Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N]
public String metaphone ( final String txt ) { MST[NegateConditionalsMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR5Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR3Mutator]MSP[S]
} return matches ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ABSMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR4Mutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR1Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI2Mutator]MSP[S] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N] } return matches ; }
code . append ( 'F' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[NegateConditionalsMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
isNextChar ( local , n , 'H' ) && MST[rv.UOI3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.CRCR6Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[MathMutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOD1Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR2Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR1Mutator]MSP[S]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[NegateConditionalsMutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR5Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[S]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N] if ( n == 0 &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ABSMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR2Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR1Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[NegateConditionalsMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR5Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR5Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR5Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[NegateConditionalsMutator]MSP[N] } return matches ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[InlineConstantMutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR4Mutator]MSP[S]
public String metaphone ( final String txt ) { boolean hard = false ; MST[InlineConstantMutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[NegateConditionalsMutator]MSP[N] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[NegateConditionalsMutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI4Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && MST[rv.ROR3Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.ABSMutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[NegateConditionalsMutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'F' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
local . setCharAt ( 0 , 'W' ) ; MST[VoidMethodCallMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR3Mutator]MSP[N]
public String encode ( final String str ) { return metaphone ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR1Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'T' :
code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI2Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR2Mutator]MSP[N] case 'W' : case 'Y' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
local . setCharAt ( 0 , 'W' ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[NegateConditionalsMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[N] } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && MST[NonVoidMethodCallMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ArgumentPropagationMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NonVoidMethodCallMutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.ROR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR4Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR5Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[ReturnValsMutator]MSP[N] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR1Mutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ArgumentPropagationMutator]MSP[N] }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[ArgumentPropagationMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
return n + 1 == wdsz ; MST[MathMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI4Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[NegateConditionalsMutator]MSP[N]
public String metaphone ( final String txt ) { MST[rv.UOI2Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR2Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI2Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI3Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
public String metaphone ( final String txt ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR2Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[InlineConstantMutator]MSP[N] if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR3Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[MathMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR5Mutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR4Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'S' ) ; break; default: break; } n ++ ; MST[IncrementsMutator]MSP[N] } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
public String metaphone ( final String txt ) { MST[rv.ROR5Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; }
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR4Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR2Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[S]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR6Mutator]MSP[N]
boolean matches = false ; MST[rv.CRCR1Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR5Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[ConditionalsBoundaryMutator]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR6Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( regionMatch ( local , n , lr_8 ) || MST[NonVoidMethodCallMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[S]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[NegateConditionalsMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR4Mutator]MSP[N]
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR4Mutator]MSP[S] matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI3Mutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'H' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[NegateConditionalsMutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR2Mutator]MSP[S] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[NegateConditionalsMutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
public String metaphone ( final String txt ) { MST[rv.CRCR2Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR1Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR5Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR1Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
return n + 1 == wdsz ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] code . append ( 'S' ) ; break; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[ReturnValsMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI1Mutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR4Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOD2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR5Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR2Mutator]MSP[S] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ABSMutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR5Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public String metaphone ( final String txt ) { MST[InlineConstantMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NonVoidMethodCallMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] code . append ( 'J' ) ; n += 2 ;
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
return n + 1 == wdsz ; MST[rv.UOI2Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; MST[NonVoidMethodCallMutator]MSP[N] int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.AOR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR5Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR3Mutator]MSP[S] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] matches = string . charAt ( index + 1 ) == c ;
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'D' :
} return matches ; MST[ReturnValsMutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR4Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[NegateConditionalsMutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR5Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'Z' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR2Mutator]MSP[N]
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR4Mutator]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[InlineConstantMutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR1Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
boolean matches = false ; if( index > 0 && MST[rv.ROR2Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'D' :
code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_4]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_5]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_3]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI2Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR2Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] break; case 'C' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NegateConditionalsMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR5Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI1Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR1Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[InlineConstantMutator]MSP[S]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI2Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[InlineConstantMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR5Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[InlineConstantMutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR3Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
boolean matches = false ; if( index > 0 && MST[rv.ROR5Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR3Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_3]MSP[S] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_4]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_5]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NegateConditionalsMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR2Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR6Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.ABSMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
isNextChar ( local , n , 'H' ) && MST[rv.AOD2Mutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI4Mutator]MSP[N] if ( n == 0 &&
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR5Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI3Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR1Mutator]MSP[N] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR1Mutator]MSP[N] break; }
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR6Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.ROR1Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI2Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR2Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NegateConditionalsMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR2Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'K' : if ( n > 0 ) {
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR3Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[S]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI2Mutator]MSP[S] }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[S] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR3Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( n == 0 &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'K' : if ( n > 0 ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'S' ) ; break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR3Mutator]MSP[S] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR1Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && MST[rv.CRCR6Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'T' :
code . append ( 'F' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOD1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
return n + 1 == wdsz ; MST[rv.ABSMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[InlineConstantMutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI2Mutator]MSP[S] } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.ABSMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[BooleanFalseReturnValsMutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR5Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[N] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[NonVoidMethodCallMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI4Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[S]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR5Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR3Mutator]MSP[N] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR4Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[ConditionalsBoundaryMutator]MSP[S] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ABSMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR4Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI3Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[InlineConstantMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR6Mutator]MSP[N]
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI1Mutator]MSP[S] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI4Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[ConditionalsBoundaryMutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR5Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( n == 0 &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'T' :
if ( regionMatch ( local , n , lr_8 ) || MST[NegateConditionalsMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR5Mutator]MSP[S]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[InlineConstantMutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR3Mutator]MSP[N] case 'W' : case 'Y' :
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR2Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI3Mutator]MSP[N]
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR1Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR2Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI2Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR3Mutator]MSP[N] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[S] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . setCharAt ( 0 , 'W' ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR4Mutator]MSP[S] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR4Mutator]MSP[N] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR4Mutator]MSP[N] } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI1Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR5Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[InlineConstantMutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; MST[VoidMethodCallMutator]MSP[N] } } return code . toString () ; }
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR1Mutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { MST[rv.ROR1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[InlineConstantMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR3Mutator]MSP[S] return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOD1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
boolean matches = false ; MST[rv.CRCR5Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[ConstructorCallMutator]MSP[N] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI2Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[ConditionalsBoundaryMutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_8]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_9]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_6]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR3Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_7]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR3Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR1Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR1Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N] } return matches ; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR2Mutator]MSP[S] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI1Mutator]MSP[N] break; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[NegateConditionalsMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
code . append ( 'H' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR2Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ABSMutator]MSP[S] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ABSMutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR1Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[InlineConstantMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR6Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[ConditionalsBoundaryMutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR3Mutator]MSP[S] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR5Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI4Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR2Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI2Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[NonVoidMethodCallMutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
return n + 1 == wdsz ; MST[rv.CRCR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI2Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
regionMatch ( local , n , lr_6 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[NonVoidMethodCallMutator]MSP[N] case 'W' : case 'Y' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR5Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI3Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[rv.ROR3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI4Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR1Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR1Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR1Mutator]MSP[S]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
return n + 1 == wdsz ; MST[rv.ROR4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR5Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { code . append ( 'T' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'H' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S]
code . append ( 'F' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR4Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI1Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.CRCR5Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR6Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOD2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI1Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR3Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( isPreviousChar ( local , n , 'S' ) && MST[NegateConditionalsMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR4Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR3Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR1Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.CRCR6Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[S]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR5Mutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI4Mutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'C' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[ArgumentPropagationMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'H' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[NonVoidMethodCallMutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR3Mutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ArgumentPropagationMutator]MSP[N] }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR5Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[ConditionalsBoundaryMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'S' ) ; break; }
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ABSMutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR2Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[NegateConditionalsMutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[BooleanFalseReturnValsMutator]MSP[N] }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR6Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR1Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI3Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
return n + 1 == wdsz ; MST[ReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N]
code . append ( 'F' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR3Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ABSMutator]MSP[S]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[NegateConditionalsMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] index + test . length () - 1 < string . length () ) {
public String metaphone ( final String txt ) { MST[rv.CRCR4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[S]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI3Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR2Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR2Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[ReturnValsMutator]MSP[N] }
code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[NonVoidMethodCallMutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'H' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR3Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI2Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR3Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
return n + 1 == wdsz ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.ABSMutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ABSMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR4Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] break; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR4Mutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR5Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR1Mutator]MSP[N] } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR6Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI1Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public String metaphone ( final String txt ) { MST[rv.ROR4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI2Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( n == 0 &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'T' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR1Mutator]MSP[N] case 'W' : case 'Y' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[NegateConditionalsMutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOD1Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
return n + 1 == wdsz ; MST[rv.AOD2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[experimental.NakedReceiverMutator]MSP[N] final StringBuilder local = new StringBuilder ( 40 ) ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR1Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR1Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR5Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'D' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[NegateConditionalsMutator]MSP[N] index + test . length () - 1 < string . length () ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI4Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR1Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR4Mutator]MSP[N] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR3Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[NonVoidMethodCallMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR3Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI2Mutator]MSP[S] } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( 'H' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && MST[rv.ROR1Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; MST[ConstructorCallMutator]MSP[S] } return metaphone ( ( String ) obj ) ; } @Override
public String metaphone ( final String txt ) { MST[InlineConstantMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI2Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI4Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR3Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR6Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.ABSMutator]MSP[S] } private boolean isLastChar ( final int wdsz , final int n ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[InlineConstantMutator]MSP[S]
boolean matches = false ; if( index > 0 && MST[rv.ABSMutator]MSP[S] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[N] } @Override
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR1Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; MST[InlineConstantMutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N]
} return matches ; MST[BooleanFalseReturnValsMutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR5Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR3Mutator]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR4Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isLastChar ( wdsz , n ) ) { MST[rv.ABSMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( 'F' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[NegateConditionalsMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.AOR4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR3Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR5Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ABSMutator]MSP[N] } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[InlineConstantMutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[InlineConstantMutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR3Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ABSMutator]MSP[N]
code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[ConditionalsBoundaryMutator]MSP[N] index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR3Mutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[NegateConditionalsMutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index + test . length () - 1 < string . length () ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_13]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_14]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
isNextChar ( local , n , 'H' ) && MST[NonVoidMethodCallMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_15]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_16]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_17]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR1Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_18]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI1Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_19]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] break; case 'K' : if ( n > 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[N] code . append ( 'S' ) ; break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[InlineConstantMutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[S] } return matches ; }
code . append ( 'H' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
boolean matches = false ; if( index > 0 && MST[ConditionalsBoundaryMutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( n == 0 &&
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[ReturnValsMutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ABSMutator]MSP[S]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI1Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_20]MSP[S] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_21]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_22]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR2Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_23]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_24]MSP[S] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_25]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
boolean matches = false ; MST[rv.CRCR6Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
boolean matches = false ; if( index > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public String metaphone ( final String txt ) { MST[experimental.MemberVariableMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI1Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[InlineConstantMutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOD1Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI2Mutator]MSP[S]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD2Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR3Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR6Mutator]MSP[N]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR2Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] break; case 'K' : if ( n > 0 ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR4Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI2Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR3Mutator]MSP[S] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_10]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_11]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_12]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; MST[rv.UOI2Mutator]MSP[S] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR5Mutator]MSP[S]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[NonVoidMethodCallMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR2Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR4Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
return n + 1 == wdsz ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR2Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
public String metaphone ( final String txt ) { MST[rv.CRCR1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR5Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR5Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} return matches ; MST[rv.ABSMutator]MSP[S] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ABSMutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ABSMutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ABSMutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NegateConditionalsMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR5Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.ABSMutator]MSP[S] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR2Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI3Mutator]MSP[N] if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.UOI1Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[InlineConstantMutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR2Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR4Mutator]MSP[N] case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOD2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI2Mutator]MSP[S] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'H' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR2Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
return n + 1 == wdsz ; MST[rv.ROR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.ABSMutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NonVoidMethodCallMutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ABSMutator]MSP[S]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR4Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI3Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR3Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[InlineConstantMutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI4Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR4Mutator]MSP[S] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI4Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR3Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR5Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR4Mutator]MSP[N]
boolean matches = false ; if( index > 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOD2Mutator]MSP[N] } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR1Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR5Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR1Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[MathMutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI2Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.ABSMutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR5Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[S]
boolean matches = false ; if( index > 0 && MST[NegateConditionalsMutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR6Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[S] code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR5Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR4Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( n == 0 &&
return n + 1 == wdsz ; MST[rv.UOI1Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final String substring = string . substring ( index , index + test . length () ) ; MST[MathMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR3Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOD2Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[ConditionalsBoundaryMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
isNextChar ( local , n , 'H' ) && MST[rv.AOR2Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && MST[InlineConstantMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI1Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NonVoidMethodCallMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI3Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.UOI2Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOD2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR3Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[S]
isNextChar ( local , n , 'H' ) && MST[rv.CRCR3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR3Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR2Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR2Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR2Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR3Mutator]MSP[N] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR3Mutator]MSP[N] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR3Mutator]MSP[N] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NegateConditionalsMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ABSMutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[NegateConditionalsMutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR2Mutator]MSP[N]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NonVoidMethodCallMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR2Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[S] code . append ( 'J' ) ; n += 2 ;
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR5Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI1Mutator]MSP[S]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR1Mutator]MSP[S] break; } code . append ( symb ) ; break; case 'C' :
code . append ( 'H' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR2Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NegateConditionalsMutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR4Mutator]MSP[S] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR5Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
public String metaphone ( final String txt ) { MST[rv.ROR3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[ConditionalsBoundaryMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR5Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR6Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
isNextChar ( local , n , 'H' ) && MST[rv.UOI1Mutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR4Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[NonVoidMethodCallMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR1Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[InlineConstantMutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR2Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI4Mutator]MSP[N] } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[rv.ROR2Mutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR2Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI3Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI4Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR4Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[S] break; } if ( isVowel ( local , n + 1 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[ConstructorCallMutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI4Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR6Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI4Mutator]MSP[N] }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR2Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR2Mutator]MSP[N] } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR2Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR1Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI3Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR3Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
isNextChar ( local , n , 'H' ) && MST[NegateConditionalsMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
return n + 1 == wdsz ; MST[rv.CRCR1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N]
} else { code . append ( 'T' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR3Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NonVoidMethodCallMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NegateConditionalsMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR4Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR4Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[MathMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[S] index + test . length () - 1 < string . length () ) {
} return matches ; MST[rv.UOI4Mutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S] if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR3Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR5Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[S]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI4Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR4Mutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI3Mutator]MSP[N] break; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ReturnValsMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( regionMatch ( local , n , lr_11 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'H' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR5Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[NonVoidMethodCallMutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR3Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.ABSMutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR3Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[MathMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR2Mutator]MSP[N]
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI4Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR5Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR5Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI2Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR6Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[rv.CRCR1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR2Mutator]MSP[N]
boolean matches = false ; MST[rv.CRCR3Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[ConditionalsBoundaryMutator]MSP[N]
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.UOI1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR5Mutator]MSP[N] } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR5Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR6Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR2Mutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI4Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR4Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'D' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.ROR5Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[N] } return matches ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR3Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR1Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR1Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[rv.AOR4Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR3Mutator]MSP[S]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI3Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[InlineConstantMutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI3Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR4Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI1Mutator]MSP[S]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR3Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR5Mutator]MSP[N] case 'W' : case 'Y' :
return n + 1 == wdsz ; MST[rv.AOD1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR4Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR3Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR2Mutator]MSP[N] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR3Mutator]MSP[S]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI4Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N] if ( n == 0 &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR5Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR2Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI1Mutator]MSP[S] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR6Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[N]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR5Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[InlineConstantMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[MathMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.SwitchMutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NegateConditionalsMutator]MSP[N]
isNextChar ( local , n , 'H' ) && MST[rv.CRCR4Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NegateConditionalsMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR1Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'F' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR6Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI3Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOD1Mutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && MST[rv.ROR4Mutator]MSP[S] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI4Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR1Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'D' :
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOD1Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR3Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI1Mutator]MSP[S] }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR4Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[S]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI1Mutator]MSP[S] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR3Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.ABSMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return n + 1 == wdsz ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR3Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR2Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR6Mutator]MSP[N]
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] break; case 'K' : if ( n > 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR5Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR3Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.UOI1Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR6Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR4Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI1Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR3Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR4Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[NegateConditionalsMutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ABSMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR4Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR4Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[NegateConditionalsMutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[NegateConditionalsMutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR2Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ABSMutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR5Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI1Mutator]MSP[S]
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[S] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR2Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR4Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR5Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[PrimitiveReturnsMutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} return matches ; MST[rv.UOI1Mutator]MSP[S] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI4Mutator]MSP[N]
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NegateConditionalsMutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR5Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[InlineConstantMutator]MSP[N] case 'W' : case 'Y' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[ReturnValsMutator]MSP[N] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[rv.AOR1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[InlineConstantMutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR5Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI4Mutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} else { code . append ( 'T' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[rv.AOR1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'H' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.SwitchMutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI1Mutator]MSP[S] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR2Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ABSMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR6Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ReturnValsMutator]MSP[N] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI4Mutator]MSP[N]
code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR5Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI2Mutator]MSP[N] if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR6Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[S]
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[InlineConstantMutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.CRCR4Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR1Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR4Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR5Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
